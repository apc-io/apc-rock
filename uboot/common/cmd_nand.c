/*
 * Driver for NAND support, Rick Bronson
 * borrowed heavily from:
 * (c) 1999 Machine Vision Holdings, Inc.
 * (c) 1999, 2000 David Woodhouse <dwmw2@infradead.org>
 *
 * Added 16-bit nand support
 * (C) 2004 Texas Instruments
 */

#include <common.h>
#include <command.h>
#include <malloc.h>
#include <asm/io.h>
//#include <watchdog.h>
#include <nand.h>

#ifdef CONFIG_SHOW_BOOT_PROGRESS
# include <status_led.h>
# define SHOW_BOOT_PROGRESS(arg)	show_boot_progress(arg)
#else
# define SHOW_BOOT_PROGRESS(arg)
#endif

//#if (CONFIG_COMMANDS & CFG_CMD_NAND)

#include <linux/mtd/nand.h>
#include <linux/mtd/nand_ids.h>
#include <jffs2/jffs2.h>

#ifdef CONFIG_OMAP1510
void archflashwp(void *archdata, int wp);
#endif

#define ROUND_DOWN(value,boundary)      ((value) & (~((boundary)-1)))

extern unsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base);
/*
 * Definition of the out of band configuration structure
 */
struct nand_oob_config {
	int ecc_pos[6];		/* position of ECC bytes inside oob */
	int badblock_pos;	/* position of bad block flag inside oob -1 = inactive */
	int eccvalid_pos;	/* position of ECC valid flag inside oob -1 = inactive */
} oob_config = { {0}, 0, 0};

#undef	NAND_DEBUG
#undef	PSYCHO_DEBUG

/* ****************** WARNING *********************
 * When ALLOW_ERASE_BAD_DEBUG is non-zero the erase command will
 * erase (or at least attempt to erase) blocks that are marked
 * bad. This can be very handy if you are _sure_ that the block
 * is OK, say because you marked a good block bad to test bad
 * block handling and you are done testing, or if you have
 * accidentally marked blocks bad.
 *
 * Erasing factory marked bad blocks is a _bad_ idea. If the
 * erase succeeds there is no reliable way to find them again,
 * and attempting to program or erase bad blocks can affect
 * the data in _other_ (good) blocks.
 */
#define	 ALLOW_ERASE_BAD_DEBUG 0

#define CONFIG_MTD_NAND_ECC  /* enable ECC */
#define CONFIG_MTD_NAND_ECC_JFFS2

/* bits for nand_rw() `cmd'; or together as needed */
#define NANDRW_READ	0x01
#define NANDRW_WRITE	0x00
#define NANDRW_JFFS2	0x02
#define NANDRW_JFFS2_SKIP	0x04

/*------move from cmd_nandrw.c---start--*/
#define CONFIG_WMT_RANDOMIZER
#define USE_BBT
#define NFC_TIMEING_CAL
#define PMPMB_ADDR 0xd8130204
#define PMNAND_ADDR 0xd8130330
#define PMCS_ADDR 0xd8130000
#define WMT_PLL_CLOCK 25
#define NFC_MAX_CLOCK 60
#define NFC_SETUPTIME 15

WMT_NFC_CFG *pNFCRegs;
struct _NAND_PDMA_REG_ *pNand_PDma_Reg;
unsigned long *ReadDesc, *WriteDesc;
unsigned int g_WMTNFCBASE;
static unsigned char *rdmz_buf = NULL;

#define WRITE_NAND16(d, addr) (*(volatile unsigned short *)(addr) = (unsigned short)d)
#define READ_NAND16(d, addr) (d = *(volatile unsigned short *)(addr))
#define READ_NAND8(d, addr) (d = *(volatile unsigned char *)(addr))
#define WRITE_NAND8(d, addr) (*(volatile unsigned char *)(addr) = (unsigned char)d)
#define READ_NAND(adr) ((volatile unsigned char)(*(volatile __u8 *)(unsigned long)adr))

static unsigned char bbt_pattern[] = {'B', 'b', 't', '0' };
static unsigned char mirror_pattern[] = {'1', 't', 'b', 'B' };
static unsigned int *bbt;
static unsigned int bbt_version;
#define BBT_MAX_BLOCK 4
#define RETRY_MAX_BLOCK 4
#define BBT_BITMAP 2
unsigned int bad_block_pos[CFG_MAX_NAND_DEVICE][30];
static uint8_t wmt_rdmz[] = { 'z', 'm', 'd', 'r' };
/*------move from cmd_nandrw.c---end--*/
/*
 * Function Prototypes
 */
static void nand_print(struct nand_chip *nand);
int nand_rw (struct nand_chip* nand, int cmd,
	    size_t start, size_t len,
	    size_t * retlen, u_char * buf);
int wmt_nand_erase(struct nand_chip *nand, unsigned int block);
int get_pattern_small(struct nand_chip *nand, unsigned int block, unsigned int *tag, unsigned int *version);
int get_pattern_large(struct nand_chip *nand, unsigned int block, unsigned int *tag, unsigned int *version);
int nand_page_program(struct nand_chip *nand, unsigned int page, unsigned int maddr, unsigned int len);
int nand_page_program_random(struct nand_chip *nand, unsigned int start, unsigned int maddr, unsigned int len);

int nand_read_page(struct nand_chip *nand, unsigned int start, unsigned int maddr, unsigned int len);
void nfc_ecc_set(unsigned int type, unsigned int ecc, struct nand_chip *nand);
int WMTLoadImageFormNAND(struct nand_chip *nand, unsigned long long naddr, unsigned int maddr, unsigned int size);
int WMTSaveImageToNAND(struct nand_chip *nand, unsigned long long naddr, unsigned int dwImageStart,
		unsigned int dwImageLength);
int nfc_BCH_read_page(struct nand_chip *nand, unsigned int page, unsigned int maddr, unsigned int len);
int NFC_CHECK_ECC(void);
int nfc_1bit_ecc_correct(struct nand_chip *nand, unsigned int start, unsigned int maddr, unsigned int len);
int nfc_1bit_read_page(struct nand_chip *nand, unsigned int start, unsigned int maddr, unsigned int len);
int creat_bbt(struct nand_chip *nand, int chip);
int find_bbt(struct nand_chip *nand, int chip);
int update_bbt_inram(struct nand_chip *nand, unsigned int block, int chip);
int update_bbt_inflash(struct nand_chip *nand, unsigned int last, int chip);
int isbbtbadblock(struct nand_chip *nand, unsigned int block, int chip);
int tellme_badblock(struct nand_chip *nand);
int WMTEraseNAND(struct nand_chip *nand, unsigned int block, unsigned int block_nums, unsigned int all);
int tellme_whereistable(struct nand_chip *nand);
int nand_write_block(struct nand_chip *nand, unsigned int start, unsigned int page, unsigned int page_count, unsigned char *oob);
int tellme_nandinfo(struct nand_chip *nand);
int nand_readID(unsigned char *id);
int WMTEraseNANDALL(struct nand_chip *nand, unsigned int all);
int check_block_table(struct nand_chip *nand, unsigned int scan);
int nfc_BCH_ecc_check(struct nand_chip *nand, unsigned int maddr);
void nfc_BCH_ecc_correct(struct nand_chip *nand, unsigned int bitcnt, unsigned int maddr);
int wmt_calc_clock(struct nand_chip *nand, unsigned int spec_clk,
unsigned int *T, unsigned int *divisor, unsigned int *Thold);
int wmt_get_timing(struct nand_chip *nand, unsigned int nand_timing);
int set_ECC_mode(struct nand_chip *nand);
void calculate_ECC_info(struct nand_chip *nand, struct ECC_size_info *ECC_size);

int nand_erase(struct nand_chip* nand, size_t ofs, size_t len, int clean);
/*
static int nand_read_ecc(struct nand_chip *nand, size_t start, size_t len,
		 size_t * retlen, u_char *buf, u_char *ecc_code);
static int nand_write_ecc (struct nand_chip* nand, size_t to, size_t len,
			   size_t * retlen, const u_char * buf, u_char * ecc_code);
static int nand_read_oob(struct nand_chip* nand, size_t ofs, size_t len,
		 size_t * retlen, u_char * buf);
*/
static void nand_print_bad(struct nand_chip *nand);
/*static int nand_read_oob(struct nand_chip* nand, size_t ofs, size_t len,
		 size_t * retlen, u_char * buf);*/
int nand_boot(struct nand_chip* nand, unsigned long long off, unsigned int mem_kernel, unsigned int mem_ramdisk, char *ramdiskSize);
void rdmzier(uint8_t *buf, int size, int page);
void rdmzier_oob(uint8_t *buf, uint8_t *src, int size, int page, int ofs);
int get_read_retry_para(struct nand_chip *nand);
int set_read_retry_para(struct nand_chip *nand, int reg);
/*static int nand_write_oob(struct nand_chip* nand, size_t ofs, size_t len,
		 size_t * retlen, const u_char * buf);
static int NanD_WaitReady(struct nand_chip *nand, int ale_wait);*/
#ifdef CONFIG_MTD_NAND_ECC
/*static int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc);
static void nand_calculate_ecc (const u_char *dat, u_char *ecc_code);*/
#endif
#define BYTE_SEED 2112
unsigned int rdmz[BYTE_SEED]= {
 0xC5F7B49E, 0x85AD42B6, 0x1888A48B, 0xFBA90A42, 0xE20E7129, 0x37E8086E, 0x6F1C1918, 0x31510E20,
 0x382771CB, 0x6107F49D, 0x901B6D0B, 0x3CD489E1, 0xA9B9CE07, 0x6B41AC61, 0x749F181D, 0xA7DDA658,
 0x405276C0, 0xB67EFB43, 0xC5EE35A6, 0xF8406534, 0x73D8093A, 0xD98028A3, 0x084CE1AF, 0xB4744210,
 0x951E02A0, 0xF657482D, 0x6C64F9D0, 0x68DB8651, 0xD1E64A45, 0x3A0FCB39, 0x9C9BB663, 0x05322DAE,
 0xA4F40077, 0x801BA102, 0xB73BE0DD, 0xA2E34B6A, 0x5A50E576, 0x83CD0C99, 0x63C1440B, 0x2F82661D,
 0x6846C973, 0xA74C29E6, 0x880E86A2, 0xB1D7E000, 0xF9B6F2B5, 0x71E5F26C, 0xE707DE1E, 0x439D5A63,
 0x1F697817, 0x23DFB560, 0xE87F6BD0, 0xBD1BBCC3, 0xB1D3A074, 0x6C1B7C0A, 0xE2823FDB, 0x17F45131,
 0x9082625D, 0xDFD364FD, 0x88DF4E2B, 0xB6FE752D, 0x5B04FF38, 0xB27648A9, 0x8C4EF297, 0x1C595F00,
 0x9E7B4520, 0x826ADDFF, 0xF83FE0EE, 0xF981B0B0, 0x1F9233D7, 0xA2C148CB, 0xF73C908E, 0x18F36125,
 0xE45D3D77, 0xB77BA7EA, 0x6D962E25, 0xFF4BF3B8, 0x7C06714F, 0x812DFFDA, 0xE499B45A, 0x73498684,
 0x11DCD8C1, 0x0FE5FAEC, 0x882C8503, 0x1CBB95F8, 0x62889F09, 0xF6798B10, 0x7FFE1FE9, 0x464DBD35,
 0x476EA249, 0xD7D7428D, 0xD885740A, 0xA034FA2C, 0xB37FD49C, 0x9AC07AD5, 0xAEFA9F54, 0x80B1AC25,
 0xAFE642C5, 0x55249024, 0xC3BD79F8, 0x78D3CAB0, 0x71523E07, 0x179AD53B, 0x4C6DE12B, 0x545E4957,
 0xE19CDBF1, 0xB9CA4748, 0xD401EF16, 0x0C7FD0DC, 0x2D55D75B, 0x8169F899, 0xBE415FAA, 0x45355DFD,
 0x1EE42A38, 0x3E167903, 0x838D4BAE, 0xACB42144, 0x8A9970D3, 0x978DB4A5, 0x45A09237, 0x431554E5,
 0xAAD8AFF7, 0x4F260392, 0xF60E8E22, 0xDEFCBB1D, 0xA6903D2E, 0x0C041572, 0x32A1E06E, 0xD41C2E5A,
 0xE43F79E1, 0xD562B75D, 0x53B35557, 0x871CF712, 0x06130B69, 0x4FE6CACB, 0xA79121F3, 0x31D1804E,
 0xA6CDBB55, 0x2B31D900, 0x6F8D96A6, 0xF90DFE42, 0x3F8E6A88, 0x5D5F338E, 0x19BEFA53, 0xA80B5EC5,
 0x33A4BCC7, 0x7C6435D9, 0xE334EF6D, 0xDABCCF28, 0x0B1E822E, 0x6BC9A2E7, 0xC12ECFFD, 0xCB2410AA,
 0x5E239332, 0xD599FC9D, 0xD2ADA8FC, 0x985F0C4C, 0xA3FBD68F, 0x1A6857C8, 0x7CF1FA13, 0xBEC591B0,
 0x4E7219DC, 0xC7B5CA12, 0x31730D81, 0x954B0433, 0xFA399921, 0x17871477, 0xA42D4816, 0xAC692951,
 0x3346763F, 0x8097EFF0, 0x9727B982, 0x5D7D302F, 0xB4D28FAB, 0x33353379, 0xB438C5BB, 0xE49DF42E,
 0xE6E4083B, 0x82BB1576, 0xFF1675C3, 0x5B33BD3D, 0xDC018912, 0xC9886442, 0xA8F895ED, 0x99E15C12,
 0x45E855E8, 0xA73B2CD4, 0x290C2256, 0x510A601B, 0xB2DC458E, 0x9493508F, 0xEB9E844E, 0x0796D9AE,
 0x79741BD6, 0xEAAC9AE2, 0xC1990396, 0x3BB91B8F, 0x51D3287A, 0x9EAECDDD, 0x10EEC66D, 0xC9EA20D4,
 0xCAE1855A, 0xA7C42760, 0x3DBF5142, 0xDD2E56F2, 0xE7C71747, 0x1202F5B2, 0xF0444344, 0x2382331B,
 0xCF4AA7A2, 0xE037CA0B, 0x9CC2706C, 0xB7AA6F63, 0x6ABFBB08, 0x5DF9FE35, 0xBF95CB8A, 0xEA64D353,
 0xBB5DB139, 0xF25BBBB3, 0xB069B05E, 0x1FA571D2, 0xCCB68970, 0xB2FA065B, 0xAC52ABC8, 0xE3C72445,
 0x70F92FFD, 0x3292E21F, 0x2FC6615E, 0x329E2283, 0x9130F29F, 0x8736745B, 0x802463EF, 0xF2173C18,
 0xC1EA46D0, 0x0F1631C4, 0x226965D6, 0x2537F5C9, 0x26875CB0, 0x05C9666E, 0x25EAFDDC, 0x9F585A5C,
 0x12D33D3B, 0xF76DD669, 0x81303E96, 0x0CD91D67, 0x8B7EE682, 0xC306750F, 0x36B85254, 0xCB0AD397,
 0x4DB9750B, 0xFB0FC7F9, 0x442540F0, 0x758785F8, 0xE7E514E6, 0xBF6E804A, 0x6B7A2EF8, 0xA41E4A67,
 0x57B36655, 0xE5E72D5D, 0xC4C5AA32, 0x43A2988E, 0x5A45A4D2, 0x40D6B8DA, 0xBD39BF62, 0x1CBFD58C,
 0xF72511B6, 0x651E46A7, 0x8F0D90C6, 0x9552850B, 0x87D4BEA3, 0x7CD7B9C6, 0x86046AF7, 0x462BB9D7,
 0xB0DA3C41, 0x7A95F448, 0x5021FF8F, 0x093EB834, 0xBD0EFD67, 0x72C81437, 0xB2E38763, 0xD1BF8C4A,
 0x889789F4, 0x52D00D1C, 0xD8D07299, 0xAC5A2B20, 0xC89C393B, 0x5636B492, 0xD375FC40, 0x89F81123,
 0xB3EA1B56, 0xC7310408, 0x3A3449A0, 0x4C1AE419, 0xF55CEDA3, 0x01415BEA, 0xF2A0F073, 0x31774DF5,
 0x00E68A8C, 0x695E5496, 0xE7749B58, 0x77327028, 0x6CD335BB, 0x98468D74, 0xDE16F10D, 0x7138FA79,
 0x5ED8D8F2, 0x54870136, 0xCDEE53A2, 0x3DB7D1AA, 0xF6754B8C, 0xC1088C28, 0xF3E5EBED, 0x567A3339,
 0xA2F60ACE, 0x994B5135, 0x5D35F7F0, 0x50FCF79A, 0xB0E1BED8, 0xAA14A632, 0xA04F3F82, 0xAC8BE3A9,
 0xCFB5AC16, 0xF484B91F, 0x10E64685, 0xE2B13DAA, 0xEC2E1E35, 0x4623393F, 0x9B81213F, 0x5C5A6F27,
 0xB1C6E1D0, 0xAF00C849, 0x3C7AC4B2, 0x24C9E2A0, 0x0FE1BA98, 0x1D810BBC, 0x8FDC584F, 0x927B1026,
 0x2566B32E, 0xBF440303, 0xED4D467E, 0x19EFBCB4, 0x31C80176, 0xDB209CD7, 0x406174B1, 0x4DA4B447,
 0x134F6EC4, 0xBC1220F6, 0xA75D2836, 0xDEB8BC5E, 0xFC48D6DE, 0x3A78CE0B, 0x3D991297, 0xE5EFADB5,
 0xEF9EB74C, 0x656D03E1, 0xBBA2BA8D, 0xE6E8C8A7, 0x3C4D86B7, 0x4ABE231B, 0x4A272C4D, 0xA920C151,
 0x8846417D, 0x55F99831, 0x7A627F14, 0x6FC991E5, 0xA3D515B2, 0x09F2B1F1, 0x5267C177, 0x284D79BC,
 0xA3AA9068, 0x83AB087B, 0x9475DA03, 0x82C0D0D8, 0xE0E242F6, 0x0E466BFE, 0x867FAF59, 0x59DF8EE2,
 0xE5AFEA82, 0x20EBD203, 0xC076152F, 0x4469C75B, 0x04047376, 0xF75654F0, 0x51B16CEC, 0xFCB7DD6A,
 0x2ECBBD1F, 0xB1BD247E, 0xB0F4FF7C, 0x690F1271, 0x7EB7C4EB, 0x9FB65038, 0x50D674D3, 0x36D6D65E,
 0x17E550E1, 0xC63458A1, 0x924C5223, 0x4B117295, 0xFA8295D6, 0x59EC8C93, 0x1E75A586, 0xF64A8961,
 0x842450ED, 0x90ECE657, 0x033CE78B, 0x03526381, 0xDFBDE0F7, 0x5430CD5D, 0x3D735887, 0x32476AE2,
 0xBD427ACC, 0x034BE2B9, 0xA250C775, 0x3F6060EC, 0x1F5A7A66, 0xD805FA64, 0x3EDE30B2, 0xF949F901,
 0x65568178, 0x6B23E8F7, 0x168608AA, 0x99F8DD2A, 0x3805726A, 0xCC6B8165, 0x0B2500B7, 0xBB48F09D,
 0x31400FF0, 0x6E914B37, 0x2C98C243, 0x53D551B5, 0x70A8691A, 0xAB51BDAC, 0xC742414E, 0x0E9B63EB,
 0x3FA0A9B5, 0x4EC5D5B7, 0x3728C137, 0x3E83B6C9, 0xDE7C3573, 0x387AF7B0, 0x463238EF, 0xCD371BC3,
 0x11C559F9, 0x7208DD6E, 0xE37C28B2, 0x3E92B719, 0x88CA0F8F, 0x75E5C16E, 0x85FC0451, 0x814BFB38,
 0x132D2A52, 0xDE0B3041, 0x99785344, 0xA6EFB8F4, 0x865DACF8, 0xF4B3FB1A, 0x7E91873E, 0xA777AB7F,
 0x588FD4D8, 0x41B9200D, 0x5C03A928, 0x035EA31D, 0x614B7336, 0xE1989B85, 0x2C67C9F7, 0x476622A1,
 0xFC8C5FF3, 0xFE4AEF65, 0x41D3E473, 0x1541A4E1, 0x1BB44300, 0xF8FB69C3, 0x3DB391DE, 0x63D8C533,
 0x526F419F, 0x031664C2, 0x85650B07, 0x624C1624, 0x324BAA7E, 0x03B4E90D, 0xB6E3B461, 0xB3445605,
 0x4A4128AF, 0x5E945F59, 0x2504F7B8, 0xDD5D13B4, 0xD3683D0C, 0x61B8B81E, 0x4BDD7B50, 0x15EBA9C6,
 0x0369E118, 0x0F3CB28D, 0xA45E0D50, 0x98C6031A, 0x40FC3B93, 0x3B0ED7E4, 0xA14E235F, 0x915E7695,
 0x5BD9F72D, 0x0BA94E45, 0x9B54A9C2, 0xCEDE74B5, 0x801321EA, 0x9C60FDA3, 0x842CD005, 0xBBB7FB29,
 0x25F37CE4, 0xE2B57DDE, 0x7983908A, 0xD544F488, 0x6B72AE10, 0x8F455719, 0x717CFD3A, 0x04003302,
 0x62FBDA4F, 0xC2D6A15B, 0x0C445245, 0xFDD48521, 0x71073894, 0x1BF40437, 0x378E0C8C, 0x98A88710,
 0x9C13B8E5, 0xB083FA4E, 0xC80DB685, 0x9E6A44F0, 0xD4DCE703, 0xB5A0D630, 0x3A4F8C0E, 0x53EED32C,
 0xA0293B60, 0x5B3F7DA1, 0x62F71AD3, 0x7C20329A, 0xB9EC049D, 0xECC01451, 0x042670D7, 0x5A3A2108,
 0xCA8F0150, 0x7B2BA416, 0xB6327CE8, 0xB46DC328, 0xE8F32522, 0x9D07E59C, 0x4E4DDB31, 0x829916D7,
 0x527A003B, 0xC00DD081, 0x5B9DF06E, 0x5171A5B5, 0xAD2872BB, 0xC1E6864C, 0xB1E0A205, 0x97C1330E,
 0x342364B9, 0x53A614F3, 0x44074351, 0xD8EBF000, 0x7CDB795A, 0x38F2F936, 0xF383EF0F, 0xA1CEAD31,
 0x0FB4BC0B, 0x11EFDAB0, 0xF43FB5E8, 0x5E8DDE61, 0x58E9D03A, 0xB60DBE05, 0xF1411FED, 0x8BFA2898,
 0xC841312E, 0xEFE9B27E, 0xC46FA715, 0x5B7F3A96, 0xAD827F9C, 0xD93B2454, 0x4627794B, 0x0E2CAF80,
 0xCF3DA290, 0x41356EFF, 0x7C1FF077, 0xFCC0D858, 0x8FC919EB, 0x5160A465, 0xFB9E4847, 0x8C79B092,
 0x722E9EBB, 0xDBBDD3F5, 0x36CB1712, 0xFFA5F9DC, 0x3E0338A7, 0x4096FFED, 0x724CDA2D, 0xB9A4C342,
 0x08EE6C60, 0x87F2FD76, 0x44164281, 0x8E5DCAFC, 0x31444F84, 0xFB3CC588, 0xBFFF0FF4, 0xA326DE9A,
 0xA3B75124, 0x6BEBA146, 0x6C42BA05, 0x501A7D16, 0xD9BFEA4E, 0x4D603D6A, 0xD77D4FAA, 0xC058D612,
 0x57F32162, 0x2A924812, 0x61DEBCFC, 0xBC69E558, 0xB8A91F03, 0x8BCD6A9D, 0xA636F095, 0xAA2F24AB,
 0x70CE6DF8, 0x5CE523A4, 0x6A00F78B, 0x863FE86E, 0x96AAEBAD, 0x40B4FC4C, 0xDF20AFD5, 0x229AAEFE,
 0x8F72151C, 0x1F0B3C81, 0x41C6A5D7, 0xD65A10A2, 0xC54CB869, 0xCBC6DA52, 0xA2D0491B, 0xA18AAA72,
 0x556C57FB, 0x279301C9, 0xFB074711, 0x6F7E5D8E, 0x53481E97, 0x06020AB9, 0x1950F037, 0xEA0E172D,
 0xF21FBCF0, 0xEAB15BAE, 0x29D9AAAB, 0xC38E7B89, 0x830985B4, 0xA7F36565, 0x53C890F9, 0x98E8C027,
 0x5366DDAA, 0x1598EC80, 0x37C6CB53, 0x7C86FF21, 0x1FC73544, 0xAEAF99C7, 0x8CDF7D29, 0xD405AF62,
 0x99D25E63, 0xBE321AEC, 0x719A77B6, 0x6D5E6794, 0x858F4117, 0xB5E4D173, 0x609767FE, 0x65920855,
 0xAF11C999, 0x6ACCFE4E, 0x6956D47E, 0xCC2F8626, 0x51FDEB47, 0x8D342BE4, 0x3E78FD09, 0x5F62C8D8,
 0x27390CEE, 0xE3DAE509, 0x98B986C0, 0xCAA58219, 0xFD1CCC90, 0x0BC38A3B, 0xD216A40B, 0xD63494A8,
 0x19A33B1F, 0x404BF7F8, 0xCB93DCC1, 0xAEBE9817, 0xDA6947D5, 0x999A99BC, 0x5A1C62DD, 0xF24EFA17,
 0x7372041D, 0xC15D8ABB, 0xFF8B3AE1, 0x2D99DE9E, 0x6E00C489, 0xE4C43221, 0x547C4AF6, 0x4CF0AE09,
 0x22F42AF4, 0x539D966A, 0x9486112B, 0x2885300D, 0xD96E22C7, 0x4A49A847, 0x75CF4227, 0x03CB6CD7,
 0x3CBA0DEB, 0x75564D71, 0xE0CC81CB, 0x1DDC8DC7, 0xA8E9943D, 0xCF5766EE, 0x08776336, 0x64F5106A,
 0x6570C2AD, 0x53E213B0, 0x1EDFA8A1, 0xEE972B79, 0x73E38BA3, 0x09017AD9, 0xF82221A2, 0x11C1198D,
 0xE7A553D1, 0x701BE505, 0xCE613836, 0x5BD537B1, 0xB55FDD84, 0x2EFCFF1A, 0xDFCAE5C5, 0xF53269A9,
 0xDDAED89C, 0x792DDDD9, 0x5834D82F, 0x0FD2B8E9, 0xE65B44B8, 0x597D032D, 0xD62955E4, 0xF1E39222,
 0xB87C97FE, 0x1949710F, 0x97E330AF, 0x994F1141, 0xC898794F, 0xC39B3A2D, 0x401231F7, 0x790B9E0C,
 0x60F52368, 0x078B18E2, 0x9134B2EB, 0x129BFAE4, 0x1343AE58, 0x02E4B337, 0x12F57EEE, 0xCFAC2D2E,
 0x89699E9D, 0x7BB6EB34, 0xC0981F4B, 0x066C8EB3, 0xC5BF7341, 0x61833A87, 0x9B5C292A, 0xE58569CB,
 0xA6DCBA85, 0x7D87E3FC, 0x2212A078, 0x3AC3C2FC, 0x73F28A73, 0x5FB74025, 0xB5BD177C, 0xD20F2533,
 0xABD9B32A, 0x72F396AE, 0x6262D519, 0x21D14C47, 0x2D22D269, 0x206B5C6D, 0x5E9CDFB1, 0x0E5FEAC6,
 0xFB9288DB, 0x328F2353, 0xC786C863, 0xCAA94285, 0x43EA5F51, 0xBE6BDCE3, 0xC302357B, 0xA315DCEB,
 0x586D1E20, 0xBD4AFA24, 0x2810FFC7, 0x849F5C1A, 0xDE877EB3, 0xB9640A1B, 0x5971C3B1, 0x68DFC625,
 0x444BC4FA, 0xA968068E, 0x6C68394C, 0xD62D1590, 0x644E1C9D, 0x2B1B5A49, 0xE9BAFE20, 0x44FC0891,
 0x59F50DAB, 0x63988204, 0x9D1A24D0, 0xA60D720C, 0x7AAE76D1, 0x80A0ADF5, 0xF9507839, 0x18BBA6FA,
 0x00734546, 0x34AF2A4B, 0x73BA4DAC, 0xBB993814, 0x36699ADD, 0xCC2346BA, 0xEF0B7886, 0x389C7D3C,
 0x2F6C6C79, 0x2A43809B, 0x66F729D1, 0x1EDBE8D5, 0x7B3AA5C6, 0xE0844614, 0xF9F2F5F6, 0x2B3D199C,
 0xD17B0567, 0x4CA5A89A, 0x2E9AFBF8, 0x287E7BCD, 0x5870DF6C, 0x550A5319, 0xD0279FC1, 0x5645F1D4,
 0xE7DAD60B, 0xFA425C8F, 0x08732342, 0xF1589ED5, 0xF6170F1A, 0xA3119C9F, 0xCDC0909F, 0x2E2D3793,
 0xD8E370E8, 0x57806424, 0x1E3D6259, 0x1264F150, 0x07F0DD4C, 0x8EC085DE, 0x47EE2C27, 0x493D8813,
 0x92B35997, 0x5FA20181, 0x76A6A33F, 0x0CF7DE5A, 0x98E400BB, 0xED904E6B, 0xA030BA58, 0x26D25A23,
 0x09A7B762, 0x5E09107B, 0x53AE941B, 0x6F5C5E2F, 0xFE246B6F, 0x9D3C6705, 0x9ECC894B, 0x72F7D6DA,
 0xF7CF5BA6, 0xB2B681F0, 0xDDD15D46, 0xF3746453, 0x9E26C35B, 0xA55F118D, 0xA5139626, 0xD49060A8,
 0xC42320BE, 0x2AFCCC18, 0xBD313F8A, 0x37E4C8F2, 0xD1EA8AD9, 0x84F958F8, 0x2933E0BB, 0x1426BCDE,
 0xD1D54834, 0xC1D5843D, 0x4A3AED01, 0x4160686C, 0x7071217B, 0x872335FF, 0x433FD7AC, 0x2CEFC771,
 0xF2D7F541, 0x9075E901, 0xE03B0A97, 0x2234E3AD, 0x020239BB, 0x7BAB2A78, 0x28D8B676, 0xFE5BEEB5,
 0x1765DE8F, 0x58DE923F, 0xD87A7FBE, 0xB4878938, 0x3F5BE275, 0xCFDB281C, 0x286B3A69, 0x9B6B6B2F,
 0x8BF2A870, 0xE31A2C50, 0xC9262911, 0x2588B94A, 0xFD414AEB, 0x2CF64649, 0x8F3AD2C3, 0xFB2544B0,
 0xC2122876, 0xC876732B, 0x819E73C5, 0x81A931C0, 0xEFDEF07B, 0xAA1866AE, 0x1EB9AC43, 0x1923B571,
 0xDEA13D66, 0x81A5F15C, 0x512863BA, 0x1FB03076, 0x0FAD3D33, 0x6C02FD32, 0x9F6F1859, 0x7CA4FC80,
 0xB2AB40BC, 0x3591F47B, 0x0B430455, 0x4CFC6E95, 0x9C02B935, 0xE635C0B2, 0x8592805B, 0x5DA4784E,
 0x98A007F8, 0xB748A59B, 0x964C6121, 0x29EAA8DA, 0x3854348D, 0x55A8DED6, 0xE3A120A7, 0x874DB1F5,
 0x9FD054DA, 0xA762EADB, 0x9B94609B, 0x9F41DB64, 0x6F3E1AB9, 0x9C3D7BD8, 0xA3191C77, 0xE69B8DE1,
 0x08E2ACFC, 0x39046EB7, 0xF1BE1459, 0x9F495B8C, 0x446507C7, 0xBAF2E0B7, 0x42FE0228, 0x40A5FD9C,
 0x89969529, 0x6F059820, 0x4CBC29A2, 0x5377DC7A, 0x432ED67C, 0x7A59FD8D, 0xBF48C39F, 0x53BBD5BF,
 0xAC47EA6C, 0x20DC9006, 0xAE01D494, 0x01AF518E, 0xB0A5B99B, 0xF0CC4DC2, 0x9633E4FB, 0xA3B31150,
 0xFE462FF9, 0xFF2577B2, 0xA0E9F239, 0x0AA0D270, 0x8DDA2180, 0x7C7DB4E1, 0x9ED9C8EF, 0xB1EC6299,
 0x2937A0CF, 0x818B3261, 0x42B28583, 0x31260B12, 0x9925D53F, 0x81DA7486, 0xDB71DA30, 0xD9A22B02,
 0xA5209457, 0x2F4A2FAC, 0x12827BDC, 0x6EAE89DA, 0x69B41E86, 0x30DC5C0F, 0x25EEBDA8, 0x0AF5D4E3,
 0x81B4F08C, 0x079E5946, 0x522F06A8, 0xCC63018D, 0x207E1DC9, 0x9D876BF2, 0xD0A711AF, 0xC8AF3B4A,
 0xADECFB96, 0x05D4A722, 0xCDAA54E1, 0x676F3A5A, 0xC00990F5, 0xCE307ED1, 0xC2166802, 0x5DDBFD94,
 0x12F9BE72, 0x715ABEEF, 0x3CC1C845, 0x6AA27A44, 0xB5B95708, 0x47A2AB8C, 0x38BE7E9D, 0x82001981,
 0xB17DED27, 0xE16B50AD, 0x86222922, 0x7EEA4290, 0xB8839C4A, 0x0DFA021B, 0x1BC70646, 0xCC544388,
 0x4E09DC72, 0xD841FD27, 0x6406DB42, 0xCF352278, 0x6A6E7381, 0x5AD06B18, 0x1D27C607, 0x29F76996,
 0xD0149DB0, 0xAD9FBED0, 0x317B8D69, 0xBE10194D, 0xDCF6024E, 0xF6600A28, 0x0213386B, 0x2D1D1084,
 0x654780A8, 0x3D95D20B, 0x5B193E74, 0x5A36E194, 0x74799291, 0xCE83F2CE, 0xA726ED98, 0xC14C8B6B,
 0xA93D001D, 0x6006E840, 0xADCEF837, 0xA8B8D2DA, 0x5694395D, 0xE0F34326, 0x58F05102, 0xCBE09987,
 0x9A11B25C, 0xA9D30A79, 0x2203A1A8, 0x6C75F800, 0x3E6DBCAD, 0x9C797C9B, 0xF9C1F787, 0xD0E75698,
 0x07DA5E05, 0x08F7ED58, 0xFA1FDAF4, 0x2F46EF30, 0xAC74E81D, 0xDB06DF02, 0x78A08FF6, 0x45FD144C,
 0x64209897, 0xF7F4D93F, 0x6237D38A, 0x2DBF9D4B, 0x56C13FCE, 0xEC9D922A, 0x2313BCA5, 0x071657C0,
 0xE79ED148, 0xA09AB77F, 0x3E0FF83B, 0xFE606C2C, 0xC7E48CF5, 0xA8B05232, 0x7DCF2423, 0xC63CD849,
 0xB9174F5D, 0x6DDEE9FA, 0x1B658B89, 0xFFD2FCEE, 0x9F019C53, 0xA04B7FF6, 0x39266D16, 0x5CD261A1,
 0x04773630, 0xC3F97EBB, 0x220B2140, 0x472EE57E, 0x18A227C2, 0x7D9E62C4, 0x5FFF87FA, 0x51936F4D,
 0x51DBA892, 0xB5F5D0A3, 0x36215D02, 0x280D3E8B, 0x6CDFF527, 0x26B01EB5, 0x6BBEA7D5, 0x602C6B09,
 0x2BF990B1, 0x15492409, 0x30EF5E7E, 0xDE34F2AC, 0xDC548F81, 0xC5E6B54E, 0xD31B784A, 0x55179255,
 0x386736FC, 0xAE7291D2, 0x35007BC5, 0xC31FF437, 0x4B5575D6, 0xA05A7E26, 0x6F9057EA, 0x114D577F,
 0xC7B90A8E, 0x8F859E40, 0x20E352EB, 0xEB2D0851, 0x62A65C34, 0xE5E36D29, 0x5168248D, 0xD0C55539,
 0xAAB62BFD, 0x93C980E4, 0x7D83A388, 0xB7BF2EC7, 0xA9A40F4B, 0x8301055C, 0x8CA8781B, 0x75070B96,
 0x790FDE78, 0xF558ADD7, 0x94ECD555, 0x61C73DC4, 0xC184C2DA, 0xD3F9B2B2, 0xA9E4487C, 0x4C746013,
 0x29B36ED5, 0x8ACC7640, 0x9BE365A9, 0x3E437F90, 0x8FE39AA2, 0xD757CCE3, 0x466FBE94, 0xEA02D7B1,
 0x4CE92F31, 0x5F190D76, 0x38CD3BDB, 0xB6AF33CA, 0xC2C7A08B, 0x5AF268B9, 0xB04BB3FF, 0xB2C9042A,
 0x5788E4CC, 0x35667F27, 0x34AB6A3F, 0xE617C313, 0x28FEF5A3, 0xC69A15F2, 0x1F3C7E84, 0x2FB1646C,
 0x939C8677, 0x71ED7284, 0xCC5CC360, 0x6552C10C, 0xFE8E6648, 0x85E1C51D, 0x690B5205, 0xEB1A4A54,
 0x0CD19D8F, 0xA025FBFC, 0xE5C9EE60, 0xD75F4C0B, 0x6D34A3EA, 0xCCCD4CDE, 0xAD0E316E, 0xF9277D0B,
 0xB9B9020E, 0xE0AEC55D, 0x7FC59D70, 0x96CCEF4F, 0xB7006244, 0x72621910, 0xAA3E257B, 0x26785704,
 0x117A157A, 0xA9CECB35, 0xCA430895, 0x94429806, 0xECB71163, 0xA524D423, 0xBAE7A113, 0x81E5B66B,
 0x9E5D06F5, 0xBAAB26B8, 0xF06640E5, 0x8EEE46E3, 0x5474CA1E, 0x67ABB377, 0x043BB19B, 0xB27A8835,
 0x32B86156, 0xA9F109D8, 0x8F6FD450, 0xF74B95BC, 0xB9F1C5D1, 0x0480BD6C, 0xFC1110D1, 0x88E08CC6,
 0xF3D2A9E8, 0x380DF282, 0xE7309C1B, 0x2DEA9BD8, 0x5AAFEEC2, 0x977E7F8D, 0xEFE572E2, 0x7A9934D4,
 0xEED76C4E, 0xBC96EEEC, 0xAC1A6C17, 0x07E95C74, 0xF32DA25C, 0x2CBE8196, 0x6B14AAF2, 0x78F1C911,
 0xDC3E4BFF, 0x8CA4B887, 0xCBF19857, 0xCCA788A0, 0xE44C3CA7, 0xE1CD9D16, 0x200918FB, 0x3C85CF06,
 0x307A91B4, 0x83C58C71, 0x489A5975, 0x094DFD72, 0x89A1D72C, 0x0172599B, 0x097ABF77, 0xE7D61697,
 0x44B4CF4E, 0xBDDB759A, 0xE04C0FA5, 0x83364759, 0xE2DFB9A0, 0x30C19D43, 0xCDAE1495, 0xF2C2B4E5,
 0x536E5D42, 0x3EC3F1FE, 0x1109503C, 0x9D61E17E, 0xB9F94539, 0x2FDBA012, 0xDADE8BBE, 0x69079299,
 0x55ECD995, 0xB979CB57, 0xB1316A8C, 0x90E8A623, 0x96916934, 0x9035AE36, 0x2F4E6FD8, 0x872FF563,
 0xFDC9446D, 0x994791A9, 0xE3C36431, 0xE554A142, 0xA1F52FA8, 0xDF35EE71, 0xE1811ABD, 0x518AEE75,
 0x2C368F10, 0xDEA57D12, 0x14087FE3, 0xC24FAE0D, 0xEF43BF59, 0xDCB2050D, 0xACB8E1D8, 0x346FE312,
 0x2225E27D, 0x54B40347, 0x36341CA6, 0xEB168AC8, 0xB2270E4E, 0x158DAD24, 0xF4DD7F10, 0xA27E0448,
 0x2CFA86D5, 0x31CC4102, 0x4E8D1268, 0xD306B906, 0xBD573B68, 0xC05056FA, 0x7CA83C1C, 0x0C5DD37D,
 0x8039A2A3, 0x1A579525, 0x39DD26D6, 0xDDCC9C0A, 0x1B34CD6E, 0x6611A35D, 0x7785BC43, 0x9C4E3E9E,
 0x97B6363C, 0x9521C04D, 0xB37B94E8, 0x0F6DF46A, 0x3D9D52E3, 0x7042230A, 0x7CF97AFB, 0x959E8CCE,
 0x68BD82B3, 0x2652D44D, 0x974D7DFC, 0x143F3DE6, 0xAC386FB6, 0xAA85298C, 0x6813CFE0, 0xAB22F8EA,
 0xF3ED6B05, 0x7D212E47, 0x843991A1, 0x78AC4F6A, 0xFB0B878D, 0xD188CE4F, 0xE6E0484F, 0x17169BC9,
 0x6C71B874, 0xABC03212, 0x0F1EB12C, 0x093278A8, 0x03F86EA6, 0xC76042EF, 0xA3F71613, 0xA49EC409,
 0xC959ACCB, 0xAFD100C0, 0x3B53519F, 0x867BEF2D, 0xCC72005D, 0x76C82735, 0xD0185D2C, 0x13692D11,
 0x84D3DBB1, 0xAF04883D, 0xA9D74A0D, 0xB7AE2F17, 0xFF1235B7, 0xCE9E3382, 0x4F6644A5, 0x397BEB6D,
 0x7BE7ADD3, 0x595B40F8, 0xEEE8AEA3, 0xF9BA3229, 0xCF1361AD, 0x52AF88C6, 0x5289CB13, 0x6A483054,
 0x6211905F, 0x157E660C, 0x5E989FC5, 0x9BF26479, 0x68F5456C, 0xC27CAC7C, 0x1499F05D, 0x0A135E6F,
 0xE8EAA41A, 0xE0EAC21E, 0x251D7680, 0xA0B03436, 0xB83890BD, 0x43919AFF, 0xA19FEBD6, 0x9677E3B8,
 0xF96BFAA0, 0xC83AF480, 0xF01D854B, 0x911A71D6, 0x01011CDD, 0x3DD5953C, 0x946C5B3B, 0xFF2DF75A,
 0x8BB2EF47, 0x2C6F491F, 0x6C3D3FDF, 0xDA43C49C, 0x1FADF13A, 0xE7ED940E, 0x94359D34, 0x4DB5B597,
 0x45F95438, 0xF18D1628, 0x64931488, 0x92C45CA5, 0xFEA0A575, 0x967B2324, 0x479D6961, 0x7D92A258,
 0xE109143B, 0xE43B3995, 0x40CF39E2, 0xC0D498E0, 0x77EF783D, 0xD50C3357, 0x8F5CD621, 0x0C91DAB8,
 0x6F509EB3, 0x40D2F8AE, 0x289431DD, 0x8FD8183B, 0x07D69E99, 0xB6017E99, 0x4FB78C2C, 0x3E527E40,
 0xD955A05E, 0x9AC8FA3D, 0x85A1822A, 0xA67E374A, 0x4E015C9A, 0xF31AE059, 0x42C9402D, 0x2ED23C27,
 0xCC5003FC, 0xDBA452CD, 0x4B263090, 0x94F5546D, 0x1C2A1A46, 0xAAD46F6B, 0xF1D09053, 0x43A6D8FA,
 0xCFE82A6D, 0xD3B1756D, 0x4DCA304D, 0xCFA0EDB2, 0x379F0D5C, 0xCE1EBDEC, 0xD18C8E3B, 0x734DC6F0,
 0x8471567E, 0x9C82375B, 0x78DF0A2C, 0xCFA4ADC6, 0xA23283E3, 0x5D79705B, 0x217F0114, 0xA052FECE,
 0x44CB4A94, 0x3782CC10, 0x265E14D1, 0x29BBEE3D, 0xA1976B3E, 0xBD2CFEC6, 0xDFA461CF, 0x29DDEADF,
 0x5623F536, 0x106E4803, 0x5700EA4A, 0x80D7A8C7, 0x5852DCCD, 0xF86626E1, 0x4B19F27D, 0xD1D988A8,
 0x7F2317FC, 0xFF92BBD9, 0x5074F91C, 0x05506938, 0xC6ED10C0, 0xBE3EDA70, 0xCF6CE477, 0xD8F6314C,
 0x949BD067, 0xC0C59930, 0x215942C1, 0x98930589, 0x4C92EA9F, 0x40ED3A43, 0x6DB8ED18, 0xECD11581,
 0x52904A2B, 0x17A517D6, 0x09413DEE, 0x375744ED, 0xB4DA0F43, 0x186E2E07, 0x92F75ED4, 0x057AEA71,
 0x40DA7846, 0x03CF2CA3, 0xA9178354, 0xE63180C6, 0x103F0EE4, 0xCEC3B5F9, 0x685388D7, 0x64579DA5,
 0x56F67DCB, 0x82EA5391, 0x66D52A70, 0xB3B79D2D, 0xE004C87A, 0x67183F68, 0x610B3401, 0x2EEDFECA,
 0x897CDF39, 0xB8AD5F77, 0x1E60E422, 0x35513D22, 0x5ADCAB84, 0xA3D155C6, 0x9C5F3F4E, 0xC1000CC0,
 0xD8BEF693, 0x70B5A856, 0x43111491, 0x3F752148, 0xDC41CE25, 0x06FD010D, 0x0DE38323, 0x662A21C4,
 0xA704EE39, 0x6C20FE93, 0x32036DA1, 0xE79A913C, 0x353739C0, 0xAD68358C, 0x0E93E303, 0x14FBB4CB,
 0x680A4ED8, 0xD6CFDF68, 0x98BDC6B4, 0x5F080CA6, 0x6E7B0127, 0xFB300514, 0x01099C35, 0x168E8842,
 0xB2A3C054, 0x1ECAE905, 0x2D8C9F3A, 0xAD1B70CA, 0x3A3CC948, 0x6741F967, 0xD39376CC, 0xE0A645B5,
 0x549E800E, 0xB0037420, 0x56E77C1B, 0xD45C696D, 0x2B4A1CAE, 0x7079A193, 0xAC782881, 0x65F04CC3,
 0xCD08D92E, 0x54E9853C, 0x1101D0D4, 0xB63AFC00, 0x9F36DE56, 0xCE3CBE4D, 0x7CE0FBC3, 0xE873AB4C,
 0x03ED2F02, 0x047BF6AC, 0x7D0FED7A, 0x97A37798, 0x563A740E, 0x6D836F81, 0x3C5047FB, 0xA2FE8A26,
 0xB2104C4B, 0x7BFA6C9F, 0xB11BE9C5, 0x16DFCEA5, 0x2B609FE7, 0xF64EC915, 0x1189DE52, 0x038B2BE0,
 0xF3CF68A4, 0xD04D5BBF, 0x1F07FC1D, 0xFF303616, 0x63F2467A, 0xD4582919, 0xBEE79211, 0xE31E6C24,
 0x5C8BA7AE, 0xB6EF74FD, 0x0DB2C5C4, 0xFFE97E77, 0x4F80CE29, 0x5025BFFB, 0x9C93368B, 0x2E6930D0,
 0x823B9B18, 0x61FCBF5D, 0x110590A0, 0x239772BF, 0x0C5113E1, 0x3ECF3162, 0xAFFFC3FD, 0x28C9B7A6,
 0xA8EDD449, 0x5AFAE851, 0x9B10AE81, 0x94069F45, 0xB66FFA93, 0x93580F5A, 0xB5DF53EA, 0xB0163584,
 0x95FCC858, 0x0AA49204, 0x1877AF3F, 0xEF1A7956, 0x6E2A47C0, 0x62F35AA7, 0xE98DBC25, 0x2A8BC92A,
 0x1C339B7E, 0xD73948E9, 0x9A803DE2, 0x618FFA1B, 0x25AABAEB, 0x502D3F13, 0xB7C82BF5, 0x08A6ABBF,
 0x63DC8547, 0xC7C2CF20, 0x9071A975, 0x75968428, 0xB1532E1A, 0xF2F1B694, 0xA8B41246, 0xE862AA9C,
 0x555B15FE, 0x49E4C072, 0xBEC1D1C4, 0xDBDF9763, 0x54D207A5, 0xC18082AE, 0x46543C0D, 0x3A8385CB,
 0xBC87EF3C, 0xFAAC56EB, 0x4A766AAA, 0x30E39EE2, 0x60C2616D, 0x69FCD959, 0xD4F2243E, 0xA63A3009,
 0x14D9B76A, 0xC5663B20, 0x4DF1B2D4, 0x1F21BFC8, 0xC7F1CD51, 0x6BABE671, 0xA337DF4A, 0xF5016BD8,
 0x26749798, 0xAF8C86BB, 0x1C669DED, 0xDB5799E5, 0xE163D045, 0xAD79345C, 0x5825D9FF, 0x59648215,
 0xABC47266, 0x9AB33F93, 0x9A55B51F, 0xF30BE189, 0x147F7AD1, 0x634D0AF9, 0x0F9E3F42, 0x97D8B236,
 0x49CE433B, 0x38F6B942, 0x662E61B0, 0x32A96086, 0xFF473324, 0xC2F0E28E, 0x3485A902, 0xF58D252A,
 0x0668CEC7, 0x5012FDFE, 0xF2E4F730, 0x6BAFA605, 0x369A51F5, 0x6666A66F, 0xD68718B7, 0x7C93BE85,
 0xDCDC8107, 0x705762AE, 0xBFE2CEB8, 0x4B6677A7, 0x5B803122, 0xB9310C88, 0x551F12BD, 0x133C2B82,
 0x88BD0ABD, 0xD4E7659A, 0x6521844A, 0xCA214C03, 0xF65B88B1, 0xD2926A11, 0xDD73D089, 0xC0F2DB35,
 0x4F2E837A, 0xDD55935C, 0xF8332072, 0x47772371, 0xAA3A650F, 0xB3D5D9BB, 0x821DD8CD, 0x593D441A,
 0x195C30AB, 0x54F884EC, 0x47B7EA28, 0xFBA5CADE, 0x5CF8E2E8, 0x82405EB6, 0x7E088868, 0x44704663,
 0x79E954F4, 0x9C06F941, 0x73984E0D, 0x16F54DEC, 0xAD57F761, 0x4BBF3FC6, 0x77F2B971, 0x3D4C9A6A,
 0x776BB627, 0xDE4B7776, 0x560D360B, 0x03F4AE3A, 0x7996D12E, 0x165F40CB, 0xB58A5579, 0xBC78E488,
 0xEE1F25FF, 0xC6525C43, 0x65F8CC2B, 0xE653C450, 0x72261E53, 0xF0E6CE8B, 0x10048C7D, 0x1E42E783,
 0x983D48DA, 0xC1E2C638, 0x244D2CBA, 0x04A6FEB9, 0xC4D0EB96, 0x80B92CCD, 0x84BD5FBB, 0x73EB0B4B,
 0x225A67A7, 0xDEEDBACD, 0xF02607D2, 0x419B23AC, 0xF16FDCD0, 0x9860CEA1, 0xE6D70A4A, 0x79615A72,
 0x29B72EA1, 0x1F61F8FF, 0x0884A81E, 0xCEB0F0BF, 0x5CFCA29C, 0x17EDD009, 0xED6F45DF, 0xB483C94C,
 0xAAF66CCA, 0x5CBCE5AB, 0xD898B546, 0x48745311, 0x4B48B49A, 0x481AD71B, 0x97A737EC, 0xC397FAB1,
 0xFEE4A236, 0xCCA3C8D4, 0x71E1B218, 0x72AA50A1, 0xD0FA97D4, 0xEF9AF738, 0xF0C08D5E, 0x28C5773A,
 0x161B4788, 0xEF52BE89, 0x8A043FF1, 0xE127D706, 0xF7A1DFAC, 0x6E590286, 0x565C70EC, 0x9A37F189,
 0x9112F13E, 0x2A5A01A3, 0x1B1A0E53, 0x758B4564, 0x59138727, 0x0AC6D692, 0x7A6EBF88, 0xD13F0224,
 0x167D436A, 0x18E62081, 0x27468934, 0x69835C83, 0x5EAB9DB4, 0x60282B7D, 0xBE541E0E, 0x862EE9BE,
 0xC01CD151, 0x0D2BCA92, 0x1CEE936B, 0x6EE64E05, 0x8D9A66B7, 0xB308D1AE, 0x3BC2DE21, 0x4E271F4F,
 0xCBDB1B1E, 0x4A90E026, 0x59BDCA74, 0x87B6FA35, 0x1ECEA971, 0xB8211185, 0x3E7CBD7D, 0xCACF4667,
 0xB45EC159, 0x13296A26, 0x4BA6BEFE, 0x0A1F9EF3, 0x561C37DB, 0x554294C6, 0x3409E7F0, 0xD5917C75,
 0xF9F6B582, 0xBE909723, 0x421CC8D0, 0xBC5627B5, 0xFD85C3C6, 0xE8C46727, 0xF3702427, 0x0B8B4DE4,
 0x3638DC3A, 0x55E01909, 0x078F5896, 0x04993C54, 0x81FC3753, 0xE3B02177, 0xD1FB8B09, 0xD24F6204,
 0x64ACD665, 0xD7E88060, 0x9DA9A8CF, 0xC33DF796, 0xE639002E, 0x3B64139A, 0xE80C2E96, 0x89B49688,
 0xC269EDD8, 0xD782441E, 0xD4EBA506, 0xDBD7178B, 0x7F891ADB, 0xE74F19C1, 0xA7B32252, 0x9CBDF5B6,
 0x3DF3D6E9, 0xACADA07C, 0xF7745751, 0xFCDD1914, 0x6789B0D6, 0xA957C463, 0x2944E589, 0xB524182A,
 0x3108C82F, 0x8ABF3306, 0xAF4C4FE2, 0x4DF9323C, 0x347AA2B6, 0xE13E563E, 0x8A4CF82E, 0x0509AF37,
 0x7475520D, 0x7075610F, 0x128EBB40, 0xD0581A1B, 0xDC1C485E, 0x21C8CD7F, 0x50CFF5EB, 0x4B3BF1DC,
 0x7CB5FD50, 0xE41D7A40, 0x780EC2A5, 0xC88D38EB, 0x00808E6E, 0x9EEACA9E, 0x4A362D9D, 0xFF96FBAD,
 0xC5D977A3, 0x9637A48F, 0x361E9FEF, 0x6D21E24E, 0x0FD6F89D, 0x73F6CA07, 0xCA1ACE9A, 0x26DADACB,
 0x22FCAA1C, 0x78C68B14, 0xB2498A44, 0xC9622E52, 0x7F5052BA, 0xCB3D9192, 0x23CEB4B0, 0xBEC9512C,
 0xF0848A1D, 0x721D9CCA, 0x20679CF1, 0xE06A4C70, 0xBBF7BC1E, 0xEA8619AB, 0x47AE6B10, 0x8648ED5C,
 0x37A84F59, 0xA0697C57, 0x944A18EE, 0xC7EC0C1D, 0x83EB4F4C, 0x5B00BF4C, 0x27DBC616, 0x1F293F20,
 0xECAAD02F, 0x4D647D1E, 0x42D0C115, 0x533F1BA5, 0xA700AE4D, 0xF98D702C, 0xA164A016, 0x17691E13,
 0xE62801FE, 0x6DD22966, 0xA5931848, 0x4A7AAA36, 0x8E150D23, 0xD56A37B5, 0x78E84829, 0xA1D36C7D,
 0xE7F41536, 0xE9D8BAB6, 0x26E51826, 0x67D076D9, 0x1BCF86AE, 0xE70F5EF6, 0x68C6471D, 0x39A6E378,
 0xC238AB3F, 0x4E411BAD, 0x3C6F8516, 0xE7D256E3, 0xD11941F1, 0x2EBCB82D, 0x10BF808A, 0x50297F67,
 0x2265A54A, 0x9BC16608, 0x932F0A68, 0x14DDF71E, 0x50CBB59F, 0xDE967F63, 0xEFD230E7, 0x14EEF56F,
 0xAB11FA9B, 0x08372401, 0xAB807525, 0xC06BD463, 0xAC296E66, 0xFC331370, 0x258CF93E, 0x68ECC454,
 0xBF918BFE, 0x7FC95DEC, 0x283A7C8E, 0x02A8349C, 0x63768860, 0xDF1F6D38, 0x67B6723B, 0xEC7B18A6,
 0x4A4DE833, 0xE062CC98, 0x90ACA160, 0xCC4982C4, 0xA649754F, 0x20769D21, 0xB6DC768C, 0xF6688AC0,
 0x29482515, 0x0BD28BEB, 0x84A09EF7, 0x9BABA276, 0xDA6D07A1, 0x0C371703, 0xC97BAF6A, 0x02BD7538,
 0xA06D3C23, 0x01E79651, 0x548BC1AA, 0x7318C063, 0x881F8772, 0xE761DAFC, 0xB429C46B, 0xB22BCED2,
 0xAB7B3EE5, 0x417529C8, 0xB36A9538, 0x59DBCE96, 0x7002643D, 0xB38C1FB4, 0x30859A00, 0x9776FF65,
 0xC4BE6F9C, 0x5C56AFBB, 0x0F307211, 0x1AA89E91, 0x2D6E55C2, 0x51E8AAE3, 0x4E2F9FA7, 0xE0800660,
 0x6C5F7B49, 0xB85AD42B, 0x21888A48, 0x9FBA90A4, 0xEE20E712, 0x837E8086, 0x06F1C191, 0xB31510E2,
 0xD382771C, 0xB6107F49, 0x1901B6D0, 0x73CD489E, 0x1A9B9CE0, 0xD6B41AC6, 0x8749F181, 0x0A7DDA65,
 0x3405276C, 0x6B67EFB4, 0x4C5EE35A, 0xAF840653, 0x373D8093, 0xFD98028A, 0x0084CE1A, 0x0B474421,
 0xD951E02A, 0x0F657482, 0x16C64F9D, 0x568DB865, 0x9D1E64A4, 0x33A0FCB3, 0xE9C9BB66, 0x705322DA,
 0x2A4F4007, 0xD801BA10, 0xAB73BE0D, 0x6A2E34B6, 0x95A50E57, 0xB83CD0C9, 0xD63C1440, 0x32F82661,
 0x66846C97, 0x2A74C29E, 0x0880E86A, 0x5B1D7E00, 0xCF9B6F2B, 0xE71E5F26, 0x3E707DE1, 0x7439D5A6,
 0x01F69781, 0x023DFB56, 0x3E87F6BD, 0x4BD1BBCC, 0xAB1D3A07, 0xB6C1B7C0, 0x1E2823FD, 0xD17F4513,
 0xD9082625, 0xBDFD364F, 0xD88DF4E2, 0x8B6FE752, 0x95B04FF3, 0x7B27648A, 0x08C4EF29, 0x01C595F0,
};

void rdmzier(uint8_t *buf, int size, int page)
{
	int i, j;
	unsigned int *bi = (unsigned int *)buf;
	j = page%256;

	for (i = 0; i < size; i++) {
		bi[i]	= rdmz[j] ^ bi[i];
		j++;
		if (j >= BYTE_SEED)
			j = 0;
	}
}

void rdmzier_oob(uint8_t *buf, uint8_t *src, int size, int page, int ofs)
{
	int i, j;
	unsigned int *bi = (unsigned int *)buf;
	unsigned int *bs = (unsigned int *)src;
	j = page%256;
	j = (j+ofs)%BYTE_SEED;

	for (i = 0; i < size; i++) {
		bi[i]	= rdmz[j] ^ bs[i];
		j++;
		if (j >= BYTE_SEED)
			j = 0;
	}
}


struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE] = {{0}};
int eslc_load_image(struct nand_chip *nand, unsigned long long naddr, unsigned int maddr, unsigned int size);
int eslc_save_image(struct nand_chip *nand, unsigned long long naddr, unsigned int dwImageStart, unsigned int dwImageLength);
int eslc_nand_write_block(struct nand_chip *nand, unsigned int start, unsigned int page, unsigned int page_count, unsigned char *oob);
int read_retry_param_from_nand(struct nand_chip *nand, int chip);
int write_retry_param_to_nand(struct nand_chip *nand, int chip);
int toshiba_pre_condition(void);
int write_bytes_param(int cmd_cnt, int addr_cnt, int data_cnt, uchar *cmd, uchar *addr, uchar *data);

/* Current NAND Device	*/
static int curr_device = -1;

//FIXME: move Wmt*Nand* Functions to sepereate file?
struct nand_chip* get_current_nand_chip(void){
    if(curr_device >= 0 && curr_device < CFG_MAX_NAND_DEVICE)
		return nand_dev_desc + curr_device;
	return NULL;
}

struct nand_read_retry_param *cur_chip = NULL;
#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
#define READ_RETRY_CHIP_NUM ARRAY_SIZE(chip_table)

/* ------------------------------------------------------------------------- */

int do_nand (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
    int rcode = 0;

    switch (argc) {
    case 0:
    case 1:
	printf ("Usage:\n%s\n", cmdtp->usage);
	return 1;
    case 2:
	if (strcmp(argv[1],"info") == 0) {
		int i;

		putc ('\n');

		for (i=0; i<CFG_MAX_NAND_DEVICE; ++i) {
			if(nand_dev_desc[i].ChipID == NAND_ChipID_UNKNOWN)
				continue; /* list only known devices */
			printf ("Device %d: ", i);
			nand_print(&nand_dev_desc[i]);
		}
		return 0;

	} else if (strcmp(argv[1],"device") == 0) {
		if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
			puts ("\nno devices available\n");
			return 1;
		}
		printf ("\nDevice %d: ", curr_device);
		nand_print(&nand_dev_desc[curr_device]);
		return 0;

	} else if (strcmp(argv[1],"bad") == 0) {
		if ((curr_device < 0) || (curr_device >= CFG_MAX_NAND_DEVICE)) {
			puts ("\nno devices available\n");
			return 1;
		}
		printf ("\nDevice %d bad blocks:\n", curr_device);
		nand_print_bad(&nand_dev_desc[curr_device]);
		return 0;
	}
	printf ("Usage:\n%s\n", cmdtp->usage);
	return 1;
    case 3:
	if (strcmp(argv[1],"device") == 0) {
		int dev = (int)simple_strtoul(argv[2], NULL, 10);

		printf ("\nDevice %d: ", dev);
		if (dev >= CFG_MAX_NAND_DEVICE) {
			puts ("unknown device\n");
			return 1;
		}
		nand_print(&nand_dev_desc[dev]);
		/*nand_print (dev);*/

		if (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN) {
			return 1;
		}

		curr_device = dev;

		puts ("... is now current device\n");

		return 0;
	}	else if (strncmp(argv[1], "erase", 4) == 0 || strncmp(argv[1], "erase", 3) == 0) {
		struct nand_chip* nand = &nand_dev_desc[curr_device];
		if (strcmp(argv[2], "all") == 0) {
			printf("Erase all\n");
			WMTEraseNAND(nand, 0, 0, 1);
			return 0;
		} else if (strcmp(argv[2], "force") == 0) {
			printf("Erase force all include bbt and bad block\n");
			WMTEraseNANDALL(nand, 1);

			return 0;
		} else if (strcmp(argv[2], "table") == 0) {
			printf("Erase bbt Table\n");
			WMTEraseNANDALL(nand, 0);

			return 0;
		} else if (strcmp(argv[2], "retry") == 0) {
			printf("Erase retry Table\n");
			WMTEraseNANDALL(nand, 2);

			return 0;
		}
		return 0;
	}	else if (strncmp(argv[1], "tellme", 3) == 0) {
		struct nand_chip* nand = &nand_dev_desc[curr_device];
		if (strcmp(argv[2], "bad") == 0)
			tellme_badblock(nand);
		if (strcmp(argv[2], "table") == 0)
			tellme_whereistable(nand);
		if (strcmp(argv[2], "nand") == 0)
			tellme_nandinfo(nand);
		else if (strcmp(argv[2], "retry") == 0)
			get_read_retry_para(nand);
		return 0;
	}

	printf ("Usage:\n%s\n", cmdtp->usage);
	return 1;
    default:
	/* at least 4 args */
#if 0
	if (strncmp(argv[1], "read", 4) == 0 ||
	    strncmp(argv[1], "write", 5) == 0) {
		ulong addr = simple_strtoul(argv[2], NULL, 16);
		ulong off  = simple_strtoul(argv[3], NULL, 16);
		ulong size = simple_strtoul(argv[4], NULL, 16);
		int cmd    = (strncmp(argv[1], "read", 4) == 0) ?
				NANDRW_READ : NANDRW_WRITE;
		int ret, total;
		char* cmdtail = strchr(argv[1], '.');

		if (cmdtail && !strncmp(cmdtail, ".oob", 2)) {
			/* read out-of-band data */
			if (cmd & NANDRW_READ) {
				ret = nand_read_oob(nand_dev_desc + curr_device,
						    off, size, (size_t *)&total,
						    (u_char*)addr);
			}
			else {
				ret = 0;
				/*ret = nand_write_oob(nand_dev_desc + curr_device,
						     off, size, (size_t *)&total,
						     (u_char*)addr);*/
			}
			return ret;
		}
		else if (cmdtail && !strncmp(cmdtail, ".jffs2s", 7)) {
			cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
			if (cmd & NANDRW_READ)
				cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
		}
		else if (cmdtail && !strncmp(cmdtail, ".jffs2", 2))
			cmd |= NANDRW_JFFS2;	/* skip bad blocks (fill with 0xFF)*/
#ifdef SXNI855T
		/* need ".e" same as ".j" for compatibility with older units */
		else if (cmdtail && !strcmp(cmdtail, ".e"))
			cmd |= NANDRW_JFFS2;	/* skip bad blocks */
#endif
#ifdef CFG_NAND_SKIP_BAD_DOT_I
		/* need ".i" same as ".jffs2s" for compatibility with older units (esd) */
		/* ".i" for image -> read skips bad block (no 0xff) */
		else if (cmdtail && !strcmp(cmdtail, ".i")) {
			cmd |= NANDRW_JFFS2;	/* skip bad blocks (on read too) */
			if (cmd & NANDRW_READ)
				cmd |= NANDRW_JFFS2_SKIP;	/* skip bad blocks (on read too) */
		}
#endif /* CFG_NAND_SKIP_BAD_DOT_I */
		else if (cmdtail) {
			printf ("Usage:\n%s\n", cmdtp->usage);
			return 1;
		}

		printf ("\nNAND %s: device %d offset %ld, size %ld ... ",
			(cmd & NANDRW_READ) ? "read" : "write",
			curr_device, off, size);

		ret = nand_rw(nand_dev_desc + curr_device, cmd, off, size,
			     (size_t *)&total, (u_char*)addr);

		printf (" %d bytes %s: %s\n", total,
			(cmd & NANDRW_READ) ? "read" : "written",
			ret ? "ERROR" : "OK");

		return ret;
	} else 
#endif
	if (strncmp(argv[1], "r", 1) == 0 && argc == 5) {
		int ret;
		//ulong off = simple_strtoul(argv[2], NULL, 16);
		unsigned long long off = simple_strtoull(argv[2], NULL, 16);
		ulong maddr  = simple_strtoul(argv[3], NULL, 16);
		ulong size = simple_strtoul(argv[4], NULL, 16);
		if (!size) {
				printf("size=0\n");
				return 1;
		}
		/*printf("Load Image Form NAND Flash off=0x%lx\r\n", off);*/
		ret = WMTLoadImageFormNAND(nand_dev_desc + curr_device, off, maddr, size);
		return ret;
	} else if (strncmp(argv[1], "w", 1) == 0 && argc == 5) {
		int ret;
		ulong maddr = simple_strtoul(argv[2], NULL, 16);
		//ulong off = simple_strtoul(argv[3], NULL, 16);
		unsigned long long off = simple_strtoull(argv[3], NULL, 16);
		ulong size = simple_strtoul(argv[4], NULL, 16);
		if (!size) {
				printf("size=0\n");
				return 1;
		}
		ret = WMTSaveImageToNAND(nand_dev_desc + curr_device, off, maddr, size);
		return ret;
	} else if (strncmp(argv[1], "er", 2) == 0 && argc == 5) {
		int ret;
		//ulong off = simple_strtoul(argv[2], NULL, 16);
		unsigned long long off = simple_strtoull(argv[2], NULL, 16);
		ulong maddr  = simple_strtoul(argv[3], NULL, 16);
		ulong size = simple_strtoul(argv[4], NULL, 16);
		if (!size) {
				printf("size=0\n");
				return 1;
		}
		if(!cur_chip) {
			printf("Warning: This chip not need eslc and read retry.\n");
			return 1;
		}
		/*printf("Load Image Form NAND Flash off=0x%lx\r\n", off);*/
		ret = eslc_load_image(nand_dev_desc + curr_device, off, maddr, size);
		return ret;
	} else if (strncmp(argv[1], "ew", 2) == 0 && argc == 5) {
		int ret;
		ulong maddr = simple_strtoul(argv[2], NULL, 16);
		//ulong off = simple_strtoul(argv[3], NULL, 16);
		unsigned long long off = simple_strtoull(argv[3], NULL, 16);
		ulong size = simple_strtoul(argv[4], NULL, 16);
		if (!size) {
				printf("size=0\n");
				return 1;
		}
		if(!cur_chip) {
			printf("Warning: This chip not need eslc and read retry.\n");
			return 1;
		}
	
		ret = eslc_save_image(nand_dev_desc + curr_device, off, maddr, size);
		return ret;
	} else if (strncmp(argv[1], "boot", 1) == 0 && argc == 6) {
		int ret;
		unsigned long long off = simple_strtoull(argv[2], NULL, 16);
		ulong maddr_kernel  = simple_strtoul(argv[3], NULL, 16);
		ulong maddr_ramdisk = simple_strtoul(argv[4], NULL, 16);
		
		printf("nand partition offset=0x%lx%x\r\n", (ulong)(off>>32), (ulong)off);
		ret = nand_boot(nand_dev_desc + curr_device, off, maddr_kernel, maddr_ramdisk, argv[5]);
		if (ret)
			return 0;
		return ret;
	} else if ((strcmp(argv[1],"erase") == 0 && strncmp(argv[2], "address", 4) == 0)
	&& strcmp(argv[3], "clean") == 0) {
		struct nand_chip* nand = &nand_dev_desc[curr_device];
		ulong off = 0;
		ulong size = nand->totlen;
		int ret;

		printf ("\nNAND erase: device %d offset %ld, size %ld ... ",
			curr_device, off, size);

		ret = nand_erase(nand, off, size, 1);

		printf("%s\n", ret ? "ERROR" : "OK");

		return ret;
	} else if ((strcmp(argv[1],"erase") == 0 && (strcmp("address", argv[2]) == 0))
	&& (argc == 5 || strcmp("clean", argv[3]) == 0)) {
		int clean = argc == 6;
		ulong off = simple_strtoul(argv[3 + clean], NULL, 16);
		ulong size = simple_strtoul(argv[4 + clean], NULL, 16);
		int ret;

		printf ("\nNAND erase: device %d offset %ld, size %ld ... ",
			curr_device, off, size);

		ret = nand_erase(nand_dev_desc + curr_device, off, size, clean);

		printf("%s\n", ret ? "ERROR" : "OK");

		return ret;
	} else if (strcmp(argv[1],"erase") == 0 &&
		   (argc == 4)) {
		ulong start_blk = simple_strtoul(argv[2], NULL, 16);
		ulong blk_num = simple_strtoul(argv[3], NULL, 16);
		WMTEraseNAND(nand_dev_desc + curr_device, start_blk, blk_num, 0);
	} else if (strncmp(argv[1], "set", 3) == 0 && (argc == 4)) {
		struct nand_chip* nand = &nand_dev_desc[curr_device];
		int reg  = simple_strtoul(argv[3], NULL, 16);
		if (strcmp(argv[2], "retry") == 0)
			set_read_retry_para(nand, reg);
	} else {
		printf ("Usage:\n%s\n", cmdtp->usage);
		rcode = 1;
	}

	return rcode;
  }
}

U_BOOT_CMD(
	nandrw,	6,	1,	do_nand,
	"nandrw  - NAND sub-system\n",
	"nandrw info  - show available NAND devices\n"
	/*"nandrw device [dev] - show or set current device\n"
	"nandrw read[.jffs2[s]]  addr off size\n"
	"nandrw write[.jffs2] addr off size - read/write `size' bytes starting\n"
	"    at offset `off' to/from memory address `addr'\n"
	"nandrw erase address [clean] [off size] - erase `size' bytes from\n"
	"    offset `off' (entire device if not specified)\n"
	"nandrw bad - show bad blocks by checking initial defective marker\n"
	" \r\n"*/
	"nandrw erase start_block block_numbers - erase blocks skip bad block\n"
	"nandrw erase all   - erase full blocks except table blocks (last 4 blocks)\n"
	/*"nandrw erase table - erase table blocks (last 4 blocks)\n"*/
	/*"nandrw erase force - erase entire device including table blocks\n"*/
	"nandrw tellme nand - show nand flash info\n"
	"nandrw tellme bad - show bad blocks from bad block table\n"
	"nandrw tellme table - show bad block table\n"
	/*"nandrw read.oob addr off size - read out-of-band data\n"*/
	"nandrw r off addr size - read nand flash from offset 'off' to memory\n"
	"    address `addr' with skip bad blocks\n"
	"nandrw w addr off size - write nand flash from memory address 'addr' to nand\n"
	"    flash offset `off' with skip bad blocks\n"
	/*"nandrw write.oob addr off size - read out-of-band data\n"*/

);

#if 0
int do_nandboot (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	char *boot_device = NULL;
	char *ep;
	int dev;
	ulong cnt;
	ulong addr;
	ulong offset = 0;
	image_header_t *hdr;
	int rcode = 0;
	switch (argc) {
	case 1:
		addr = CFG_LOAD_ADDR;
		boot_device = getenv ("bootdevice");
		break;
	case 2:
		addr = simple_strtoul(argv[1], NULL, 16);
		boot_device = getenv ("bootdevice");
		break;
	case 3:
		addr = simple_strtoul(argv[1], NULL, 16);
		boot_device = argv[2];
		break;
	case 4:
		addr = simple_strtoul(argv[1], NULL, 16);
		boot_device = argv[2];
		offset = simple_strtoul(argv[3], NULL, 16);
		break;
	default:
		printf ("Usage:\n%s\n", cmdtp->usage);
		SHOW_BOOT_PROGRESS (-1);
		return 1;
	}

	if (!boot_device) {
		puts ("\n** No boot device **\n");
		SHOW_BOOT_PROGRESS (-1);
		return 1;
	}

	dev = simple_strtoul(boot_device, &ep, 16);

	if ((dev >= CFG_MAX_NAND_DEVICE) ||
	    (nand_dev_desc[dev].ChipID == NAND_ChipID_UNKNOWN)) {
		printf ("\n** Device %d not available\n", dev);
		SHOW_BOOT_PROGRESS (-1);
		return 1;
	}

	printf ("\nLoading from device %d: %s at 0x%lx (offset 0x%lx)\n",
		dev, nand_dev_desc[dev].name, nand_dev_desc[dev].IO_ADDR,
		offset);

	if (nand_rw(nand_dev_desc + dev, NANDRW_READ, offset,
		    SECTORSIZE, NULL, (u_char *)addr)) {
		printf ("** Read error on %d\n", dev);
		SHOW_BOOT_PROGRESS (-1);
		return 1;
	}

	hdr = (image_header_t *)addr;

	if (ntohl(hdr->ih_magic) == IH_MAGIC) {

		print_image_hdr (hdr);

		cnt = (ntohl(hdr->ih_size) + sizeof(image_header_t));
		cnt -= SECTORSIZE;
	} else {
		printf ("\n** Bad Magic Number 0x%x **\n", hdr->ih_magic);
		SHOW_BOOT_PROGRESS (-1);
		return 1;
	}

	if (nand_rw(nand_dev_desc + dev, NANDRW_READ, offset + SECTORSIZE, cnt,
		    NULL, (u_char *)(addr+SECTORSIZE))) {
		printf ("** Read error on %d\n", dev);
		SHOW_BOOT_PROGRESS (-1);
		return 1;
	}

	/* Loading ok, update default load address */

	load_addr = addr;

	/* Check if we should attempt an auto-start */
	if (((ep = getenv("autostart")) != NULL) && (strcmp(ep,"yes") == 0)) {
		char *local_args[2];
		extern int do_bootm (cmd_tbl_t *, int, int, char *[]);

		local_args[0] = argv[0];
		local_args[1] = NULL;

		printf ("Automatic boot of image at addr 0x%08lx ...\n", addr);

		do_bootm (cmdtp, 0, 1, local_args);
		rcode = 1;
	}
	return rcode;
}

U_BOOT_CMD(
	nboot,	4,	1,	do_nandboot,
	"nboot   - boot from NAND device\n",
	"loadAddr dev\n"
);
#endif

void WRITE_NAND_COMMAND(unsigned int cmd)
{
	pNFCRegs->NFCR2 = (unsigned char)cmd;
}



//FIXME: this command has nothing to do with nand, move this to another file?
int do_parseimg (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]){

    char buf[10];
	ulong imgAddr, kernelAddr, ramdiskAddr;
    unsigned int kernelSize, ramdiskSize, pageSize, ramOff;
	struct boot_img_hdr *imgHdr = NULL;
	
	
	if(argc < 5){
		printf("Invalid argument , type 'help parseimg' to view the help msg\n");
		return 1;
	}

	imgAddr = simple_strtoul(argv[1], NULL, 16);
	imgHdr = (struct boot_img_hdr *)imgAddr;

	if (strncmp((char *)imgHdr->magic, "ANDROID!", 8) != 0) {
		printf("fail: image header (0x%x) signature is not \"ANDROID!\" \n", imgAddr);
		return 0;
	}

	kernelAddr  = simple_strtoul(argv[2], NULL, 16);
	ramdiskAddr = simple_strtoul(argv[3], NULL, 16);

    kernelSize = imgHdr->kernel_size;
	ramdiskSize = imgHdr->ramdisk_size;
	pageSize = imgHdr->page_size;

	memcpy((void*)kernelAddr, (void*)(imgAddr+pageSize), kernelSize);

	ramOff =  pageSize + kernelSize + ((kernelSize%pageSize) ? (pageSize - (kernelSize%pageSize)) : 0);
	memcpy((void*)ramdiskAddr, (void*)(imgAddr+ramOff), ramdiskSize);

	sprintf(buf, "%lx", ramdiskSize);
	setenv(argv[4], buf);	

	return 0;
}

U_BOOT_CMD(
	parseimg,	5,	1,	do_parseimg,
	"parseimg   - parse android img\n",
	"imgMemAddr kernelMemAddr ramdiskMemAddr sizeVar\n"
);


int nand_boot(
struct nand_chip* nand,
unsigned long long off,
unsigned int mem_kernel,
unsigned int mem_ramdisk,
char * ramdiskSize)
{
	int ret = 0;
	struct boot_img_hdr *img_hdr;
	char *s = NULL, *p = NULL, buf[10];
	unsigned int maddr, page_size, kernel_size, ramdisk_size, total_size;
	unsigned int load_kernel, copy_start;

	s = getenv("boot-method");
	if (strncmp(s, "boot-nand-normal", 16) == 0) {
		p = getenv("nand-normal-offs");
	}
	load_kernel = mem_kernel;
	maddr = mem_ramdisk;
	printf("load_kernel = 0x%x load_ramdisk=0x%x, nand offset = 0x%lx \n", load_kernel, maddr, (ulong)off);
	
	//read header 608 Bytes
	//if(cur_chip && nand->mfr == 0xad)
	//	ret = eslc_load_image(nand_dev_desc , off, maddr, nand->oobblock);
	//else 
		ret = WMTLoadImageFormNAND(nand_dev_desc /*+ curr_device*/, off, maddr, nand->oobblock);
	if (ret) {
		printf("read nand img header fail\n");
		return 0;
	}

	img_hdr = (struct boot_img_hdr *)maddr;
	if (strncmp((char *)img_hdr->magic, "ANDROID!", 8) != 0) {
		printf("fail: image header signature is not \"ANDROID!\" \n");
		return 0;
	}
	kernel_size = img_hdr->kernel_size;
	ramdisk_size = img_hdr->ramdisk_size;
	page_size = img_hdr->page_size;

	printf("kernel_size = 0x%x ramdisk_size = 0x%x, page_size=0x%x\n",
	kernel_size, ramdisk_size, page_size);
	
	if (kernel_size == 0) {
		printf("kernel size is zero\n");
		return 0;
	}

	total_size = (page_size<<1) + kernel_size + ramdisk_size;
	printf("read kernel from offset = 0x%x to mem = 0x%x, size=0x%x\n", (ulong)off, maddr,total_size);
	//if(cur_chip && nand->mfr == 0xad)
	//	ret = eslc_load_image(nand_dev_desc , off, maddr, total_size);
	//else 
		ret = WMTLoadImageFormNAND(nand_dev_desc /*+ curr_device*/, off, maddr, total_size);
	if (ret) {
		printf("read nand kernel fail\n");
		return 0;
	}
	memcpy((void *)load_kernel, (void *)(maddr+page_size), kernel_size);

	if (ramdisk_size == 0) {
		printf("ramdisk size is zero\n");
		return 0;
	}
	copy_start = page_size + kernel_size +
	((kernel_size%page_size) ? (page_size - (kernel_size%page_size)) : 0);
	memcpy((void *)maddr, (void *)(maddr+copy_start), ramdisk_size);

	sprintf(buf, "%lx", ramdisk_size);
	setenv(ramdiskSize, buf);

	return ramdisk_size;
}

void print_nfc_register(void){
	int j;
	for (j = 0; j < 0x60; j += 4)
	printf("XDCR%x ~ XDCR%x = 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x\r\n",
	j, j+3,
	*(unsigned int *)(&pNFCRegs->NFCR0+j+0),
	*(unsigned int *)(&pNFCRegs->NFCR0+j+1),
	*(unsigned int *)(&pNFCRegs->NFCR0+j+2),
	*(unsigned int *)(&pNFCRegs->NFCR0+j+3));
}

void print_nand_buf(unsigned char * rvalue, int length)
{
	int j;
	for (j = 0; j < length; j += 16)
	/*printf("Row%x:%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x\n",
		j, rvalue[j+0], rvalue[j+1], rvalue[j+2], rvalue[j+3], rvalue[j+4],
		rvalue[j+5], rvalue[j+6], rvalue[j+7], rvalue[j+8], rvalue[j+9],
		rvalue[j+10], rvalue[j+11], rvalue[j+12], rvalue[j+13], rvalue[j+14], rvalue[j+15]);*/
		printf("Row%3.3x:%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
		j, rvalue[j+0], rvalue[j+1], rvalue[j+2], rvalue[j+3], rvalue[j+4],	rvalue[j+5], rvalue[j+6],
		rvalue[j+7], rvalue[j+8], rvalue[j+9], rvalue[j+10], rvalue[j+11], rvalue[j+12],
		rvalue[j+13], rvalue[j+14], rvalue[j+15]);
}

void nfc_ecc_set(unsigned int type, unsigned int ecc, struct nand_chip *nand)
{
	if (type == USE_HW_ECC) {
		printf("USE_HW_ECC ");
		pNFCRegs->NFCR15 &= (~(unsigned int)USE_SW_ECC);
		pNFCRegs->NFCR23 &= 0xfffffff0;
		pNFCRegs->NFCR23 |= ecc;
	/* enable 4bit ecc interrupt and new structure */
		if (ecc != ECC1bit) {
			if (ecc == ECC40bitPer1K)
				printf("ECC40bitPer1K\n");
			else if (ecc == ECC24bitPer1K)
				printf("ECC24bitPer1K\n");
			else if (ecc == ECC12bit)
				printf("ECC12bit\n");
			else if(ecc == ECC4bit)
				printf("ECC4bit\n");
			nand->nfc_read_page = nfc_BCH_read_page;
			pNFCRegs->NFCR24 = eccBCH_interrupt_enable;
			pNFCRegs->NFCR12 &= (~OLDATA_EN);
			pNFCRegs->NFCR23 |= READ_RESUME;/* do for safty	*/
		} else if (ecc == ECC1bit) {
			/* disable 4bit ecc interrupt and old structure  */
			printf("ECC1bit\n");
			nand->nfc_read_page = nfc_1bit_read_page;
			/* make sure our status is clear before we start */
			pNFCRegs->NFCR1f |= 0x07;
			pNFCRegs->NFCR20 |= 0xffffffff;
			/* pNFCRegs->NFCR24 = ecc4bit_inetrrupt_disable; */
			pNFCRegs->NFCR12 |= OLDATA_EN;
			pNFCRegs->NFCR23 |= READ_RESUME;/* do for safty */
		}
	} else {
		/*if (ecc == ECC1bit) {
			printf("USE_SW_ECC\n");
			nand->nfc_read_page = nand_read_page;
			pNFCRegs->NFCR15 |= USE_SW_ECC;
			pNFCRegs->NFCR12 &= (~OLDATA_EN);
			pNFCRegs->NFCR23 &= 0xfffffff8;
		} else {*/
			printf("USE_SW_ECC\n");
			nand->nfc_read_page = nfc_BCH_read_page;
			pNFCRegs->NFCR23 |= BCH_ECC_DIS;
	//}
	}
}

int shift_bit(unsigned int value)
{
	int i = 0;
	while (!(value & 1)) {
		value >>= 1;
		i++;
		if (i == 32)
			break;
	}
	/* return the number count of "zero" bit */
	return i;
}

int NFC_WAIT_READY(void)
{
	int i = 0;

	while (1) {
		if (!(pNFCRegs->NFCRa & NFC_BUSY))
			break;
		if (i>>21)
			return -3;
		i++;
	}
	return 0;
}

int NAND_WAIT_READY(void)
{
	int i = 0;

	while (1) {
		if (pNFCRegs->NFCRb & B2R)
			break;
		if ((i>>21))
			return -1;
		i++;
	}
	pNFCRegs->NFCRb |= B2R;
	return 0;
}

int NFC_WAIT_CMD_READY(void)
{
	int i = 0;

	while (1) {
		if (!(pNFCRegs->NFCRa & NFC_CMD_RDY))
			break;
		if (i>>21)
			return -4;
		i++;
	}
	return 0;
}

int NAND_WAIT_IDLE(void)
{
	int i = 0;

	while (1) {
		if (pNFCRegs->NFCR1d & NFC_IDLE)
			break;
		if (i>>21)
			return -2;
		i++;
	}
	return 0;
}
/* returns 0 if block containing pos is OK:
 *		valid erase block and
 *		not marked bad, or no bad mark position is specified
 * returns 1 if marked bad or otherwise invalid
 */
int check_block(struct nand_chip *nand, unsigned long block)
{
	/*size_t retlen;
	uint8_t oob_data;
	uint16_t oob_data16[6];*/
	int j, rc = -1;
	int page[2];
	page[1] = page[0] = block * nand->dwPageCount;
	int badpos = (nand->dwBIOffset&0xffff);/*oob_config.badblock_pos;*/
	page[0] += (nand->dwBI0Position&0xffff);
	page[1] += (nand->dwBI1Position&0xffff);

	if (block >= nand->dwBlockCount)
		return 1;

	if (badpos < 0)
		return 0;	/* no way to check, assume OK */

	for (j = 0; j < 2; j++) {
		rc = nand->nfc_read_page(nand, page[j],	(unsigned int)nand->data_buf, nand->oobblock+nand->oobsize);
		if (rc) {
			printf("scan bbt err at addr %d, rc=%d\n", page[j], rc);
			if (rc != -ERR_ECC_UNCORRECT)
				return rc;
			printf("read page fail at block%d\n", block);
			return 1;
		} else {
			if (*(((unsigned char *)nand->data_buf)+nand->oobblock+badpos) != 0xFF ||
				*((unsigned char *)nand->data_buf) != 0xFF) {
				printf("find bad block : block%d  ", block);
				return 1;
			}
		}
	}
	#if 0
	if (nand->bus16) {
		if (nand_read_oob(nand, (page0 + 0), 12, &retlen, (uint8_t *)oob_data16)
		    || (oob_data16[2] & 0xff00) != 0xff00)
			return 1;
		if (nand_read_oob(nand, (page1 + 0), 12, &retlen, (uint8_t *)oob_data16)
		    || (oob_data16[2] & 0xff00) != 0xff00)
			return 1;
	} else {
		/* Note - bad block marker can be on first or second page */
		if (nand_read_oob(nand, page0 + badpos, 1, &retlen, (unsigned char *)&oob_data)
		    || oob_data != 0xff
		    || nand_read_oob (nand, page1 + badpos, 1, &retlen, (unsigned char *)&oob_data)
		    || oob_data != 0xff)
			return 1;
	}
	#endif
	

	return 0;
}

/* print bad blocks in NAND flash */
static void nand_print_bad(struct nand_chip* nand)
{
	unsigned long block, chip;

	nfc_ecc_set(USE_SW_ECC, ECC1bit, nand);
	for (chip = 0; chip < nand->numchips; chip++) {
		NAND_ENABLE_CE(nand, chip);
		for (block = 0; block < nand->dwBlockCount; block++) {
			if (check_block(nand, block))
				printf(" 0x%8.8lx\n", block);
		}
	}

	NAND_DISABLE_CE(nand);
	set_ECC_mode(nand);
	puts("\n");
}

#if 0
/* cmd: 0: NANDRW_WRITE			write, fail on bad block
 *	1: NANDRW_READ			read, fail on bad block
 *	2: NANDRW_WRITE | NANDRW_JFFS2	write, skip bad blocks
 *	3: NANDRW_READ | NANDRW_JFFS2	read, data all 0xff for bad blocks
 *      7: NANDRW_READ | NANDRW_JFFS2 | NANDRW_JFFS2_SKIP read, skip bad blocks
 */
int nand_rw (struct nand_chip* nand, int cmd,
	    size_t start, size_t len,
	    size_t * retlen, u_char * buf)
{
	int ret = 0, n, total = 0;
	char eccbuf[6];
	/* eblk (once set) is the start of the erase block containing the
	 * data being processed.
	 */
	unsigned long eblk = ~0;	/* force mismatch on first pass */
	unsigned long erasesize = nand->erasesize;
	NAND_ENABLE_CE(nand, 0);  /* set pin low */
	if (check_block_table(nand, 0)) {
		NAND_DISABLE_CE(nand);  /* set pin high */
		return -1;
	}

	while (len) {
		if ((start & (-erasesize)) != eblk) {
			/* have crossed into new erase block, deal with
			 * it if it is sure marked bad.
			 */
			eblk = start & (-erasesize); /* start of block */
			/*printf("check bad block in eblk = 0x%x\n", eblk);*/
			ret = nand->isbadblock(nand, eblk/nand->erasesize, 0);
			/*printf("check bad block out ret= %d\n", ret);*/
			if (ret < 0) {
				printf("bbt is not exist\n");
				NAND_DISABLE_CE(nand);  /* set pin high */
				return ret;
			} else if (ret > 0) {
				if (cmd == (NANDRW_READ | NANDRW_JFFS2)) {
					while (len > 0 &&
					       start - eblk < erasesize) {
						*(buf++) = 0xff;
						++start;
						++total;
						--len;
					}
					continue;
				} else if (cmd == (NANDRW_READ | NANDRW_JFFS2 | NANDRW_JFFS2_SKIP)) {
					start += erasesize;
					continue;
				} else if (cmd == (NANDRW_WRITE | NANDRW_JFFS2)) {
					/* skip bad block */
					start += erasesize;
					continue;
				} else {
					ret = 1;
					break;
				}
			}
		}
		/* The ECC will not be calculated correctly if
		   less than 512 is written or read */
		/* Is request at least 512 bytes AND it starts on a proper boundry */
		if((start != ROUND_DOWN(start, 0x200)) || (len < 0x200))
			printf("Warning block writes should be at least 512 bytes and start on a 512 byte boundry\n");

		if (cmd & NANDRW_READ) {
			ret = nand_read_ecc(nand, start,
					   min(len, eblk + erasesize - start),
					   (size_t *)&n, (u_char*)buf, (u_char *)eccbuf);
		} else {
			ret = nand_write_ecc(nand, start,
					    min(len, eblk + erasesize - start),
					    (size_t *)&n, (u_char*)buf, (u_char *)eccbuf);
		}

		if (ret&1)
			break;

		start  += n;
		buf   += n;
		total += n;
		len   -= n;
	}
	if (retlen)
		*retlen = total;

	NAND_DISABLE_CE(nand);  /* set pin high */
	return (ret&1);
}
#endif

static void nand_print(struct nand_chip *nand)
{
	if (nand->numchips > 1) {
		printf("%s at 0x%lx,\n"
		       "\t  %d chips %s, size %d MB, \n"
		       "\t  total size %ld MB, sector size %ld kB\n",
		       nand->name, nand->IO_ADDR, nand->numchips,
		       nand->chips_name, 1 << (nand->chipshift - 20),
		       nand->totlen >> 20, nand->erasesize >> 10);
	} else {
		printf("%s at 0x%lx (", nand->chips_name, nand->IO_ADDR);
		print_size(nand->totlen, ", ");
		print_size(nand->erasesize, " sector)\n");
	}
}

/* ------------------------------------------------------------------------- */
#if 0
static int NanD_WaitReady(struct nand_chip *nand, int ale_wait)
{
	/* This is inline, to optimise the common case, where it's ready instantly */
	int ret = 0;

#ifdef NAND_NO_RB	/* in config file, shorter delays currently wrap accesses */
	if(ale_wait)
		NAND_WAIT_READY();	/* do the worst case 25us wait */
	else
		udelay(10);
#else	/* has functional r/b signal */
	NAND_WAIT_READY();
#endif
	return ret;
}

/* NanD_Command: Send a flash command to the flash chip */
#if 0
static inline int NanD_Command(struct nand_chip *nand, unsigned char command)
{
	unsigned long nandptr = nand->IO_ADDR;

	/* Assert the CLE (Command Latch Enable) line to the flash chip */
	NAND_CTL_SETCLE(nandptr);

	/* Send the command */
	WRITE_NAND_COMMAND(command, nandptr);

	/* Lower the CLE line */
	NAND_CTL_CLRCLE(nandptr);

#ifdef NAND_NO_RB
	if(command == NAND_CMD_RESET){
		u_char ret_val;
		NanD_Command(nand, NAND_CMD_STATUS);
		do {
			ret_val = READ_NAND(nandptr);/* wait till ready */
		} while((ret_val & 0x40) != 0x40);
	}
#endif
	return NanD_WaitReady(nand, 0);
}
#endif
#endif
/* NanD_Address: Set the current address for the flash chip */
void NanD_Address(struct nand_chip *nand, int numbytes, unsigned int col, unsigned int row)
{
	unsigned char addr[10];
	unsigned int i = 0, tmp;
	unsigned int nandptr = 0;

	if (nand->id == 0xECDED57A)
		if (row >= (4096*128)) {
			row = row + 0x80000;
	}

	memset(addr, 0, 10);
	nandptr = g_WMTNFCBASE + 0x0c;
	if (numbytes == ADDR_COLUMN_PAGE) {
		for (i = 0; i < nand->col; i++)
			addr[i] = (col>>(i*8));
		for (i = nand->col; i < (nand->row + nand->col); i++)
			addr[i] = (row>>((i-nand->col)*8));
		for (i = 0; i <= (nand->col+nand->row); i += 2, nandptr += 4) {
			tmp = (addr[i+1]<<8)+addr[i];
			WRITE_NAND16(tmp, nandptr);
			/*printf("write %x to %8.8x\n",tmp,nandptr);*/
		}
	}
	if (numbytes == ADDR_COLUMN) {
			for (i = 0; i < nand->col; i++)
				addr[i] = (col>>(i*8));
		for (i = 0; i < nand->col; i += 2, nandptr += 4) {
			tmp = (addr[i+1]<<8)+addr[i];
			WRITE_NAND16(tmp, nandptr);
		}
	}
	if (numbytes == ADDR_PAGE) {
		for (i = 0; i < nand->row; i++)
				addr[i] = (row>>(i*8));

		for (i = 0; i < nand->row; i += 2, nandptr += 4) {
			tmp = (addr[i+1]<<8)+addr[i];
			WRITE_NAND16(tmp, nandptr);
		}
	}
}
#if 0
static int NanD_Address(struct nand_chip *nand, int numbytes, unsigned long ofs)
{
	unsigned long nandptr;
	int i;

	nandptr = nand->IO_ADDR;

	/* Assert the ALE (Address Latch Enable) line to the flash chip */
	NAND_CTL_SETALE(nandptr);

	/* Send the address */
	/* Devices with 256-byte page are addressed as:
	 * Column (bits 0-7), Page (bits 8-15, 16-23, 24-31)
	 * there is no device on the market with page256
	 * and more than 24 bits.
	 * Devices with 512-byte page are addressed as:
	 * Column (bits 0-7), Page (bits 9-16, 17-24, 25-31)
	 * 25-31 is sent only if the chip support it.
	 * bit 8 changes the read command to be sent
	 * (NAND_CMD_READ0 or NAND_CMD_READ1).
	 */

	if (numbytes == ADDR_COLUMN || numbytes == ADDR_COLUMN_PAGE)
		WRITE_NAND_ADDRESS(ofs, nandptr);

	ofs = ofs >> nand->page_shift;

	if (numbytes == ADDR_PAGE || numbytes == ADDR_COLUMN_PAGE) {
		for (i = 0; i < nand->pageadrlen; i++, ofs = ofs >> 8) {
			WRITE_NAND_ADDRESS(ofs, nandptr);
		}
	}

	/* Lower the ALE line */
	NAND_CTL_CLRALE(nandptr);

	/* Wait for the chip to respond */
	return NanD_WaitReady(nand, 1);
}
#endif

int nfc_dma_cfg(unsigned int buf, unsigned int len, unsigned int wr)
{
	unsigned int status, CurDes_off = 0, i, dma_unit;

	//if (!len || buf & 0x03) {
	if (!len) {
		printf("Error : length = %x , address = %x\r\n", len, buf);
		return -1;
	}

	if (!ReadDesc) {
		printf("alloc ReadDesc failed\n");
		return -1;
	}
	pNFCRegs->NFCR8 = len-1;
	/*	Interrupt setting	*/
	/*disable_irq();
	set_irq_handlers(IRQ_NFC_DMA, nand_dma_isr);
	set_int_route(IRQ_NFC_DMA, 0);
	unmask_interrupt(IRQ_NFC_DMA);
	enable_irq();*/

	if (pNand_PDma_Reg->DMA_ISR & NAND_PDMA_IER_INT_STS)
		pNand_PDma_Reg->DMA_ISR = NAND_PDMA_IER_INT_STS;

	if (pNand_PDma_Reg->DMA_ISR & NAND_PDMA_IER_INT_STS) {
		printf("PDMA interrupt status can't be clear ");
		printf("pNand_PDma_Reg->DMA_ISR = 0x%8.8x \n", (unsigned int)pNand_PDma_Reg->DMA_ISR);
	}
	if ((pNFCRegs->NFCR23&BCH_ERR_MODE) >= ECC24bitPer1K)
		dma_unit = 1024;
	else
		dma_unit = 512;
	status = nand_init_pdma();
	if (status)
		printf("nand_init_pdma fail status = 0x%x", status);
	nand_alloc_desc_pool(ReadDesc);
	/*printf(" ReadDesc = 0x%x\r\n", (unsigned int ) ReadDesc);*/
	/*printf(" buf = 0x%x\r\n", (unsigned int ) buf);*/
	for (i = 0; i < (len/dma_unit); i++) {
		nand_init_short_desc(ReadDesc+CurDes_off, dma_unit, (unsigned long *)(buf+i*dma_unit),
		((i == ((len/dma_unit)-1)) && !(len%dma_unit)) ? 1 : 0);
		CurDes_off += sizeof(NAND_PDMA_DESC_S)/4;
	}
	if (len%dma_unit)
		nand_init_short_desc(ReadDesc+CurDes_off, (len%dma_unit),
		(unsigned long *)(buf+i*dma_unit), 1);	

	nand_config_pdma(ReadDesc, wr);
	return 0;
}

int nand_init_pdma(void)
{
	pNand_PDma_Reg->DMA_GCR = NAND_PDMA_GCR_SOFTRESET;
	pNand_PDma_Reg->DMA_GCR = NAND_PDMA_GCR_DMA_EN;
	if (pNand_PDma_Reg->DMA_GCR & NAND_PDMA_GCR_DMA_EN)
		return 0;
	else
		return 1;
}


int nand_free_pdma(void)
{
	pNand_PDma_Reg->DMA_DESPR	= 0;
	pNand_PDma_Reg->DMA_GCR = 0;
	return 0;
}


int nand_alloc_desc_pool(unsigned long *DescAddr)
{
	int i;
	for (i = 0; i < 40; i++)
		*(DescAddr+i) = 0;
	return 0;
}

int nand_init_short_desc(unsigned long *DescAddr, unsigned int ReqCount, unsigned long *BufferAddr, int End)
{
	struct _NAND_PDMA_DESC_S *CurDes_S;
	CurDes_S = (struct _NAND_PDMA_DESC_S *) DescAddr;
	CurDes_S->ReqCount = ReqCount;
	CurDes_S->i = End;
	CurDes_S->end = End;
	CurDes_S->format = 0;
	CurDes_S->DataBufferAddr = (unsigned long)BufferAddr;
	return 0;
}

int nand_init_long_desc(unsigned long *DescAddr, unsigned int ReqCount, unsigned long *BufferAddr,
unsigned long *BranchAddr, int End)
{
	struct _NAND_PDMA_DESC_L *CurDes_L;
	CurDes_L = (struct _NAND_PDMA_DESC_L *) DescAddr;
	CurDes_L->ReqCount = ReqCount;
	CurDes_L->i = 0;
	CurDes_L->format = 1;
	CurDes_L->DataBufferAddr = (unsigned long)BufferAddr;
	CurDes_L->BranchAddr = (unsigned long)BranchAddr;
	if (End) {
		CurDes_L->end = 1;
		CurDes_L->i = 1;
	}

	return 0;
}


int nand_config_pdma(unsigned long *DescAddr, unsigned int dir)
{
	/*pNand_PDma_Reg->DMA_IER = NAND_PDMA_IER_INT_EN;*/
	pNand_PDma_Reg->DMA_DESPR = (unsigned long)DescAddr;
	if (dir == NAND_PDMA_READ)
		pNand_PDma_Reg->DMA_CCR |= NAND_PDMA_CCR_peripheral_to_IF;
	else
		pNand_PDma_Reg->DMA_CCR &= ~NAND_PDMA_CCR_IF_to_peripheral;

	pNand_PDma_Reg->DMA_CCR |= NAND_PDMA_CCR_RUN;

	return 0;
}

int nand_pdma_handler(void)
{
	unsigned long status = 0;
	unsigned long count = 0;

	count = 0x100000;
	/*	 polling CSR TC status	*/
	do {
		count--;
		if (pNand_PDma_Reg->DMA_ISR & NAND_PDMA_IER_INT_STS) {
			status = pNand_PDma_Reg->DMA_CCR & NAND_PDMA_CCR_EvtCode;
			pNand_PDma_Reg->DMA_ISR &= NAND_PDMA_IER_INT_STS;
			break ;
		}
		if (count == 0) {
			printf("PDMA Time Out!\n");
			printf("pNand_PDma_Reg->DMA_CCR = 0x%8.8x\r\n",
			(unsigned int)pNand_PDma_Reg->DMA_CCR);

			break;
		}
	} while (1);
	if (status == NAND_PDMA_CCR_Evt_ff_underrun)
		printf("PDMA Buffer under run!\n");

	if (status == NAND_PDMA_CCR_Evt_ff_overrun)
		printf("PDMA Buffer over run!\n");

	if (status == NAND_PDMA_CCR_Evt_desp_read)
		printf("PDMA read Descriptor error!\n");

	if (status == NAND_PDMA_CCR_Evt_data_rw)
		printf("PDMA read/write memory descriptor error!\n");

	if (status == NAND_PDMA_CCR_Evt_early_end)
		printf("PDMA read early end!\n");

	if (count == 0) {
		printf("PDMA TimeOut!\n");
	//	while (1)
			;
	}

	return 0;
}

int hynix_read_retry_get_para(struct nand_chip *nand)
{
	int i, status = -1, index = 0, regc = 4;
	unsigned int cfg, para[4], IdList[4] = {0xADD794DA, 0xADD79491, 0xADDE94DA, 0x11111111};
	unsigned char *FIFO = (unsigned char *) &pNFCRegs->FIFO[48];
	unsigned char reg[4] = {4, 8, 8 , 8};
	unsigned char addr[6][8] = {{0xA7, 0xAD, 0xAE, 0xAF, 0x00, 0x00, 0x00, 0x00},
															{0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7},
															{0xA7, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3},
															{0xA7, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3},
															{0xA7, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3},
															{0xA7, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3}};
	for (i = 0; i < 4; i++)
		para[i] = 0;
	for (i = 0; i < 4; i++) {
		if (nand->id == IdList[i]) {
			index = i;
			regc = reg[i];
			break;
		}
	}

	status = NAND_WAIT_IDLE();
	if (status)
		return status;

	for (i = 0; i < regc;i++) {
		if (nfc_dma_cfg((unsigned int)&para[i], 1, 0))
			return -4;
		pNFCRegs->NFCRd |= HIGH64FIFO;
		//print_nfc_register();
		if (i == 0) {
			FIFO[0] = 0x37;
			FIFO[1] = addr[index][0];
			//printf("FIFO:");
			//for (k=0;k<2;k++)
				//printf("[%d]=0x%x ", k, FIFO[k]);
			//printf("\n");
			// set address latch ALE(high) and CLE(lower)	
			pNFCRegs->NFCRc = 0x00020001;
			cfg = (0x02<<1);
		} else {
			FIFO[0] = addr[index][i];
			// set address latch ALE(high) and CLE(lower)	
			pNFCRegs->NFCRc = 0x00010000;
			cfg = (0x01<<1);
		}
		pNFCRegs->NFCR1 = NAND2NFC|cfg|NFC_TRIGGER;	 /* cfg & start*/

		/* wait command/address to finished */
		status = NFC_WAIT_CMD_READY();
		if (status) {
			printf("retry c1 wait cmd/addr ready time out\n");
			return status;
		}
		
		status = NFC_WAIT_READY();
		if (status) {
			printf("retry wait NFC ready time out\n");
			return status;
		}
			
		status = nand_pdma_handler();
		nand_free_pdma();
		if (status)
			return status;
		
		printf("para[%d]=0x%x\n", i, para[i]);
	}
	status = NAND_WAIT_IDLE();
	if (status) {
		printf("retry wait idle time out\n");
		return status;
	}
	pNFCRegs->NFCRd &= ~HIGH64FIFO;

	//printf("retry start cmd end para = 0x%x %x %x %x\n", para[0], para[1], para[2], para[3]);	
	return 0;
}

int get_read_retry_para(struct nand_chip *nand)
{
	NAND_ENABLE_CE(nand, 0);
	if (nand->id == 0xADD794DA)
		hynix_read_retry_get_para(nand);
	/*else
		toshiba_read_retry_get_para(struct nand_chip *nand)*/
	NAND_DISABLE_CE(nand);
	return 0;
}

int hynix_read_retry_set_para(struct nand_chip *nand, int reg)
{
	int i, status = -1, index, regc = 4;
	unsigned int cfg, IdList[4] = {0xADD794DA, 0xADD79491, 0xADDE94DA, 0x11111111};
	unsigned char *FIFO = (unsigned char *) &pNFCRegs->FIFO[48];
	unsigned char reg_cnt[4] = {4, 8, 8 , 8};
	unsigned char addr[6][8] = {{0xA7, 0xAD, 0xAE, 0xAF, 0x00, 0x00, 0x00, 0x00},
															{0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7},
															{0xA7, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3},
															{0xA7, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3},
															{0xA7, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3},
															{0xA7, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3}};
	unsigned int cmd[7][4] = {{0x20, 0x20,  0x74,   0xC1},
																{0, 0x6,  0xA,   0x6},
														 		{0, 0x3,  0x7,   0x8},
														 		{0, 0x6,  0xD,   0xF},
														 		{0, 0x9, 0x14,  0x17},
														 		{0, 0x0, 0x1A,  0x1E},
														 		{0, 0x0, 0x20,  0x25}};

	for (i = 0; i < 4; i++) {
		if (nand->id == IdList[i]) {
			index = i;
			regc = reg_cnt[i];
			break;
		}
	}
	status = NAND_WAIT_IDLE();
	if (status)
		return status;

	for (i = 0; i < (regc+1);i++) {
		if (i < regc) {
		if (nfc_dma_cfg((unsigned int)&cmd[reg][i], 1, 1))
			return -4;
		}
		pNFCRegs->NFCRd |= HIGH64FIFO;
		if (i == 0) {
			FIFO[0] = 0x36;
			FIFO[1] = addr[0][0];
			//printf("FIFO:");
			//for (k=0;k<2;k++)
				//printf("[%d]=0x%x ", k, FIFO[k]);
			//printf("\n");
			// set address latch ALE(high) and CLE(lower)	
			pNFCRegs->NFCRc = 0x00020001;
			cfg = (0x02<<1);
			pNFCRegs->NFCR1 = cfg|NFC_TRIGGER;	 /* cfg & start*/
		} else if (i < regc) {
			FIFO[0] = addr[0][i];
			// set address latch ALE(high) and CLE(lower)	
			pNFCRegs->NFCRc = 0x00010000;
			cfg = (0x01<<1);
			pNFCRegs->NFCR1 = cfg|NFC_TRIGGER;	 /* cfg & start*/
		} else {
			FIFO[0] = 0x16;
			pNFCRegs->NFCRc = 0x00000001;
			cfg = (0x01<<1);
			pNFCRegs->NFCR1 = DPAHSE_DISABLE|cfg|NFC_TRIGGER;	 /* cfg & start*/
		}

		/* wait command/address to finished */
		status = NFC_WAIT_CMD_READY();
		if (status) {
			printf("retry c1 wait cmd/addr ready time out\n");
			return status;
		}
		
		status = NFC_WAIT_READY();
		if (status) {
			printf("retry wait NFC ready time out\n");
			pNFCRegs->NFCRd &= ~HIGH64FIFO;
			return status;
		}
		if (i < regc) {	
			status = nand_pdma_handler();
			nand_free_pdma();
			if (status) {
				pNFCRegs->NFCRd &= ~HIGH64FIFO;
				return status;
			}
		}
	}
	status = NAND_WAIT_IDLE();
	if (status) {
		pNFCRegs->NFCRd &= ~HIGH64FIFO;
		printf("retry c1 wait idle time out\n");
		return status;
	}
	pNFCRegs->NFCRd &= ~HIGH64FIFO;

	return 0;
}

int set_read_retry_para(struct nand_chip *nand, int reg)
{
	NAND_ENABLE_CE(nand, 0);
	if (nand->id == 0xADD794DA)
		hynix_read_retry_set_para(nand, reg);
	/*else
		toshiba_read_retry_get_para(struct nand_chip *nand)*/
	NAND_DISABLE_CE(nand);
	return 0;
}

int NFC_CHECK_ECC(void)
{
	int i = 0;

	while (1) {
		if (!(pNFCRegs->NFCRa & NFC_BUSY))
			break;
		if (pNFCRegs->NFCR25 == (ERR_CORRECT | BCH_ERR))
			return 1;
		if (i>>21)
			return -3;
		i++;
	}
	if (pNFCRegs->NFCR25&BCH_ERR) {
		while(1) {
			if (pNFCRegs->NFCR25&ERR_CORRECT)
				return 1;
		}
	}
	return 0;
}

void nfc_BCH_ecc_correct(struct nand_chip *nand, unsigned int bitcnt, unsigned int maddr)
{
	unsigned int ofs, i = 0, type, bank;
	unsigned int posptr, dma_unit;
	unsigned short err_ofs;
	unsigned int byte_ofs, bit_ofs;
	unsigned char err_data;
	unsigned int ofs1 = 0;
	struct ECC_size_info ECC_size;

	ECC_size.ecc_engine = pNFCRegs->NFCR23&ECC_MOD_SEL;
	calculate_ECC_info(nand, &ECC_size);
	dma_unit = nand->oobblock/ECC_size.banks;

#ifdef SHOWME_ECC
	printf("error happen at 0x%x", maddr);
#endif
	posptr = g_WMTNFCBASE + 0x9C;
	type = pNFCRegs->NFCR23 & BANK_DR;
	bank = (pNFCRegs->NFCR26 & BANK_NUM)>>8;
	if (type) {
		#ifdef SHOWME_ECC
		printf("bank%d red area\n",bank);
		#endif
		ofs = g_WMTNFCBASE + 0x1C0;
	} else {
		#ifdef SHOWME_ECC
		printf("bank%d data area \n",bank);
		#endif
		ofs1 = (bank*dma_unit);
		ofs = maddr + (bank*dma_unit);
	}

	for (i = 0; i < bitcnt; i++, posptr+=2) {
		READ_NAND16(err_ofs, posptr);
		byte_ofs = (unsigned int)(err_ofs>>3);
		bit_ofs = (unsigned int)(err_ofs & 0x07);
#ifdef POST_TEST_FUNS
	if(type) {
		g_ecc_result.pred[g_ecc_rcnt] = (byte_ofs*8)+bit_ofs;
		g_ecc_rcnt++;
		if (g_ecc_rcnt >= MAX_ECC_BIT)
			g_ecc_rcnt = 0;
	} else {
		g_ecc_result.pos[g_ecc_dcnt] = ((ofs1+byte_ofs)*8)+bit_ofs;
		g_ecc_dcnt++;
		if (g_ecc_dcnt >= MAX_ECC_BIT)
			g_ecc_dcnt = 0;
	}
#endif
		#ifdef SHOWME_ECC
		printf(" byte%d, bit%d ",byte_ofs,bit_ofs);
		#endif
		if (byte_ofs >= ((bank < (ECC_size.banks-1))?dma_unit:(dma_unit+24))) {
			#ifdef SHOWME_ECC
			printf("\n");
			#endif
			continue;
		}

		if (byte_ofs >= dma_unit) {
			ofs = g_WMTNFCBASE + 0x1C0;
			READ_NAND8(err_data, (ofs+byte_ofs-dma_unit));
		} else
			READ_NAND8(err_data, (ofs+byte_ofs));
		#ifdef SHOWME_ECC
		printf("org (0x%x) 0x%x => ",(ofs+byte_ofs),err_data);
		#endif
    	if (err_data & (1<<bit_ofs))
    		err_data &= ~(1<<bit_ofs);
    	else
    		err_data |= (1<<bit_ofs);
		#ifdef SHOWME_ECC
		printf("0x%x\n",err_data);
		#endif
		if (byte_ofs >= dma_unit)
			WRITE_NAND8(err_data, (ofs+byte_ofs-dma_unit));
		else
			WRITE_NAND8(err_data, (ofs+byte_ofs));
	}
}

int nfc_BCH_ecc_check(struct nand_chip *nand, unsigned int maddr)
{
	unsigned int cnt = 0, count = 0x100;
	int rc = 0;

	if (pNFCRegs->NFCR25 == (ERR_CORRECT|BCH_ERR)) {
		cnt = pNFCRegs->NFCR26 & BCH_ERR_CNT;
		if (cnt == BCH_ERR_CNT) {
			printf("Too Many Error\n");
			rc = -ERR_ECC_UNCORRECT;
		} else {
			if (!cnt) {
				printf("report ecc error : count =%d\n", cnt);
				pNFCRegs->NFCR23 |= READ_RESUME;
				rc = -ERR_UNKNOW;
			}
		}
		if (rc) {
			pNFCRegs->NFCR25 = (ERR_CORRECT|BCH_ERR);
			pNFCRegs->NFCR23 |= READ_RESUME;
			return rc;
		}

		while ((0 != (pNand_PDma_Reg->DMA_RBR%0x200)) && (count--))
			printf("dma is not finish please wait");

		nfc_BCH_ecc_correct(nand, cnt, maddr);
	}
	pNFCRegs->NFCR25 = (ERR_CORRECT|BCH_ERR);
	pNFCRegs->NFCR23 |= READ_RESUME;

	return 0;
}

int nfc_BCH_read_page(
struct nand_chip *nand,
unsigned int page,
unsigned int maddr,
unsigned int len)
{
	unsigned int row = 0, col = 0, dma_unit = 512, rdmz_mark = 0;
	int rc = -1, err = 0, i;
	int total_times = 1;
	int retry_pass = 0;
	int retry = 0;
	unsigned char cmd[1] = {0xff};

	if (nand->oobblock >= 8192)
		dma_unit = 1024;

	if(NULL != cur_chip) {
		total_times = cur_chip->total_try_times + 1;
	}


	for(i = 0; i < total_times; i++) {
		row = page;
		col = 0;
		if (nfc_dma_cfg(maddr, len, 0))
			return -ERR_DMA_CFG;

		/* addr */
		NanD_Address(nand, ADDR_COLUMN_PAGE, col, row);
		WRITE_NAND_COMMAND(NAND_READ0); /* set command cycle 1 */

		/*print_nfc_register();*/

		pNFCRegs->NFCRb |= B2R; /* write to clear */
		pNFCRegs->NFCR1 = DPAHSE_DISABLE|((nand->row+nand->col+1)<<1)|NFC_TRIGGER|0x400;
		if (nand->oobblock > 512) {
			if (NFC_WAIT_CMD_READY())
				return -ERR_NFC_CMD;
			WRITE_NAND_COMMAND(NAND_READ_CONFIRM);
			pNFCRegs->NFCRb |= B2R; /* write to clear */
			pNFCRegs->NFCR1 = NAND2NFC|1<<1|NFC_TRIGGER|0x400;
		}

		if (pNFCRegs->NFCR15 & USE_SW_ECC) {
			if (NFC_WAIT_READY())
				return -ERR_NFC_READY;
		} else {
			row = (nand->oobblock/dma_unit)+1;
			for (col = 0; col < row; col++) {
				rc = NFC_CHECK_ECC();
				if (rc < 0)
					return -ERR_NFC_READY;
				else {
					if (rc) {
						err = nfc_BCH_ecc_check(nand, maddr);
						if(err) {
							printf("The %d bank need retry.\n", col);
							retry = 1;
						}
					}
				}
			}
		}
		rc = nand_pdma_handler();
		nand_free_pdma();

		if (NAND_WAIT_READY())
			return -ERR_NAND_IDLE;

		if(cur_chip != NULL) {
//			printf("p4 retry = %d\n", retry);
			if(retry == 1) {
				printf("Ecc Err %d_th, on page %d  cur_try_times:%d fail.\n", i, page, cur_chip->cur_try_times);
				if(cur_chip->read_table == 1) {
					break;
				}
				if(i == (total_times - 1)) {
					if(nand->mfr == 0x98) {
						write_bytes_param(1, 0, 0, cmd, NULL, NULL);
						cur_chip->cur_try_times = 0;
					}
					printf("@@@@@@@@@@@@@@@@@@@@@@@@@@@ retry FAIL. %d\n", cur_chip->cur_try_times);
					retry = -1;
					break;
				}
				if(nand->mfr == 0xad) {
					cur_chip->set_parameter(nand, READ_RETRY_MODE, ECC_ERROR_VALUE);
					retry_pass = 1;
				} else if(nand->mfr == 0x98) {
					if(cur_chip->cur_try_times == 0)
						toshiba_pre_condition();
					cur_chip->set_parameter(nand, 0, 0);
					retry_pass = 1;
				}
				retry = 0;
				continue;
			} else {
				if(cur_chip->read_table == 1) {
					break;
				}

				if((nand->mfr == 0x98) && (retry_pass == 1)) {
					write_bytes_param(1, 0, 0, cmd, NULL, NULL);
					cur_chip->cur_try_times = 0;
					retry = 0;
				}
				if(retry_pass == 1)
					printf("########################### retry PASS.cur_try_times:%d\n", cur_chip->cur_try_times);
				break;
			}
		}
	}

	if (!(pNFCRegs->NFCR23 & BCH_ECC_DIS)) {
		//printf("hw r page=0x%x ", page);
		rdmzier_oob((uint8_t *)&rdmz_mark, (uint8_t *)&pNFCRegs->FIFO[20], 1, page, (nand->oobblock+20)/4);
		if (nand->dwRdmz == 1) {
			if (rdmz_mark == *(unsigned int *)wmt_rdmz || *(unsigned int *)&pNFCRegs->FIFO[20] == *(unsigned int *)wmt_rdmz) {
				//printf("1with rdmz mark fifo5=0x%x\n", *(unsigned int *)&pNFCRegs->FIFO[20]);
				rdmzier((uint8_t *)maddr, nand->oobblock/4, page);
			}
			if (rdmz_mark == *(unsigned int *)wmt_rdmz) {
				rdmzier_oob((uint8_t *)pNFCRegs->FIFO, (uint8_t *)pNFCRegs->FIFO, 6, page, nand->oobblock/4);
				//printf("2with rdmz mark fifo5=0x%x\n", *(unsigned int *)&pNFCRegs->FIFO[20]);
			}
		} /*else
			printf(" dwRdmz=0x%x\n", nand->dwRdmz);*/
	} /*else
		printf("sw r nordmz page=0x%x\n", page);*/

	if(retry)
		return -1;
	return 0;
}

int nand_read_status(unsigned char cmd)
{
	int cfg = 0, status = -1;

	pNFCRegs->NFCR2 = cmd;
	cfg = DPAHSE_DISABLE|NFC2NAND|(1<<1);
	pNFCRegs->NFCRb |= B2R; /* write to clear */
	pNFCRegs->NFCR1 = cfg|NFC_TRIGGER|0x400;
	if (NFC_WAIT_READY()) {
		return -ERR_NFC_READY;
	}
	pNFCRegs->NFCRb |= B2R; /* write to clear */
	cfg = SING_RW|NAND2NFC;
	pNFCRegs->NFCR1 = cfg | NFC_TRIGGER|0x400;
	if (NFC_WAIT_READY()) {
		return -ERR_NFC_READY;
	}
	if (NAND_WAIT_IDLE()) {
		return -ERR_NAND_IDLE;
	}
	status = pNFCRegs->NFCR0 & 0xff;

	return status;
}

int tellme_badblock(struct nand_chip *nand)
{
	unsigned int block, count = 0, chip;
	NAND_ENABLE_CE(nand, 0);
	if (check_block_table(nand, 0)) {
		NAND_DISABLE_CE(nand);
		return -1;
	}
	if (nand->isbadblock == isbbtbadblock)
		printf("Using BBT to search bad blocks\n");
	else {
		printf("Unknow Table tpye\n");
		NAND_DISABLE_CE(nand);
		return -1;
	}
	for (chip = 0; chip < nand->numchips; chip++) {
		for (block = 0; block < nand->dwBlockCount; block++) {
			if (nand->isbadblock(nand, block, chip)) {
				printf("block%d is bad\n", block);
				count++;
			}
		}
		printf("chip%d Total %d Bad Block\n", chip, count);
	}
	NAND_DISABLE_CE(nand);
	return 0;
}

int tellme_whereistable(struct nand_chip *nand)
{
	unsigned int i, cnt = 0, chip;

	NAND_ENABLE_CE(nand, 0);
	if (check_block_table(nand, 0)) {
		NAND_DISABLE_CE(nand);
		return -1;
	}
	for (chip = 0; chip < nand->numchips; chip++) {
		for (i = 0; i < 6; i++) {
			if (bad_block_pos[chip][i]) {
				cnt++;
				if ((bad_block_pos[chip][i] & 0xffff) == 1)
					printf("Find Major BBT Table ");
				else
					printf("Find Minor BBT Table ");
				printf("at block%d\n", (bad_block_pos[chip][i]>>16)&0xffff);
			}
		}
		printf("Chip%d Total %d Tables\n", chip, cnt);
	}
	NAND_DISABLE_CE(nand);
	return 0;
}

int tellme_nandinfo(struct nand_chip *nand)
{
	int rc = -1;

	if (g_WMTNFCBASE != __NFC_BASE) {
		rc = nand_probe(__NFC_BASE);
		if (!rc) {
			printf("Init Flash Failed rc=%d\r\n", rc);
			return rc;
		}
	}
	printf("NAND information : ");
	switch (nand->mfr) {
	case NAND_HYNIX:
	case NAND_HYNIX_new:
		printf("current CHIP structure addr 0x%x NAND_HYNIX\n", (int)nand);
		break;
	case NAND_SAMSUNG:
		printf("current CHIP structure addr 0x%x NAND_SAMSUNG\n", (int)nand);
		break;
	case NAND_TOSHIBA:
		printf("current CHIP structure addr 0x%x NAND_TOSHIBA\n", (int)nand);
		break;
	default:
		printf(" UNKNOW ( id = %x )\n", nand->mfr);
		return -1;
	}
	printf("page size = %d , Spare size = %d, %d pages per block\n",
	nand->oobblock, nand->oobsize, nand->dwPageCount);
	printf("column cycle = %d, row cycle = %d\n", nand->col, nand->row);
	printf("Erase size = 0x%x, Total Blocks = %d\n", nand->erasesize, nand->dwBlockCount);
	printf("page_shift = %d, chips_name = %s\n", nand->page_shift, nand->chips_name);
	printf("bus16 = %d, IO_ADDR = 0x%x\n", nand->bus16, nand->IO_ADDR);
	printf("numchips = %d\n", nand->numchips);
  return 0;
}

int nand_read_page(struct nand_chip *nand, unsigned int start, unsigned int maddr, unsigned int len)
{
	unsigned int page = 0, col = 0;
	int rc = -1;

	/* First we calculate the starting page */
	page = start >> nand->page_shift;
	/* Get raw starting column */
	col = start & (nand->oobblock - 1);

	if (pNFCRegs->NFCR9&2) {
		col = nand->oobblock;
		printf("1 bit ecc col=0x%x, row = 0x%x\r\n", col, page);
	} else {
		if (nfc_dma_cfg(maddr, len, 0))
			return -ERR_DMA_CFG;
	}
	/* addr */
	NanD_Address(nand, ADDR_COLUMN_PAGE, col, page);
	/* set command 1 cycle */
	WRITE_NAND_COMMAND(NAND_READ0);
	pNFCRegs->NFCRb |= B2R; /* write to clear */
	if (nand->oobblock > 512)
		pNFCRegs->NFCR1 = DPAHSE_DISABLE|((nand->row+nand->col+1)<<1)|NFC_TRIGGER|0x400;
	else
		pNFCRegs->NFCR1 = NAND2NFC|((nand->row+nand->col+1)<<1)|NFC_TRIGGER|0x400;
	if (nand->oobblock > 512) {
		if (NFC_WAIT_CMD_READY())
			return -ERR_NFC_CMD;
		WRITE_NAND_COMMAND(NAND_READ_CONFIRM);
		pNFCRegs->NFCRb |= B2R; /* write to clear */
		pNFCRegs->NFCR1 = NAND2NFC|1<<1|NFC_TRIGGER|0x400;
	}
	if (NFC_WAIT_READY())
			return -ERR_NFC_READY;

	if (!(pNFCRegs->NFCR9&2)) {
		rc = nand_pdma_handler();
		nand_free_pdma();
		if (rc)
			return -rc;
	}

	if (NAND_WAIT_READY())
		return -ERR_NAND_IDLE;

	if (pNFCRegs->NFCR9&2)
		memcpy((unsigned char *)maddr, (unsigned char *)&pNFCRegs->FIFO[0], 64);

	return 0;
}

int wmt_nand_erase(struct nand_chip *nand, unsigned int block)
{
	unsigned int row, col = 0;

	/* First we calculate the starting page */
	row = block * nand->dwPageCount;
	/* addr */
	NanD_Address(nand, ADDR_PAGE, col, row);

	WRITE_NAND_COMMAND(NAND_ERASE_SET);
	/*  trigger */
	pNFCRegs->NFCR1 = DPAHSE_DISABLE|((nand->row+1)<<1)|NFC_TRIGGER|0x400;

	//print_nfc_register();

	if (NFC_WAIT_CMD_READY())/* kevin:wait cmd ready excluding data phase  */
		return -ERR_NFC_CMD;
	if (NAND_WAIT_IDLE())
		return -ERR_NAND_IDLE;
	WRITE_NAND_COMMAND(NAND_ERASE_CONFIRM);
	pNFCRegs->NFCRb |= B2R; /* write to clear */
	pNFCRegs->NFCR1 = DPAHSE_DISABLE|(1<<1)|NFC_TRIGGER|0x400;
	if (NAND_WAIT_READY())
		return -ERR_NAND_READY;
	if (NAND_WAIT_IDLE())
		return -ERR_NAND_IDLE;
	/* status */
	return nand_read_status(NAND_STATUS);
}

int nand_page_program(struct nand_chip *nand, unsigned int page, unsigned int maddr, unsigned int len)
{
	unsigned int row = 0, col = 0;

	row = page;

	if (nfc_dma_cfg(maddr, len, 1)) {
		return -ERR_DMA_CFG;
	}

	/* reset nand	 */
	WRITE_NAND_COMMAND(NAND_READ0);
	pNFCRegs->NFCR1 = DPAHSE_DISABLE|(1<<1)|NFC_TRIGGER|0x400;
	if (NFC_WAIT_READY()) {
		return -ERR_NFC_READY;
	}

	NanD_Address(nand, ADDR_COLUMN_PAGE, col, row);
	WRITE_NAND_COMMAND(NAND_SEQIN);
	/*  trigger */
	pNFCRegs->NFCR1 = ((nand->row+nand->col+1)<<1)|NFC_TRIGGER|0x400;/* command 1 cycle  */
	if (NFC_WAIT_READY())/* wait command &data completed */ {
		return -ERR_NFC_READY;
	}
	/* while (!(pNFCRegs->NFCR1d&NFC_IDLE));  */
	if (NAND_WAIT_IDLE()) {
		return -ERR_NAND_IDLE;
	}
	WRITE_NAND_COMMAND(NAND_PAGEPROG);
	pNFCRegs->NFCRb |= B2R; /* write to clear */
	pNFCRegs->NFCR1 = DPAHSE_DISABLE|(1<<1)|NFC_TRIGGER|0x400;/* command 2 cycle */
	if (NAND_WAIT_READY()) {
		return -ERR_NAND_READY;
	}
	if (NAND_WAIT_IDLE()) {
		return -ERR_NAND_IDLE;
	}

	/* status */
	return nand_read_status(NAND_STATUS);
}
#if 0
int nand_page_program_random(struct nand_chip *nand, unsigned int start, unsigned int maddr, unsigned int len)
{
	unsigned int row = 0, col = 0, start2;
	int status = -ERR_DMA_CFG;

	/* First we calculate the starting page */
	row = start >> nand->page_shift;
	col = start & (nand->oobblock - 1);
	start2 = start + 4096 + 218;

	if (nfc_dma_cfg(maddr, len/2, 1))
		return -ERR_DMA_CFG;

	/* reset nand	 */
	WRITE_NAND_COMMAND(NAND_READ0);
	pNFCRegs->NFCR1 = DPAHSE_DISABLE|(1<<1)|NFC_TRIGGER|0x400;
	if (NFC_WAIT_READY())
		return -ERR_NFC_READY;

	NanD_Address(nand, ADDR_COLUMN_PAGE, col, row);
	WRITE_NAND_COMMAND(NAND_SEQIN);
	/*  trigger */
	pNFCRegs->NFCR1 = ((nand->row+nand->col+1)<<1)|NFC_TRIGGER|0x400;/* command 1 cycle  */
	if (NFC_WAIT_READY())/* wait command &data completed */
		return -ERR_NFC_READY;
	/* while (!(pNFCRegs->NFCR1d&NFC_IDLE));  */
	if (NAND_WAIT_IDLE())
		return -ERR_NAND_IDLE;
	status = nand_pdma_handler();
	if (status)
		printf("err : pdma status=%d \n", status);//return status;
	nand_free_pdma();
	
	if (nfc_dma_cfg(maddr + (len/2), len/2, 1))
		return -ERR_DMA_CFG;
/*printf("phase 2 maddr = 0x%x, len/2=0x%x \n", maddr, len/2);*/
	row = start2 >> nand->page_shift;
	col = start2 & (nand->oobblock - 1);
/*printf("phase 3 row = 0x%x, col=0x%x \n", row, col);*/
	NanD_Address(nand, ADDR_COLUMN_PAGE, col, row);
	WRITE_NAND_COMMAND(NAND_CMD_RANDOM_DATA_IN);
	pNFCRegs->NFCR1 = ((nand->col+1)<<1)|NFC_TRIGGER|0x400;/* command 2 cycle */
	if (NFC_WAIT_READY())/* wait command &data completed */
		return -ERR_NFC_READY;
	if (NAND_WAIT_IDLE())
		return -ERR_NAND_IDLE;

	WRITE_NAND_COMMAND(NAND_PAGEPROG);
	pNFCRegs->NFCRb |= B2R; /* write to clear */
	pNFCRegs->NFCR1 = DPAHSE_DISABLE|(1<<1)|NFC_TRIGGER|0x400;/* command 2 cycle */
	if (NAND_WAIT_READY())
		return -ERR_NAND_READY;
	if (NAND_WAIT_IDLE())
		return -ERR_NAND_IDLE;

	/* status */
	return nand_read_status(NAND_STATUS);
}
#endif

int WMTEraseNANDALL(struct nand_chip *nand, unsigned int all)
{
	unsigned int i, block = 0, start, blk_cnt;
	int rc = -1;

	if (g_WMTNFCBASE != __NFC_BASE) {
		rc = nand_probe(__NFC_BASE);
		if (!rc) {
			printf("Init Flash Failed rc=%d\r\n", rc);
			return -1;
		}
	}
	blk_cnt = nand->dwBlockCount;
	for (i = 0; i < nand->numchips; i++) {
		NAND_ENABLE_CE(nand, i);
		if (all == 1) //force erase
			start = 0;
		else if (all == 2) { //erase retry
			start = nand->dwBlockCount - BBT_MAX_BLOCK - 4;
			blk_cnt -= 4;
		} else //erase bbt
			start = nand->dwBlockCount - BBT_MAX_BLOCK;
		for (block = start; block < blk_cnt; block++)
			rc = wmt_nand_erase(nand, block);
	}
	bbt = NULL;
	NAND_DISABLE_CE(nand);

	return 0;
}


int WMTEraseNAND(struct nand_chip *nand, unsigned int block, unsigned int block_nums, unsigned int all)
{
	unsigned int i, cnt1 = 0, cnt = 0;
	int rc = -1;
	unsigned int chip = 0, need[CFG_MAX_NAND_DEVICE];
	unsigned int blk_start[CFG_MAX_NAND_DEVICE], blk_nobbt_inchip, blk_in_chip;
	unsigned int blk_len[CFG_MAX_NAND_DEVICE], len_in_blk = block_nums;
	
	if ((block + block_nums) > (nand->numchips*nand->dwBlockCount)) {
		printf(" erase block length is out of flash size");
		return -1;
	}

	if (check_block_table(nand, 0)) {
		NAND_DISABLE_CE(nand);
		return -1;
	}

	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++)
		blk_len[i] = blk_start[i] = need[i] = 0;

	if(cur_chip != NULL && nand->mfr == 0xad)
		blk_nobbt_inchip = nand->dwBlockCount - BBT_MAX_BLOCK - RETRY_MAX_BLOCK;
	else
		blk_nobbt_inchip = nand->dwBlockCount - BBT_MAX_BLOCK;

	while ((len_in_blk && chip < nand->numchips) && !all) {
	//printf("len_in_blk= 0x%x", len_in_blk);
		chip = block/nand->dwBlockCount;
		blk_in_chip = block%nand->dwBlockCount;
		blk_start[chip] = blk_in_chip;
		if ((len_in_blk + blk_in_chip) > nand->dwBlockCount) {
			len_in_blk -= (nand->dwBlockCount - blk_in_chip);
			block += (nand->dwBlockCount - blk_in_chip);
			blk_len[chip] = (blk_nobbt_inchip > blk_in_chip)
			? (blk_nobbt_inchip - blk_in_chip) : 0;
		} else {
			blk_len[chip] =
			((len_in_blk + blk_in_chip) >= blk_nobbt_inchip)
			? ((blk_nobbt_inchip > blk_in_chip) ? (blk_nobbt_inchip - blk_in_chip) : 0)
			: len_in_blk;
			block += len_in_blk;
			len_in_blk = 0;
			break;
		}
		chip++;
	}

	if (all)
		for (chip = 0; chip < nand->numchips; chip++) {
			blk_start[chip] = 0;
			blk_len[chip] = blk_nobbt_inchip;
		}

	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++)
		if (blk_len[i])
			printf("Erase start at chip%d block %d len=%d\n", i, blk_start[i], blk_len[i]);

	for (chip = 0; chip < nand->numchips; chip++) {
		for (i = blk_start[chip]; i < blk_start[chip] + blk_len[chip]; i++) {
			NAND_ENABLE_CE(nand, chip);
			if (!nand->isbadblock(nand, i, chip)) {
				/*printf("Erase start at chip%d block %d \n", chip, i);*/
				rc = wmt_nand_erase(nand, i);
				if (rc < 0 || rc & 0x01) {
					cnt1++;
					nand->update_table_inram(nand, i, chip);
					printf("erase fail uddate table chip%d block%d\n", chip, i);
					need[chip] = 1;
				} else
					cnt++;
			}
		}
	}
	for (chip = 0; chip < nand->numchips; chip++) {
		if (need[chip]) {
			printf("update bbt to nand chip%d..... \n", chip);
			rc = nand->update_table_inflash(nand, 0, chip);
			if (rc) {
				printf("failed\n");
				NAND_DISABLE_CE(nand);
				return rc;
			}
			printf("success\n");
		}
	}
	printf("Erase success %d failed %d\n", cnt, cnt1);
	NAND_DISABLE_CE(nand);
	return 0;
}

int eslc_nand_write_block(struct nand_chip *nand, unsigned int start, unsigned int page, unsigned int page_count, unsigned char *oob)
{
	unsigned int i = 0;
	unsigned int addr = start;
	int rc = -1;

	printf("start = %x page = %d, page_count = %d\n", start, page, page_count);
	if (oob) {
		if (nand->oobsize == 128) {
			pNFCRegs->NFCRd |= 0x08;
			for (i = 0; i < 64; i++)
				pNFCRegs->FIFO[i] = oob[64+i];
			pNFCRegs->NFCRd &= 0x07;
			for (i = 0; i < 64; i++)
				pNFCRegs->FIFO[i] = oob[i];
		} else if (nand->oobsize > 64) {
			for (i = 0; i < 64; i++)
				pNFCRegs->FIFO[i] = oob[i];
		} else {
			for (i = 0; i < nand->oobsize; i++)
				pNFCRegs->FIFO[i] = oob[i];
		}
	} else {
		for (i = 0; i < 64; i++)
			pNFCRegs->FIFO[i] = 0xff;
	}

	/* printf("need %d pages\r\n",size); 	 */
	for (i = 0; i < page_count; i++) {
#ifdef CONFIG_WMT_RANDOMIZER
		if(nand->dwRdmz) {
			memcpy((void*)rdmz_buf, (void*)addr, nand->oobblock);
			*(unsigned int *)&pNFCRegs->FIFO[20] = *(unsigned int *)wmt_rdmz;
			rdmzier(rdmz_buf, nand->oobblock/4, page+eslc_map_table[i]);
			rdmzier_oob((uint8_t *)pNFCRegs->FIFO, (uint8_t *)pNFCRegs->FIFO, 6, page + eslc_map_table[i], nand->oobblock/4);
			//printf("write page: %d\n", page + eslc_map_table[i]);
			rc = nand_page_program(nand, page+ eslc_map_table[i], (unsigned int)rdmz_buf, nand->oobblock);
		} else
#endif
			rc = nand_page_program(nand, page+eslc_map_table[i], addr, nand->oobblock);

		if (rc < 0 || rc & 0x01)
			return rc;
		addr = addr + nand->oobblock;
	}

	return 0;
}

int nand_write_block(
struct nand_chip *nand,
unsigned int start,
unsigned int page,
unsigned int page_count,
unsigned char *oob)
{
	unsigned int i = 0;
	unsigned int addr = start;
	int rc = -1;

	if (oob) {
		if (nand->oobsize == 128) {
			pNFCRegs->NFCRd |= 0x08;
			for (i = 0; i < 64; i++)
				pNFCRegs->FIFO[i] = oob[64+i];
			pNFCRegs->NFCRd &= 0x07;
			for (i = 0; i < 64; i++)
				pNFCRegs->FIFO[i] = oob[i];
		} else if (nand->oobsize > 64) {
			for (i = 0; i < 64; i++)
				pNFCRegs->FIFO[i] = oob[i];
		} else {
			for (i = 0; i < nand->oobsize; i++)
				pNFCRegs->FIFO[i] = oob[i];
		}
	} else {
		for (i = 0; i < 64; i++)
			pNFCRegs->FIFO[i] = 0xff;
	}

	/* printf("need %d pages\r\n",size); */
	for (i = 0; i < page_count; i++) {
#ifdef CONFIG_WMT_RANDOMIZER
		if (nand->dwRdmz == 1) {
			memcpy(rdmz_buf, (unsigned char *)addr, nand->oobblock);
			rdmzier((uint8_t *)rdmz_buf, nand->oobblock/4, page+i);
			*(unsigned int *)&pNFCRegs->FIFO[20] = *(unsigned int *)wmt_rdmz;
			rdmzier_oob((uint8_t *)pNFCRegs->FIFO, (uint8_t *)pNFCRegs->FIFO, 6, page+i, nand->oobblock/4);
			//printf("wr rdmz page=0x%x\n", page+i);
			rc = nand_page_program(nand, page+i, (unsigned int)rdmz_buf, nand->oobblock);
		} else
#endif
			rc = nand_page_program(nand, page+i, addr, nand->oobblock);
		if (rc < 0 || rc & 0x01)
			return rc;
		/* printf("write to %x page%d\n",naddr,(naddr>>nand->page_shift)&0x3f); */
		addr = addr + nand->oobblock;
	}

	return 0;
}
// Just read the half of one block for Hynix ESLC mode
int eslc_nand_read_block(struct nand_chip *nand, unsigned int maddr, unsigned int page, unsigned int page_count)
{
	unsigned int i = 0;
	unsigned int addr = maddr;
	int rc = -1;

	printf("hynix read: page_count = %d, start page = %d\n", page_count, page);
	for (i = 0; i < page_count; i++) {
		rc = nand->nfc_read_page(nand, page + eslc_map_table[i], addr, nand->oobblock);
		if (rc) {
			printf("Err1 at page 0x%x\n", page+eslc_map_table[i]);
			return rc;
		}
		addr = addr + nand->oobblock;
	}

	return 0;
}

int nand_read_block(struct nand_chip *nand, unsigned int maddr, unsigned int page, unsigned int page_count)
{
	unsigned int i = 0;
	unsigned int addr = maddr;
	int rc = -1;

	for (i = 0; i < page_count; i++) {
		rc = nand->nfc_read_page(nand, page+i, addr, nand->oobblock);
		if (rc) {
			printf("Read Err at page 0x%d\n", page+i);
			return rc;
		}
		addr = addr + nand->oobblock;
	}
	return 0;
}

// Just use the half of one block to save the data for Hynix ESLC mode
int eslc_save_image(struct nand_chip *nand, unsigned long long naddr, unsigned int dwImageStart, unsigned int dwImageLength)
{
	unsigned int maddr = dwImageStart;
	unsigned int ret = dwImageLength;
	unsigned int need[CFG_MAX_NAND_DEVICE], i;
	unsigned long page, chip, page_in_chip,
	len_in_page, page_count, left_page_in_blk, block_in_chip;
	unsigned char fifo[64];
	int rc = -1;

	if (naddr >= nand->totlen || (naddr + ret) >= nand->totlen) {
		printf("naddr=0x%llx is out of size\r\n", naddr);
		return -2;
	}

	if (check_block_table(nand, 1)) {
		NAND_DISABLE_CE(nand);
		return -1;
	}

	page = (unsigned long)(naddr>>nand->page_shift);

	if((page % nand->dwPageCount)) {
		printf("Error: wrong parameter, Just support 0 page start.\n");
		return -1;
	}

	len_in_page = ret/nand->oobblock + ((ret%nand->oobblock) ? 1 : 0);

	set_ECC_mode(nand);

	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++)
		need[i] = 0;

	while (1) {
		chip = page / (nand->dwBlockCount * nand->dwPageCount);
		page_in_chip = page % (nand->dwBlockCount * nand->dwPageCount);
		block_in_chip = page_in_chip/(nand->dwPageCount);

		if (chip >= nand->numchips) {
			printf("no space for write chip%d, left pages=%d\n", chip, len_in_page);
			break;
		}

		if (nand->isbadblock(nand, page_in_chip/nand->dwPageCount, chip)) {
			page = page + nand->dwPageCount - (page%nand->dwPageCount);
			continue;
		}
		NAND_ENABLE_CE(nand, chip);
		cur_chip->set_parameter(nand, ESLC_MODE, ECC_ERROR_VALUE);
//		cur_chip->get_parameter(nand, ESLC_MODE); 

		rc = wmt_nand_erase(nand, block_in_chip);
		if (rc < 0 || rc & 0x01) {
			printf("Erase failed at chip%d block%d\n", block_in_chip);
			nand->update_table_inram(nand, block_in_chip, chip);
			page = page + nand->dwPageCount - (page%nand->dwPageCount);
			need[chip] = 1;
			continue;
		}

		left_page_in_blk = nand->dwPageCount/2 - page_in_chip%(nand->dwPageCount/2);
  	    if (len_in_page >= (nand->dwPageCount/2))
			page_count = (page%(nand->dwPageCount/2)) ? left_page_in_blk : nand->dwPageCount/2;
  	    else
  		    page_count = (len_in_page < left_page_in_blk) ? len_in_page : left_page_in_blk;

		printf("left_page_in_blk:%d, len_in_page = %d, page_count = %d, chip:%d, page_in_chip:%d, block_chip:%d\n", left_page_in_blk, len_in_page, page_count, chip, page_in_chip, block_in_chip);
		memset(fifo, 0xff, 64);
		rc = eslc_nand_write_block(nand, maddr, page_in_chip, page_count, fifo);
		if (rc) {
			printf("Write block failed at chip%d page%d\n", chip, page_in_chip);
			nand->update_table_inram(nand, block_in_chip, chip);
			page = page + page_count;
			need[chip] = 1;
			continue;
		}

		printf("write data from memory 0x%x to chip%d, page=0x%x, page count=0x%x\n\n",
		maddr, chip, page_in_chip, page_count);
		
		maddr = maddr + page_count * nand->oobblock;
		if(page_count == (nand->dwPageCount/2))
			page = page + nand->dwPageCount;
		else
			page = page + page_count;
		len_in_page -= page_count;

		if (!len_in_page) {
			printf("\r\n write NAND Flash OK\r\n");
			break;
		}
	}
	for (i = 0; i < nand->numchips; i++) {
		if (need[i]) {
			printf("update bbt to nand chip%d ...", i);
			NAND_ENABLE_CE(nand, chip);
			rc = nand->update_table_inflash(nand, 0, chip);
			if (rc) {
				printf("failed\n");
				NAND_DISABLE_CE(nand);
				cur_chip->set_parameter(nand, ESLC_MODE, DEFAULT_VALUE);
				return rc;
			}
			printf("success\n");
		}
	}
	printf("\r\nWrite To NAND Flash OK\r\n");
	cur_chip->set_parameter(nand, ESLC_MODE, DEFAULT_VALUE);
//	cur_chip->get_parameter(nand, ESLC_MODE);
	NAND_DISABLE_CE(nand);
	return 0;
}

int WMTSaveImageToNAND(
	struct nand_chip *nand,
	unsigned long long naddr,
	unsigned int dwImageStart,
	unsigned int dwImageLength
	)
{
	unsigned int maddr = dwImageStart;
	unsigned int ret = dwImageLength;
	unsigned int need[CFG_MAX_NAND_DEVICE], i;
	unsigned long page, chip, page_in_chip,
	len_in_page, page_count, left_page_in_blk, block_in_chip;
	unsigned char fifo[64];
	int rc = -1;

	if (naddr >= nand->totlen || (naddr + ret) >= nand->totlen) {
		printf("naddr=0x%llx is out of size\r\n", naddr);
		return -2;
	}

	if (check_block_table(nand, 1)) {
		NAND_DISABLE_CE(nand);
		return -1;
	}

	page = (unsigned long)(naddr>>nand->page_shift);
	len_in_page = ret/nand->oobblock + ((ret%nand->oobblock) ? 1 : 0);

	set_ECC_mode(nand);

	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++)
		need[i] = 0;

	while (1) {
		chip = page / (nand->dwBlockCount * nand->dwPageCount);
		page_in_chip = page % (nand->dwBlockCount * nand->dwPageCount);
		block_in_chip = page_in_chip/nand->dwPageCount;

		if (chip >= nand->numchips) {
			printf("no space for write chip%d, left pages=%d\n", chip, len_in_page);
			break;
		}

		if (nand->isbadblock(nand, page_in_chip/nand->dwPageCount, chip)) {
			page = page + nand->dwPageCount - (page%nand->dwPageCount);
			continue;
		}
		NAND_ENABLE_CE(nand, chip);
		rc = wmt_nand_erase(nand, block_in_chip);
		if (rc < 0 || rc & 0x01) {
			printf("Erase failed at chip%d block%d\n", block_in_chip);
			nand->update_table_inram(nand, block_in_chip, chip);
			page = page + nand->dwPageCount - (page%nand->dwPageCount);
			need[chip] = 1;
			continue;
		}

		left_page_in_blk = nand->dwPageCount - page_in_chip%nand->dwPageCount;
  	    if (len_in_page >= nand->dwPageCount)
			page_count = (page%nand->dwPageCount) ? left_page_in_blk : nand->dwPageCount;
  	    else
  		    page_count = (len_in_page < left_page_in_blk) ? len_in_page : left_page_in_blk;


//		rc = nand_write_block(nand, maddr, page_in_chip, page_count, NULL);
		memset(fifo, 0xff, 64);
		rc = nand_write_block(nand, maddr, page_in_chip, page_count, fifo);
		if (rc) {
			printf("Write block failed at chip%d page%d\n", chip, page_in_chip);
			nand->update_table_inram(nand, block_in_chip, chip);
			page = page + page_count;
			need[chip] = 1;
			continue;
		}

		printf("\n write data from memory 0x%x to chip%d, page=0x%x, page count=0x%x\r\n",
		maddr, chip, page_in_chip, page_count);
		
		maddr = maddr + page_count * nand->oobblock;
		page = page + page_count;
		len_in_page -= page_count;

		if (!len_in_page) {
			printf("\r\n write NAND Flash OK\r\n");
			break;
		}
	}
	for (i = 0; i < nand->numchips; i++) {
		if (need[i]) {
			printf("update bbt to nand chip%d ...", i);
			NAND_ENABLE_CE(nand, chip);
			rc = nand->update_table_inflash(nand, 0, chip);
			if (rc) {
				printf("failed\n");
				NAND_DISABLE_CE(nand);
				return rc;
			}
			printf("success\n");
		}
	}
	printf("\r\nWrite To NAND Flash OK\r\n");
	NAND_DISABLE_CE(nand);
	return 0;
}

int eslc_load_image(struct nand_chip *nand, unsigned long long naddr, unsigned int maddr, unsigned int size)
{
	int rc = -1;
	unsigned long page, chip, page_in_chip,
	len_in_page, page_count, left_page_in_blk;

	if (naddr >= nand->totlen || (naddr + size) >= nand->totlen) {
		printf("naddr=0x%llx is out of size\r\n", naddr);
		return -2;
	}
	if (check_block_table(nand, 1)) {
		NAND_DISABLE_CE(nand);
		return -1;
	}
	page = (unsigned long)(naddr>>nand->page_shift);
	if((page % nand->dwPageCount)) {
		printf("Error: wrong parameter, Just support 0 page start.\n");
		return -1;
	}
	len_in_page = size/nand->oobblock + ((size%nand->oobblock) ? 1 : 0);
	printf("ESLC Load Image From NAND Flash page=0x%lx\r\n", page);

	rc = set_ECC_mode(nand);
	if (rc)
		return -1;

	while (1) {
		chip = page / (nand->dwBlockCount * nand->dwPageCount);
		page_in_chip = page % (nand->dwBlockCount * nand->dwPageCount);

		if (nand->isbadblock(nand, page_in_chip/nand->dwPageCount, chip)) {
			page = page + nand->dwPageCount - (page_in_chip%nand->dwPageCount);
			continue;
		}

		left_page_in_blk = nand->dwPageCount/2 - page_in_chip%(nand->dwPageCount/2);
	  	if (len_in_page >= (nand->dwPageCount/2))
			page_count = (page%(nand->dwPageCount/2)) ? left_page_in_blk : nand->dwPageCount/2;
	  	else
			page_count = (len_in_page < left_page_in_blk) ? len_in_page : left_page_in_blk;

		printf("left_page_in_blk:%d, len_in_page = %d, page_count = %d, chip:%d, page_in_chip:%d\n", left_page_in_blk, len_in_page, page_count, chip, page_in_chip);
		NAND_ENABLE_CE(nand, chip);
		rc = eslc_nand_read_block(nand, maddr, page_in_chip, page_count);
		if (rc)
			return rc;

		maddr = maddr + page_count*nand->oobblock;
		if(page_count == (nand->dwPageCount/2))
			page = page + nand->dwPageCount;
		else
			page = page + page_count;
		len_in_page -= page_count;

		if (!len_in_page) {
			printf("\r\nRead NAND Flash OK\r\n");
			NAND_DISABLE_CE(nand);
			return 0;
		}
	}
	NAND_DISABLE_CE(nand);
	return -1;
}

int WMTLoadImageFormNAND(
struct nand_chip *nand,
unsigned long long naddr,
unsigned int maddr,
unsigned int size)
{
	int rc = -1;
	unsigned long page, chip, page_in_chip,
	len_in_page, page_count, left_page_in_blk;

	if (naddr >= nand->totlen || (naddr + size) >= nand->totlen) {
		printf("naddr=0x%llx is out of size\r\n", naddr);
		return -2;
	}
	if (check_block_table(nand, 0)) {
		NAND_DISABLE_CE(nand);
		return -1;
	}
	page = (unsigned long)(naddr>>nand->page_shift);
	len_in_page = size/nand->oobblock + ((size%nand->oobblock) ? 1 : 0);
	printf("Load Image From NAND Flash page=0x%lx\r\n", page);

	rc = set_ECC_mode(nand);
	if (rc)
		return -1;

	while (1) {
		chip = page / (nand->dwBlockCount * nand->dwPageCount);
		page_in_chip = page % (nand->dwBlockCount * nand->dwPageCount);

		if (nand->isbadblock(nand, page_in_chip/nand->dwPageCount, chip)) {
			page = page + nand->dwPageCount - (page_in_chip%nand->dwPageCount);
			continue;
		}

  	left_page_in_blk = nand->dwPageCount - page_in_chip%nand->dwPageCount;
  	if (len_in_page >= nand->dwPageCount)
			page_count = (page%nand->dwPageCount) ? left_page_in_blk : nand->dwPageCount;
  	else
  		page_count = (len_in_page < left_page_in_blk) ? len_in_page : left_page_in_blk;

		/*printf("\n read start chip%d,page=0x%x, page count=0x%x\r\n",
		chip, page_in_chip, page_count);
		printf("\n read left_page_in_blk=%d,len_in_page=0x%x, page count=0x%x\r\n",
		left_page_in_blk, len_in_page, page_count);*/

		NAND_ENABLE_CE(nand, chip);
		rc = nand_read_block(nand, maddr, page_in_chip, page_count);
		if (rc)
			return rc;

		maddr = maddr + page_count*nand->oobblock;
		page = page + page_count;
		len_in_page -= page_count;

		if (!len_in_page) {
			printf("\r\nRead NAND Flash OK\r\n");
			NAND_DISABLE_CE(nand);
			return 0;
		}
	}
	NAND_DISABLE_CE(nand);
	return -1;
}

int isbbtbadblock(struct nand_chip *nand, unsigned int block, int chip)
{
#ifdef USE_BBT
	unsigned int ffword = 0x03;

	if (!bbt)
		return -1;
	if ((bbt[(nand->oobblock*chip)/4 + (block>>4)] & (ffword<<((block&0x0f)*2)))
	!= (ffword<<((block&0x0f)*2))) {
		/*printf("bbt : block%d is bad\n", block);*/
		return 1;
	}
#endif
	return 0;
}

int update_bbt_inflash(struct nand_chip *nand, unsigned int last, int chip)
{
	unsigned int i, j, block = 0, page_count;
	int rc = -1;
	unsigned char *pattern;
	unsigned int need;
	unsigned char fifo[64];
	unsigned int ofs, ofs1;

	if (!bbt) {
		printf("bbt = NULL\n");
		return -1;
	}

	NAND_ENABLE_CE(nand, chip);

	rc = set_ECC_mode(nand);
	if (rc) {
		return -1;
	}

	if(cur_chip && nand->mfr == NAND_HYNIX) {
		cur_chip->set_parameter(nand, ESLC_MODE, ECC_ERROR_VALUE);
	}
	ofs = NAND_LARGE_DWRESERVED1_OFS;
	ofs1 = NAND_LARGE_DWRESERVED2_OFS;
	if (nand->oobblock <= 0x200) {
		ofs = NAND_SMALL_DWRESERVED1_OFS;
		ofs1 = NAND_SMALL_DWRESERVED2_OFS;
	}
	page_count = 1 + (((nand->dwBlockCount>>2)>nand->oobblock) ? 1 : 0);
	/* first update to last block */
	if (last)
		block = last & 0xffff;
	else {
		bbt_version++;
		pattern = bbt_pattern;
		for (i = nand->dwBlockCount-1; i >= (nand->dwBlockCount-BBT_MAX_BLOCK); i--) {
			if (isbbtbadblock(nand, i, chip))
				continue;
			rc = wmt_nand_erase(nand, i);
			if (rc < 0 || rc & 0x01) {
				printf("Erase failed at chip%d, block%d\n", chip, i);
				update_bbt_inram(nand, i, chip);
				continue;
			}
			memset(fifo, 0xff, 64);
			for (j = 0; j < 4; j++) {
				fifo[ofs+j] = pattern[j];
				fifo[ofs1+j] = (unsigned char)((bbt_version>>(8*j))&0xff);
			}
			rc = nand_write_block(
				nand,
				(unsigned int)&bbt[(chip*nand->oobblock)/4],
				(i*nand->dwPageCount),
				page_count,
				fifo
			);
			if (rc)
				update_bbt_inram(nand, i, chip);
			else {
				printf("write bbt_pattern to chip%d, block%d , bbt 0x%8.8x\n",
					chip, i, (unsigned int)&bbt[0]);
				bad_block_pos[chip][nand->dwBlockCount -i -1] = i << 16;
				break;
			}
		}
		block = i;
	}
	if (block <= (nand->dwBlockCount-BBT_MAX_BLOCK)) {
		printf("err : we have only %d table blocks (block=%d)\n", BBT_MAX_BLOCK, block);
		if(cur_chip && nand->mfr == NAND_HYNIX) {
			cur_chip->set_parameter(nand, ESLC_MODE, DEFAULT_VALUE);
		}
		return -1;
	}
	need = 0;
	for (i = (nand->dwBlockCount-BBT_MAX_BLOCK); i < block; i++) {
		if (isbbtbadblock(nand, i, chip))
			continue;
		rc = wmt_nand_erase(nand, i);
		if (rc < 0 || rc & 0x01) {
			update_bbt_inram(nand, i, chip);
			printf("Erase failed at chip%d, block%x\n", chip, i);
			if (!need)
				bbt_version++;
			need = 1;
		}
	}
	pattern = mirror_pattern;
	if (last) {
		if ((last>>16) - 1)
			pattern = bbt_pattern;
	}
	for (i = block-1; i >= (nand->dwBlockCount-BBT_MAX_BLOCK); i--) {
		if (isbbtbadblock(nand, i, chip))
			continue;
		memset(fifo, 0xff, 64);
		for (j = 0; j < 4; j++) {
			fifo[ofs+j] = pattern[j];
			fifo[ofs1+j] = (unsigned char)((bbt_version>>(8*j))&0xff);
		}
		rc = nand_write_block(
			nand,
			(unsigned int)&bbt[(chip*nand->oobblock)/4],
			(i*nand->dwPageCount),
			page_count,
			fifo
		);
		if (rc) {
			update_bbt_inram(nand, i, chip);
			if (!need)
				bbt_version++;
			need = 1;
		} else {
			printf("write mirror_pattern to chip%d, block%d bbt = 0x%8.8x\n",
			chip, i, (unsigned int)&bbt[0]);
			bad_block_pos[chip][nand->dwBlockCount -i -1] = (i << 16);
			break;
		}
	}
	if(cur_chip && nand->mfr == NAND_HYNIX) {
		cur_chip->set_parameter(nand, ESLC_MODE, DEFAULT_VALUE);
	}
	return 0;
}

int update_bbt_inram(struct nand_chip *nand, unsigned int block, int chip)
{
	unsigned int ffword = 0x03;

	bbt[(chip*nand->oobblock)/4 + (block>>4)] &= ~(ffword<<((block&0x0f)*2));

	return 0;
}

int creat_bbt(struct nand_chip *nand, int chip)
{
	unsigned int i, j, count = 0;
	unsigned int page[2];
	unsigned int bpos[2];
	unsigned int ffword = 0x03;
	int rc = -1;

	NAND_ENABLE_CE(nand, chip);

	printf("creat_bbt at chip=%d\n", chip);
	nfc_ecc_set(USE_SW_ECC, ECC1bit, nand);
	/* scan bbt first */
	bpos[0] = (nand->dwBIOffset&0xffff);
	page[0] = (nand->dwBI0Position&0xffff);
	bpos[1] = (nand->dwBIOffset&0xffff);
	page[1] = (nand->dwBI1Position&0xffff);
	if (!bbt) {
		bbt = malloc(nand->oobblock * nand->numchips);
		if (!bbt) {
			printf("alloc bbt failed\n");
			return -1;
		}
	}
	memset((unsigned char *)bbt+nand->oobblock*chip, 0xff, nand->oobblock);
	for (i = 0; i < nand->dwBlockCount; i++) {
		for (j = 0; j < 2; j++) {
			rc = nand->nfc_read_page(
				nand,
				(i*nand->dwPageCount)+page[j],
				(unsigned int)nand->data_buf,
				nand->oobblock+nand->oobsize
			);
			if (rc) {
				printf("scan bbt err at block%d rc=%d\n", i+page[j], rc);
				if (rc != -ERR_ECC_UNCORRECT)
					return rc;
				bbt[i>>4] &= ~(ffword<<((i&0x0f)*2));
				count++;
				printf("find bad block : block%d\n", i);
				break;
			} else {
				if (*(((unsigned char *)nand->data_buf)+nand->oobblock+bpos[j]) != 0xFF ||
						*((unsigned char *)nand->data_buf) != 0xFF) {
							/*printf("find bad block : data_buf%x\n", *((unsigned char *)nand->data_buf));
							printf("find bad block : data_buf+oobblock%x\n", *(((unsigned char *)nand->data_buf)+nand->oobblock+bpos[j]));*/
					bbt[(nand->oobblock*chip)/4 +(i>>4)] &= ~(ffword<<((i&0x0f)*2));
					//printf("find bad block : block%d bbt[%d]=0x%x\n", i, (nand->oobblock*chip)/4 +(i>>4), bbt[(nand->oobblock*chip)/4 +(i>>4)]);
					count++;
					printf("find bad block : block%d\n", i);
					break;
				}
			}
		}
	}
	printf("Total find %d bad blocks\n", count);
	rc = set_ECC_mode(nand);
	if (rc)
		return -1;
	bbt_version = 0;
	nand->update_table_inflash = update_bbt_inflash;
	nand->update_table_inram = update_bbt_inram;
	nand->isbadblock = isbbtbadblock;

	return update_bbt_inflash(nand, 0, chip);
}

/* NanD_SelectChip: Select a given flash chip within the current floor */
#if 0
static inline int NanD_SelectChip(struct nand_chip *nand, int chip)
{
	/* Wait for it to be ready */
	return NanD_WaitReady(nand, 0);
}
#endif

int nfc_1bit_ecc_correct(struct nand_chip *nand, unsigned int start, unsigned int maddr, unsigned int len)
{
	unsigned int err = 0, bank = 0, i;
	unsigned int cp, lp = 0;
	unsigned char data = 0;
	int rc = -1;

	/* correct data area , first */
	err = pNFCRegs->NFCR20;
	if (err & 0xffffffff) {
		printf("data error err = %x\n", err);

		/* find which bank is err */
		for (i = 0; i < 32; i += 4) {
			if ((err>>i) & 0x0f) {
				err = (err>>i) & 0x0f;
				bank = i>>2;
				lp++;
			}
		}
		if (lp != 1)
			return -ERR_ECC_BANK;
		if (err & 0x0d)
			return -ERR_ECC_UNCORRECT;
		/* reset bank select */
		err = pNFCRegs->NFCR15;
		err &= 0xfffffffc;
		err |= ((bank+1)>>1);
		pNFCRegs->NFCR15 = err;
		rc = nand_read_page(nand, start, maddr, len);
		if (rc)
			return rc;
		/* correct data , now */
		if ((bank+1)%2) {
			lp = (pNFCRegs->NFCR1a & 0x1ff);
			cp = (pNFCRegs->NFCR1a>>9) & 0x07;
		} else {
			lp = (pNFCRegs->NFCR1b & 0x1ff);
			cp = (pNFCRegs->NFCR1b>>9) & 0x07;
		}
		bank = bank - 1;
		data = *(unsigned char *)(maddr+(bank*256)+lp);
		if (data & (1<<cp))
			data &= ~(1<<cp);
		else
			data |= (1<<cp);
		*(unsigned char *)(maddr+(bank*256)+lp) = data;
	}
	/* need to correct spare area ?	 */
	err = pNFCRegs->NFCR1f;
	if (err & 0x07) {
		printf(" red error \n");
		lp = (pNFCRegs->NFCR1c & 0x3f);
		cp = (pNFCRegs->NFCR1c>>8) & 0x07;
		data = pNFCRegs->FIFO[lp];
		if (data & (1<<cp))
			data &= ~(1<<cp);
		else
			data |= (1<<cp);
		pNFCRegs->FIFO[lp] = data;
	}
	return 0;
}

int nfc_1bit_read_page(struct nand_chip *nand, unsigned int start, unsigned int maddr, unsigned int len)
{
	int rc = -1;

	/* printf("nfc_1bit_read_page : addr = 0x%x (len = 0x%x) \n",start,len); */
	rc = nand_read_page(nand, start, maddr, len);
	if (rc < 0)
		return rc;
	if (pNFCRegs->NFCR1f & 0x07 || pNFCRegs->NFCR20 & 0xffffffff) {
		printf("ECC error \n");
		rc = nfc_1bit_ecc_correct(nand, start, maddr, len);
		if (rc)
			return rc;
	}

	return 0;
}

void calculate_ECC_info(struct nand_chip *nand, struct ECC_size_info *ECC_size)
{
	switch (ECC_size->ecc_engine)	{
		case 1:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC4bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 4;
		ECC_size->banks = nand->oobblock/512;
		ECC_size->bank_offset = nand->oobblock/ECC_size->banks + ECC4bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC4bit_byte_count;
		ECC_size->unprotect = ECC4bit_unprotect;
		break;
		case 2:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC8bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 8;
		ECC_size->banks = nand->oobblock/512;
		ECC_size->bank_offset = nand->oobblock/ECC_size->banks + ECC8bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC8bit_byte_count;
		ECC_size->unprotect = ECC8bit_unprotect;
		break;
		case 3:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC12bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 12;
		ECC_size->banks = nand->oobblock/512;
		ECC_size->bank_offset = nand->oobblock/ECC_size->banks + ECC12bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC12bit_byte_count;
		ECC_size->unprotect = ECC12bit_unprotect;
		break;
		case 4:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC16bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 16;
		ECC_size->banks = nand->oobblock/512;
		ECC_size->bank_offset = nand->oobblock/ECC_size->banks + ECC16bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC16bit_byte_count;
		ECC_size->unprotect = ECC16bit_unprotect;
		break;
		case 5:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC24bitPer1K_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 24;
		ECC_size->banks = nand->oobblock/1024;
		ECC_size->bank_offset = nand->oobblock/ECC_size->banks + ECC24bitPer1K_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC24bitPer1K_byte_count;
		ECC_size->unprotect = ECC24bitPer1K_unprotect;
		break;
		case 6:
		ECC_size->ecc_bits_count = ECC40bitPer1K_bit_count;
		ECC_size->oob_ecc_bits_count = ECC24bitPer1K_bit_count;
		ECC_size->max_bit_error = 40;
		ECC_size->oob_max_bit_error = 24;
		ECC_size->banks = nand->oobblock/1024;
		ECC_size->bank_offset = nand->oobblock/ECC_size->banks + ECC40bitPer1K_byte_count;
		ECC_size->ECC_bytes = ECC40bitPer1K_byte_count;
		ECC_size->oob_ECC_bytes = ECC24bitPer1K_byte_count;
		ECC_size->unprotect = ECC40bitPer1K_unprotect;
		break;
		case 7:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC44bitPer1K_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 44;
		ECC_size->banks = nand->oobblock/1024;
		ECC_size->bank_offset = nand->oobblock/ECC_size->banks + ECC44bitPer1K_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC44bitPer1K_byte_count;
		ECC_size->unprotect = ECC44bitPer1K_unprotect;
		break;
		/*case 8:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC44bit_bit_count;
		ECC_size->max_bit_error = 44;
		ECC_size->banks = nand->oobblock/512;
		ECC_size->bank_offset = nand->oobblock/ECC_size->banks + ECC44bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC44bit_byte_count;
		ECC_size->unprotect = ECC44bitPer1K_unprotect;
		break;*/
		default:
		printf("%d-bit ECC engine is not support:\r\n", ECC_size->ecc_engine);
		break;;
	}
	return;
}

int wmt_nand_reset(void)
{
	int status = -1;

	pNFCRegs->NFCR2 = 0xff; /* set command  */
	pNFCRegs->NFCRb |= B2R; /* write to clear*/
	pNFCRegs->NFCR1 = DPAHSE_DISABLE|(1<<1)|NFC_TRIGGER|0x400;
	status = NAND_WAIT_READY();
	if (status) {
		printf("\r\nreset chip=%x wait busy status = 0x%x time out\r\n", ((~pNFCRegs->NFCR11)&0xFF)>>1, status);
		return status;
	}
	return status;
}

int set_ECC_mode(struct nand_chip *nand)
{
	unsigned int ECCbit = nand->dwECCBitNum;
	unsigned int ECC_mode;
	switch (ECCbit) {
		case 1:
			ECC_mode = ECC1bit;
			break;
		case 4:
			ECC_mode = ECC4bit;
			break;
		case 8:
			ECC_mode = ECC8bit;
			break;
		case 12:
			ECC_mode = ECC12bit;
			break;
		case 16:
			ECC_mode = ECC16bit;
			break;
		case 24:
			ECC_mode = ECC24bitPer1K;
			break;
		case 40:
			ECC_mode = ECC40bitPer1K;
			break;
		default:
			printf("ecc mode input not support ECCbit=%d\n", ECCbit);
			return -1;
	}
	nfc_ecc_set(USE_HW_ECC, ECC_mode, nand);
	return 0;
}

int nand_readID(unsigned char *id)
{
	unsigned int cfg = 0, i = 0;
	int status = -1;

	pNFCRegs->NFCR2 = NAND_READID;
	pNFCRegs->NFCR3 = 0xff00;
	cfg = DPAHSE_DISABLE|(0x02<<1);
	pNFCRegs->NFCR1 = cfg|NFC_TRIGGER|0x400;	 /* cfg & start */
	status = NFC_WAIT_READY();
	if (status)
		return status;
	cfg = NAND2NFC|SING_RW;
	for (i = 0; i < 6; i++) {
		pNFCRegs->NFCR1 = cfg|NFC_TRIGGER|0x400;
		status = NFC_WAIT_READY();
		if (status)
			return status;
		status = NAND_WAIT_IDLE();
		if (status)
			return status;
		id[i] = (unsigned char)pNFCRegs->NFCR0;
	}

	return 0;
}

int nand_get_feature(void)
{
	unsigned char id[4]={0};
	
	unsigned int cfg = 0, i = 0;
	int status = -1;

	pNFCRegs->NFCR2 = 0xEE;
	pNFCRegs->NFCR3 = 0xff01;
	cfg = DPAHSE_DISABLE|(0x02<<1);
	pNFCRegs->NFCR1 = cfg|NFC_TRIGGER|0x400;	 /* cfg & start */
	status = NFC_WAIT_READY();
	if (status)
		return status;
	cfg = NAND2NFC|SING_RW;
	for (i = 0; i < 4; i++) {
		pNFCRegs->NFCR1 = cfg|NFC_TRIGGER|0x400;
		status = NFC_WAIT_READY();
		if (status)
			return status;
		status = NAND_WAIT_IDLE();
		if (status)
			return status;
		id[i] = (unsigned char)pNFCRegs->NFCR0;
	}

	printf("Micron nand flash feature is: 0x%02X%02X%02X%02X\n", id[0], id[1], id[2], id[3]);
	return 0;
}

int nand_set_feature(int value)
{
	unsigned char id[5]= {0};	
	unsigned int cfg = 0;

	id[0] = value;
	/* reset nand	 */
	WRITE_NAND_COMMAND(NAND_READ0);
	pNFCRegs->NFCR1 = DPAHSE_DISABLE|(1<<1)|NFC_TRIGGER|0x400;
	if (NFC_WAIT_READY())
		return -ERR_NFC_READY;

	if (nfc_dma_cfg((unsigned int)id, 4, 1))
	{
		printf("nand_set_feature() fail\n");
		return -ERR_DMA_CFG;
	}

	pNFCRegs->NFCR2 = 0xEF;
	pNFCRegs->NFCR3 = 0xff01;
	cfg = 0x02<<1;
	pNFCRegs->NFCR1 = cfg|NFC_TRIGGER|0x400;	 /* cfg & start */

	if (NFC_WAIT_READY())/* wait command &data completed */
		return -ERR_NFC_READY;
	/* while (!(pNFCRegs->NFCR1d&NFC_IDLE));  */
	if (NAND_WAIT_IDLE())
		return -ERR_NAND_IDLE;

	return 0;
}

void copy_filename (char *dst, char *src, int size);/*
{                                                                                                                                            
    if (*src && (*src == '"')) {
        ++src;
        --size;
    }
    
    while ((--size > 0) && *src && (*src != '"')) {
        *dst++ = *src++;
    }
    *dst = '\0';
}*/

/* Nand_IdentChip: Identify a given NAND chip given {floor,chip} */
static int Nand_IdentChip(struct nand_chip *nand, int floor, int chip)
{
	unsigned int mfr, id, i, found = 0, ecc_bit_mode, id_5th = 0;
	unsigned char ids[6], chip_off = chip;
	unsigned int idd;
	struct ECC_size_info ECC_size;
	//char *s = NULL, *tmp;
	//unsigned int value;
	int rc = -1;

	pNFCRegs->NFCR22 = 0;
	pNFCRegs->NFCRd = 0;
	NAND_ENABLE_CE(nand, chip_off);  /* set pin low */
	/*pNFCRegs->NFCR11 = ~(1 << chip_off);*/
	if (chip_off == 0) {
		pNFCRegs->NFCR12 = PAGE_2K|WIDTH_8|WP_DISABLE|DIRECT_MAP|0x40;
		pNFCRegs->NFCR14 &= 0xffff0000;
		pNFCRegs->NFCR14 |= 0x3636;/* in case of margine short	 */
	}
	/* Reset the chip */
	rc = wmt_nand_reset();
	if (rc)
		return 0;

#if 0 /* dannier mark open source start */
/*************************************************************************/
	if (NanD_Command(nand, NAND_CMD_RESET)) {
#ifdef NAND_DEBUG
		printf("NanD_Command (reset) for %d,%d returned true\n",
		       floor, chip);
#endif
		NAND_DISABLE_CE(nand);  /* set pin high */
		return 0;
	}

	/* Read the NAND chip ID: 1. Send ReadID command */
	if (NanD_Command(nand, NAND_CMD_READID)) {
#ifdef NAND_DEBUG
		printf("NanD_Command (ReadID) for %d,%d returned true\n",
		       floor, chip);
#endif
		NAND_DISABLE_CE(nand);  /* set pin high */
		return 0;
	}

	/* Read the NAND chip ID: 2. Send address byte zero */
	NanD_Address(nand, ADDR_COLUMN, 0);

	/* Read the manufacturer and device id codes from the device */

	mfr = READ_NAND(nand->IO_ADDR);

	id = READ_NAND(nand->IO_ADDR);
/*************************************************************************/
#endif /* dannier mark open source end */

	rc = nand_readID(ids);
	if (rc) {
		printf("get id failed\n");
		return 0;
	}
	mfr = ids[0];
	idd = (ids[1]<<24) + (ids[2]<<16) + (ids[3]<<8) + (ids[4]);
	id = (ids[1]<<16) + (ids[2]<<8) + ids[3];
	id_5th = (ids[4]<<24) + (ids[5]<<16);
	NAND_DISABLE_CE(nand);  /* set pin high */
#ifdef NAND_DEBUG
	printf("NanD_Command (ReadID) got %x %x %x\n", mfr, id, id_5th);
#endif
	if (mfr == 0xff || mfr == 0) {
		/* No response - return failure */
		return 0;
	}

	/* Check it's the same as the first chip we identified.
	 * M-Systems say that any given nand_chip device should only
	 * contain _one_ type of flash part, although that's not a
	 * hardware restriction. */
	if (nand->mfr) {
		if (((mfr << 24) + id) == nand->id) {
			return 1;	/* This is another the same the first */
		} else {
			printf("Flash chip at floor %d, chip %d is different:\n",
			       floor, chip);
		}
	}
	/*-------identify by env start-----------*/
	for (i = 0; WMT_nand_flash_ids[i].dwFlashID != 0; i++)
		if (((unsigned int)id + (mfr<<24)) == WMT_nand_flash_ids[i].dwFlashID) {
			if (WMT_nand_flash_ids[i].dwFlashID == 0x98D79432)
				if (id_5th != WMT_nand_flash_ids[i].dwFlashID2)
					continue;
			found = 1;
			break;
		}
#if 0
	if (!(*((volatile unsigned int *)(0xd8110100))&2))
		s = getenv("wmt.io.nand");
	if (s != NULL) {
		if (found == 1)
			printf("flash id has been established in flash id list\n");

		value = simple_strtoul(s, &tmp, 16);
		if ((unsigned int)((unsigned int)id + (mfr<<24)) != value) {
			printf("uboot env config id not match, env_id = 0x%x, chip_id = 0x%x\n",
			value, (unsigned int)id + (mfr<<24));
			goto list;
		}
		nand->dwFlashID = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwBlockCount = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwPageSize = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwSpareSize = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwBlockSize = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwAddressCycle = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwBI0Position = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwBI1Position = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwBIOffset = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwDataWidth = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwPageProgramLimit = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwSeqRowReadSupport = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwSeqPageProgram = value;
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwNandType = value;
		/*s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwECCBitNum = value;*/
		s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		nand->dwRWTimming = value;
		s = tmp+1;
		copy_filename(nand->cProductName, s, MAX_PRODUCT_NAME_LENGTH);

		if (nand->dwBlockCount < 1024 || nand->dwBlockCount > 16384) {
			printf("dwBlockCount = 0x%x is abnormal\n", nand->dwBlockCount);
			goto list;
		}
		if (nand->dwPageSize < 512  || nand->dwPageSize > 16384) {
			printf("dwPageSize = 0x%x is abnormal\n", nand->dwPageSize);
			goto list;
		}
		if (nand->dwBlockSize < (1024*64)  || nand->dwBlockSize > (16384*64)) {
			printf("dwBlockSize = 0x%x is abnormal\n", nand->dwBlockSize);
			goto list;
		}
		if (nand->dwAddressCycle < 3  || nand->dwAddressCycle > 5) {
			printf("dwAddressCycle = 0x%x is abnoraml\n", nand->dwAddressCycle);
			goto list;
		}
		if (nand->dwBI0Position != 0  &&
		nand->dwBI0Position > ((nand->dwBlockSize/nand->dwPageSize)-1)) {
			printf("dwBI0Position = 0x%x is abnoraml\n", nand->dwBI0Position);
			goto list;
		}
		if (nand->dwBI1Position != 0  &&
		nand->dwBI1Position > ((nand->dwBlockSize/nand->dwPageSize)-1)) {
			printf("dwBI1Position = 0x%x is abnoraml\n", nand->dwBI1Position);
			goto list;
		}
		if (nand->dwBIOffset != 0 && nand->dwBIOffset != 5) {
			printf("dwBIOffset = 0x%x is abnoraml\n", nand->dwBIOffset);
			goto list;
		}
		if (nand->dwDataWidth != 0/* && nand->dwDataWidth != 1*/) {
			printf("dwDataWidth = 0x%x is abnoraml\n", nand->dwDataWidth);
			goto list;
		}
		/*printf("dwFlashID = 0x%x\n", nand->dwFlashID);
		printf("dwBlockCount = 0x%x\n", nand->dwBlockCount);
		printf("dwPageSize = 0x%x\n", nand->dwPageSize);
		printf("dwSpareSize = 0x%x\n", nand->dwSpareSize);
		printf("dwBlockSize = 0x%x\n", nand->dwBlockSize);
		printf("dwAddressCycle = 0x%x\n", nand->dwAddressCycle);
		printf("dwBI0Position = 0x%x\n", nand->dwBI0Position);
		printf("dwBI1Position = 0x%x\n", nand->dwBI1Position);
		printf("dwBIOffset = 0x%x\n", nand->dwBIOffset);
		printf("dwDataWidth = 0x%x\n", nand->dwDataWidth);
		printf("dwPageProgramLimit = 0x%x\n", nand->dwPageProgramLimit);
		printf("dwSeqRowReadSupport = 0x%x\n", nand->dwSeqRowReadSupport);
		printf("dwSeqPageProgram = 0x%x\n", nand->dwSeqPageProgram);
		printf("dwNandType = 0x%x\n", nand->dwNandType);
		printf("dwECCBitNum = 0x%x\n", nand->dwECCBitNum);
		printf("dwRWTimming = 0x%x\n", nand->dwRWTimming);
		printf("cProductName = %s\n", nand->cProductName);*/

		nand->mfr = mfr;
		nand->id = (mfr << 24) + (unsigned int)id;
		nand->chipshift = shift_bit(nand->dwBlockCount) + shift_bit(nand->dwBlockSize);
		nand->page256 = 0;/*nand_flash_ids[i].page256;*/
		nand->eccsize = 512;//256;
		if (nand->page256) {
			nand->oobblock = 256;
			nand->oobsize = 8;
			nand->page_shift = 8;
		} else {
			nand->oobblock = nand->dwPageSize;//512;
			nand->oobsize = nand->dwSpareSize;//16;
			nand->page_shift = shift_bit(nand->dwPageSize);//9;
		}
		nand->erasesize  = nand->dwBlockSize;//nand_flash_ids[i].erasesize;
		nand->chips_name = nand->cProductName;
		nand->bus16	 = nand->dwDataWidth;
		nand->dwPageCount = nand->dwBlockSize/nand->dwPageSize;
		nand->IO_ADDR = __NFC_BASE;
		wmt_get_timing(nand, (unsigned int)nand->dwRWTimming);
		/*-------------move from cmd_nandrw.c below-----------------*/
		pNFCRegs->NFCR12 = WP_DISABLE | DIRECT_MAP | CHECK_ALLFF;

		switch (nand->oobblock) {
		case 512:
			pNFCRegs->NFCR12 |= PAGE_512;
			nand->col = 1;
			break;
		case 2048:
			pNFCRegs->NFCR12 |= PAGE_2K;
			nand->col = 2;
			break;
		case 4096:
			pNFCRegs->NFCR12 |= PAGE_4K;
			nand->col = 2;
			break;
		case 8192:
			pNFCRegs->NFCR12 |= PAGE_8K;
			nand->col = 2;
			break;
		case 16384:
			pNFCRegs->NFCR12 |= PAGE_16K;
			nand->col = 2;
			break;
		default:
			return 0;
		}
		nand->row = nand->dwAddressCycle - nand->col;
		nand->pageadrlen = nand->row;
		switch (nand->dwPageCount) {
		case 32:
		case 64:
			pNFCRegs->NFCR17 |= nand->dwPageCount;
			break;
		case 128:
			pNFCRegs->NFCR17 |= 0x60;
			break;
		case 256:
			pNFCRegs->NFCR17 |= 0x80;
			break;
		case 512:
			pNFCRegs->NFCR17 |= 0xA0;
			break;
		default:
			return 0;
		}
		if (nand->bus16)
			pNFCRegs->NFCR12 |= WIDTH_16;
		else
			pNFCRegs->NFCR12 |= WIDTH_8;
	
		if (nand->oobblock > 512) {
			if (nand->oobblock >= 8192) {
				if (nand->dwSpareSize >= 640) {
					nfc_ecc_set(USE_HW_ECC, ECC40bitPer1K, nand);
					nand->dwECCBitNum = 40;
				} else {
					nfc_ecc_set(USE_HW_ECC, ECC24bitPer1K, nand);
					nand->dwECCBitNum = 24;
				}
			} else if (nand->oobblock >= 4096 && nand->oobsize >= 218) {
				nfc_ecc_set(USE_HW_ECC, ECC12bit, nand);
				nand->dwECCBitNum = 12;
			} else {
				nfc_ecc_set(USE_HW_ECC, ECC4bit, nand);
				nand->dwECCBitNum = 4;
			}
		} else {
			nand->dwECCBitNum = 1;
			nfc_ecc_set(USE_HW_ECC, ECC1bit, nand);
		}

		return 1;
	}
list:
#endif
	if (found == 0) {
		/* We haven't fully identified the chip. Print as much as we know. */
		printf("Unknown flash chip found: %2.2X %2.2X\n", mfr, idd);
		return 0;
	}
	printf("env not define nand id, use default flash id list\n");
	/*-------identify by env end----------*/

	/* Print and store the manufacturer and ID codes. */
	for (i = 0; WMT_nand_flash_ids[i].dwFlashID != 0; i++) {
		if (((unsigned int)id + (mfr<<24)) == WMT_nand_flash_ids[i].dwFlashID) {
			if (WMT_nand_flash_ids[i].dwFlashID == 0x98D79432)
				if (id_5th != WMT_nand_flash_ids[i].dwFlashID2)
					continue;
#ifdef NAND_DEBUG
			printf("Flash chip found:\n\t Manufacturer ID: 0x%2.2X, "
			       "Chip ID: 0x%2.2X (%s)\n", mfr, id,
			       WMT_nand_flash_ids[i].ProductName);
#endif
			if (!nand->mfr) {
				memcpy(nand, &WMT_nand_flash_ids[i], sizeof(struct WMT_nand_flash_dev));
				nand->mfr = mfr;
				nand->id = (mfr << 24) + (unsigned int)id;
				nand->id2 = WMT_nand_flash_ids[i].dwFlashID2;
				nand->chipshift = shift_bit(WMT_nand_flash_ids[i].dwBlockCount) +
				    shift_bit(WMT_nand_flash_ids[i].dwBlockSize);
				nand->page256 = 0;//nand_flash_ids[i].page256;
				nand->eccsize = 512;//256;
				if (nand->page256) {
					nand->oobblock = 256;
					nand->oobsize = 8;
					nand->page_shift = 8;
				} else {
					nand->oobblock = WMT_nand_flash_ids[i].dwPageSize;//512;
					nand->oobsize = WMT_nand_flash_ids[i].dwSpareSize;//16;
					nand->page_shift = shift_bit(WMT_nand_flash_ids[i].dwPageSize);//9;
				}
				nand->erasesize  = WMT_nand_flash_ids[i].dwBlockSize;//nand_flash_ids[i].erasesize;
				nand->chips_name = WMT_nand_flash_ids[i].ProductName;
				nand->bus16	 = WMT_nand_flash_ids[i].dwDataWidth;
				nand->dwPageCount = WMT_nand_flash_ids[i].dwBlockSize/WMT_nand_flash_ids[i].dwPageSize;
				nand->IO_ADDR = __NFC_BASE;
				wmt_get_timing(nand, (unsigned int)WMT_nand_flash_ids[i].dwRWTimming);
				/*-------------move from cmd_nandrw.c below-----------------*/
				pNFCRegs->NFCR12 = WP_DISABLE | DIRECT_MAP | CHECK_ALLFF;

				switch (nand->oobblock) {
				case 512:
					pNFCRegs->NFCR12 |= PAGE_512;
					nand->col = 1;
					break;
				case 2048:
					pNFCRegs->NFCR12 |= PAGE_2K;
					nand->col = 2;
					break;
				case 4096:
					pNFCRegs->NFCR12 |= PAGE_4K;
					nand->col = 2;
					break;
				case 8192:
					pNFCRegs->NFCR12 |= PAGE_8K;
					nand->col = 2;
					break;
				case 16384:
					pNFCRegs->NFCR12 |= PAGE_16K;
					nand->col = 2;
					break;
				default:
					return 0;
				}
				nand->row = WMT_nand_flash_ids[i].dwAddressCycle - nand->col;
				nand->pageadrlen = nand->row;
				switch (nand->dwPageCount) {
				case 32:
				case 64:
					pNFCRegs->NFCR17 |= nand->dwPageCount;
					break;
				case 128:
					pNFCRegs->NFCR17 |= 0x60;
					break;
				case 256:
					pNFCRegs->NFCR17 |= 0x80;
					break;
				case 512:
					pNFCRegs->NFCR17 |= 0xA0;
					break;
				default:
					return 0;
				}
				if (nand->bus16)
					pNFCRegs->NFCR12 |= WIDTH_16;
				else
					pNFCRegs->NFCR12 |= WIDTH_8;
					
				ecc_bit_mode = nand->dwECCBitNum;
				if (ecc_bit_mode > 24)
					ecc_bit_mode = (ecc_bit_mode == 40) ? 6 : (-1);
				else
					ecc_bit_mode = (ecc_bit_mode > 16) ? ((ecc_bit_mode/4) - 1) : (ecc_bit_mode/4);
				ECC_size.ecc_engine = ecc_bit_mode;
				calculate_ECC_info(nand, &ECC_size);
				pNFCRegs->NFCR10 = (ECC_size.oob_ECC_bytes<<8);//+ ECC_size.unprotect;
				rc = set_ECC_mode(nand);
				if (rc)
					return 0;

 				return 1;
			}
			return 0;
		}
	}


/*#ifdef NAND_DEBUG*/
	/* We haven't fully identified the chip. Print as much as we know. */
	printf("Unknown flash chip found: %2.2X %2.2X\n",
	       mfr, id);
/*#endif*/

	return 0;
}

int wmt_calc_clock(struct nand_chip *nand, unsigned int spec_clk,
unsigned int *T, unsigned int *divisor, unsigned int *Thold)
{
	unsigned int i, div1=0, div2, clk1, clk2=0, comp, T1=0, T2=0, clk, pllb;
	unsigned int tREA, tREH, Thold2, Ttmp, tADL, tWP;
	
	pllb = *(volatile unsigned int *)PMPMB_ADDR;
	printf("pllb=0x%x, spec_clk=0x%x\n", pllb, spec_clk);
	pllb = (2*(((pllb>>16)&0x7F)+1))/((((pllb>>8)&0x1F)+1)*(1<<(pllb&3)));

	tREA = (spec_clk>>24)&0xFF;
	tREH = (spec_clk>>16)&0xFF;
	tWP  = (spec_clk>>8)&0xFF;
	tADL = spec_clk&0xFF;
	for (i = 1; i < 16; i++) {
		if (NFC_MAX_CLOCK >= ((pllb*WMT_PLL_CLOCK)/i)) {
			div1 = i;
			break;
		}
	}

	clk1 = (1000 * div1)/(pllb*WMT_PLL_CLOCK);
	/*printf("clk1=%d, div1=%d, spec_clk=%d\n", clk1, div1, spec_clk);*/
	for (T1 = 1; T1 < 10; T1++) {
		if ((T1*clk1) >= (tREA + NFC_SETUPTIME)) /* 8.64 = tSKEW 5.64 + tDLY 2.42 + tSETUP 0.4 */
			break;
	}
	i = 1;
	while (i*clk1 <= tREH) {
		i++;
	}
	*Thold = i;
	printf("T1=%d, clk1=%d, div1=%d, Thold=%d, tREA=%d+delay(9)\n", T1, clk1, div1, *Thold, tREA);
	Ttmp = *T = T1;
	clk = clk1;
	*divisor = div1;
	div2 = div1;
	while (Ttmp > 1 && clk != 0) {
		div2++;
		clk2 = (1000 * div2)/(pllb*WMT_PLL_CLOCK);
		comp = 0;
		for (T2 = 1; T2 < Ttmp; T2++) {
			if ((T2*clk2) >= (tREA + NFC_SETUPTIME)) { /* 8.64 = tSKEW 5.64 + tDLY 2.42 + tSETUP 0.4 */
				Ttmp = T2;
				comp = 1;
				i = 1;
				while (i*clk2 <= tREH) {
					i++;
				}
				Thold2 = i;
				printf("T2=%d, clk2=%d, div2=%d, Thold2=%d, comp=1\n", T2, clk2, div2, Thold2);
				break;
			}
		}
		if (comp == 1) {
			clk1 = clk * (*T+*Thold) * nand->oobblock;
			div1 = clk2 * (T2+Thold2) * nand->oobblock;
			printf("Tim1=%d , Tim2=%d\n", clk1, div1);
			if ((clk * (*T+*Thold) * nand->oobblock) > (clk2 * (T2+Thold2) * nand->oobblock)) {
				*T = T2;
				clk = clk2;
				*divisor = div2;
				*Thold = Thold2;
			} else {
				printf("T2 is greater and not use\n");
			}
		}
	} /* end of while */
	//printf("Tadfasdfil\n");
	i = 1;
	*Thold |= 0x100; /* set write setup/hold time */
	while (((i*2+2)*clk) <= (tADL-tWP) || (i*clk) <= (tWP+1)) {/*+1*/
		*Thold += 0x100;
		i++;
	}
	/* set write hold time */
	/* tWP > tWH*/
	/*i = 1;
	*Thold |= 0x10000;
	while (((i*2+2)*clk) <= tADL || (i*clk) < tWP) {
		*Thold += 0x10000;
		i++;
	}*/
	
	printf("T=%d, clk=%d, divisor=%d, Thold=0x%x\n", *T, clk, *divisor, *Thold);
	if ((NFC_MAX_CLOCK < (pllb*WMT_PLL_CLOCK)/(*divisor)) || clk == 0 || *T == 0 || clk > 45)
		return 1;

	return 0;
}

int wmt_get_timing(struct nand_chip *nand, unsigned int nand_timing)
{
	unsigned int T, Thold, divisor, NFC_RWTimming;	

#ifdef NFC_TIMEING_CAL
	if (wmt_calc_clock(nand, nand_timing, &T, &divisor, &Thold)) {
		printf("timming setting fail");
		return 1;
	}
	NFC_RWTimming = 0x2424;//((Thold&0xFF) << 12) + ((T + (Thold&0xFF)) << 8) +
	//(2 << 4) + 4;/*(((Thold>>8)&0xFF) << 4) + 2*((Thold>>8)&0xFF);*/
	switch(nand->dwFlashID)
	{
		case 0x2C88044B:
		case 0x2C68044A:
			divisor = 9;
		break;
	}

	*(volatile unsigned long *)PMNAND_ADDR = (divisor&0x1FF);
	while ((*(volatile unsigned long *)PMCS_ADDR)&(0x7F0038))
		;
	pNFCRegs->NFCR14 &=  0xffff0000;
	pNFCRegs->NFCR14 |= NFC_RWTimming;
	printf("divisor is set 0x%x, NFC_timing=0x%x\n", divisor, NFC_RWTimming);
#endif
	return 0;
}

/* NanD_ScanChips: Find all NAND chips present in a nand_chip, and identify them */

static void Nand_ScanChips(struct nand_chip *nand)
{
	int floor, chip;
	int numchips[NAND_MAX_FLOORS];
	int maxchips = NAND_MAX_CHIPS;
	int ret = 1;

	nand->numchips = 0;
	nand->mfr = 0;
	nand->id = 0;


	/* For each floor, find the number of valid chips it contains */
	for (floor = 0; floor < NAND_MAX_FLOORS; floor++) {
		ret = 1;
		numchips[floor] = 0;
		for (chip = 0; chip < maxchips && ret != 0; chip++) {

			ret = Nand_IdentChip(nand, floor, chip);
			if (ret) {
				numchips[floor]++;
				nand->numchips++;
			} else
				break;
		}
	}

	/* If there are none at all that we recognise, bail */
	if (!nand->numchips) {
#ifdef NAND_DEBUG
		puts ("No NAND flash chips recognised.\n");
#endif
		return;
	}

	/* Allocate an array to hold the information for each chip */
	nand->chips = malloc(sizeof(struct Nand) * nand->numchips);
	if (!nand->chips) {
		puts ("No memory for allocating chip info structures\n");
		return;
	}

	ret = 0;

	/* Fill out the chip array with {floor, chipno} for each
	 * detected chip in the device. */
	for (floor = 0; floor < NAND_MAX_FLOORS; floor++) {
		for (chip = 0; chip < numchips[floor]; chip++) {
			nand->chips[ret].floor = floor;
			nand->chips[ret].chip = chip;
			nand->chips[ret].curadr = 0;
			nand->chips[ret].curmode = 0x50;
			ret++;
		}
	}

	/* Calculate and print the total size of the device */
	nand->totlen = nand->numchips * ((long long)1 << nand->chipshift);
	//nand->totlen = (long long)nand->dwBlockCount * (long long)nand->dwBlockSize;
#ifdef CONFIG_WMT_RANDOMIZER
	if(nand->dwRdmz) {
		rdmz_buf = malloc(nand->oobblock);
		if(rdmz_buf == NULL)
			printf("randomizer buffer malloc fail.\n");
	}
#endif

	printf("%d flash chips found. Total nand size: %ld MB\n",
	       nand->numchips, nand->totlen >> 20);
}

/* we need to be fast here, 1 us per read translates to 1 second per meg */
#if 0
static void NanD_ReadBuf (struct nand_chip *nand, u_char * data_buf, int cntr)
{
	unsigned long nandptr = nand->IO_ADDR;

	//NanD_Command (nand, NAND_CMD_READ0);

	if (nand->bus16) {
		u16 val;

		while (cntr >= 16) {
			val = READ_NAND (nandptr);
			*data_buf++ = val & 0xff;
			*data_buf++ = val >> 8;
			val = READ_NAND (nandptr);
			*data_buf++ = val & 0xff;
			*data_buf++ = val >> 8;
			val = READ_NAND (nandptr);
			*data_buf++ = val & 0xff;
			*data_buf++ = val >> 8;
			val = READ_NAND (nandptr);
			*data_buf++ = val & 0xff;
			*data_buf++ = val >> 8;
			val = READ_NAND (nandptr);
			*data_buf++ = val & 0xff;
			*data_buf++ = val >> 8;
			val = READ_NAND (nandptr);
			*data_buf++ = val & 0xff;
			*data_buf++ = val >> 8;
			val = READ_NAND (nandptr);
			*data_buf++ = val & 0xff;
			*data_buf++ = val >> 8;
			val = READ_NAND (nandptr);
			*data_buf++ = val & 0xff;
			*data_buf++ = val >> 8;
			cntr -= 16;
		}

		while (cntr > 0) {
			val = READ_NAND (nandptr);
			*data_buf++ = val & 0xff;
			*data_buf++ = val >> 8;
			cntr -= 2;
		}
	} else {
		while (cntr >= 16) {
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			*data_buf++ = READ_NAND (nandptr);
			cntr -= 16;
		}

		while (cntr > 0) {
			*data_buf++ = READ_NAND (nandptr);
			cntr--;
		}
	}
}
/*
 * NAND read with ECC
 */
static int nand_read_ecc(struct nand_chip *nand, size_t start, size_t len,
		 size_t * retlen, u_char *buf, u_char *ecc_code)
{
	int col, page;
	int ecc_status = 0;
#ifdef CONFIG_MTD_NAND_ECC
	int j;
	int ecc_failed = 0;
	u_char *data_poi;
	/*u_char ecc_calc[6];*/
#endif

	/* Do not allow reads past end of device */
	if ((start + len) > nand->totlen) {
		printf ("%s: Attempt read beyond end of device %x %x %x\n",
			__FUNCTION__, (uint) start, (uint) len, (uint) nand->totlen);
		*retlen = 0;
		return -1;
	}

	/* First we calculate the starting page */
	/*page = shr(start, nand->page_shift);*/
	page = start >> nand->page_shift;

	/* Get raw starting column */
	col = start & (nand->oobblock - 1);

	/* Initialize return value */
	*retlen = 0;

	/* Select the NAND device */
	NAND_ENABLE_CE(nand, 0);  /* set pin low */

	/* Loop until all data read */
	while (*retlen < len) {

#ifdef CONFIG_MTD_NAND_ECC
		/* Do we have this page in cache ? */
		if (nand->cache_page == page)
			goto readdata;
		/* Send the read command */
		//NanD_Command(nand, NAND_CMD_READ0);
		/*if (nand->bus16) {
 			NanD_Address(nand, ADDR_COLUMN_PAGE,
				     (page << nand->page_shift) + (col >> 1));
		} else {
 			NanD_Address(nand, ADDR_COLUMN_PAGE,
				     (page << nand->page_shift) + col);
		}*/

		/* Read in a page + oob data */
		/*NanD_ReadBuf(nand, nand->data_buf, nand->oobblock + nand->oobsize);*/
		j = nand->nfc_read_page(nand, (page<<nand->page_shift), (unsigned int)nand->data_buf, nand->oobblock);
		if (j)
			ecc_failed++;
		/* copy data into cache, for read out of cache and if ecc fails */
		if (nand->data_cache) {
			memcpy (nand->data_cache, nand->data_buf,
				nand->oobblock + nand->oobsize);
		}

		/* Pick the ECC bytes out of the oob data */
		for (j = 0; j < 6; j++) {
			ecc_code[j] = nand->data_buf[(nand->oobblock + oob_config.ecc_pos[j])];
		}

		/* Calculate the ECC and verify it */
		/* If block was not written with ECC, skip ECC */
		#if 0
		if (oob_config.eccvalid_pos != -1 &&
		    (nand->data_buf[nand->oobblock + oob_config.eccvalid_pos] & 0x0f) != 0x0f) {

			nand_calculate_ecc (&nand->data_buf[0], &ecc_calc[0]);
			switch (nand_correct_data (&nand->data_buf[0], &ecc_code[0], &ecc_calc[0])) {
			case -1:
				printf ("%s: Failed ECC read, page 0x%08x\n", __FUNCTION__, page);
				ecc_failed++;
				break;
			case 1:
			case 2:	/* transfer ECC corrected data to cache */
				if (nand->data_cache)
					memcpy (nand->data_cache, nand->data_buf, 256);
				break;
			}
		}

		if (oob_config.eccvalid_pos != -1 &&
		    nand->oobblock == 512 && (nand->data_buf[nand->oobblock + oob_config.eccvalid_pos] & 0xf0) != 0xf0) {

			nand_calculate_ecc (&nand->data_buf[256], &ecc_calc[3]);
			switch (nand_correct_data (&nand->data_buf[256], &ecc_code[3], &ecc_calc[3])) {
			case -1:
				printf ("%s: Failed ECC read, page 0x%08x\n", __FUNCTION__, page);
				ecc_failed++;
				break;
			case 1:
			case 2:	/* transfer ECC corrected data to cache */
				if (nand->data_cache)
					memcpy (&nand->data_cache[256], &nand->data_buf[256], 256);
				break;
			}
		}
		#endif
readdata:
		/* Read the data from ECC data buffer into return buffer */
		data_poi = (nand->data_cache) ? nand->data_cache : nand->data_buf;
		data_poi += col;
		if ((*retlen + (nand->oobblock - col)) >= len) {
			memcpy (buf + *retlen, data_poi, len - *retlen);
			*retlen = len;
		} else {
			memcpy (buf + *retlen, data_poi,  nand->oobblock - col);
			*retlen += nand->oobblock - col;
		}
		/* Set cache page address, invalidate, if ecc_failed */
		nand->cache_page = (nand->data_cache && !ecc_failed) ? page : -1;

		ecc_status += ecc_failed;
		ecc_failed = 0;
/*#else*/
#if 0
		/* Send the read command */
		//NanD_Command(nand, NAND_CMD_READ0);
		if (nand->bus16) {
			NanD_Address(nand, ADDR_COLUMN_PAGE,
				     (page << nand->page_shift) + (col >> 1));
		} else {
			NanD_Address(nand, ADDR_COLUMN_PAGE,
				     (page << nand->page_shift) + col);
		}

		/* Read the data directly into the return buffer */
		if ((*retlen + (nand->oobblock - col)) >= len) {
			NanD_ReadBuf(nand, buf + *retlen, len - *retlen);
			*retlen = len;
			/* We're done */
			continue;
		} else {
			NanD_ReadBuf(nand, buf + *retlen, nand->oobblock - col);
			*retlen += nand->oobblock - col;
			}
#endif
#endif
		/* For subsequent reads align to page boundary. */
		col = 0;
		/* Increment page address */
		page++;
	}

	/* De-select the NAND device */
	NAND_DISABLE_CE(nand);  /* set pin high */

	/*
	 * Return success, if no ECC failures, else -EIO
	 * fs driver will take care of that, because
	 * retlen == desired len and result == -EIO
	 */
	return ecc_status ? -1 : 0;
}

/*
 *	Nand_page_program function is used for write and writev !
 */
static int nand_write_page (struct nand_chip *nand,
			    int page, int col, int last, u_char * ecc_code)
{

	int i;
	unsigned long nandptr = nand->IO_ADDR;

#ifdef CONFIG_MTD_NAND_ECC
#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
	int ecc_bytes = (nand->oobblock == 512) ? 6 : 3;
#endif
#endif
	/* pad oob area */
	for (i = nand->oobblock; i < nand->oobblock + nand->oobsize; i++)
		nand->data_buf[i] = 0xff;

#ifdef CONFIG_MTD_NAND_ECC
	/* Zero out the ECC array */
	for (i = 0; i < 6; i++)
		ecc_code[i] = 0x00;

	/* Read back previous written data, if col > 0 */
	if (col) {
		NanD_Command (nand, NAND_CMD_READ0);
		if (nand->bus16) {
			NanD_Address (nand, ADDR_COLUMN_PAGE,
				      (page << nand->page_shift) + (col >> 1));
		} else {
			NanD_Address (nand, ADDR_COLUMN_PAGE,
				      (page << nand->page_shift) + col);
		}

		if (nand->bus16) {
			u16 val;

			for (i = 0; i < col; i += 2) {
				val = READ_NAND (nandptr);
				nand->data_buf[i] = val & 0xff;
				nand->data_buf[i + 1] = val >> 8;
			}
		} else {
			for (i = 0; i < col; i++)
				nand->data_buf[i] = READ_NAND (nandptr);
		}
	}

	/* Calculate and write the ECC if we have enough data */
	if ((col < nand->eccsize) && (last >= nand->eccsize)) {
		nand_calculate_ecc (&nand->data_buf[0], &(ecc_code[0]));
		for (i = 0; i < 3; i++) {
			nand->data_buf[(nand->oobblock +
					oob_config.ecc_pos[i])] = ecc_code[i];
		}
		if (oob_config.eccvalid_pos != -1) {
			nand->data_buf[nand->oobblock +
				       oob_config.eccvalid_pos] = 0xf0;
		}
	}

	/* Calculate and write the second ECC if we have enough data */
	if ((nand->oobblock == 512) && (last == nand->oobblock)) {
		nand_calculate_ecc (&nand->data_buf[256], &(ecc_code[3]));
		for (i = 3; i < 6; i++) {
			nand->data_buf[(nand->oobblock +
					oob_config.ecc_pos[i])] = ecc_code[i];
		}
		if (oob_config.eccvalid_pos != -1) {
			nand->data_buf[nand->oobblock +
				       oob_config.eccvalid_pos] &= 0x0f;
		}
	}
#endif
	/* Prepad for partial page programming !!! */
	for (i = 0; i < col; i++)
		nand->data_buf[i] = 0xff;

	/* Postpad for partial page programming !!! oob is already padded */
	for (i = last; i < nand->oobblock; i++)
		nand->data_buf[i] = 0xff;

	/* Send command to begin auto page programming */
	//NanD_Command (nand, NAND_CMD_READ0);
	//NanD_Command (nand, NAND_CMD_SEQIN);
	if (nand->bus16) {
		NanD_Address (nand, ADDR_COLUMN_PAGE,
			      (page << nand->page_shift) + (col >> 1));
	} else {
		NanD_Address (nand, ADDR_COLUMN_PAGE,
			      (page << nand->page_shift) + col);
	}

	/* Write out complete page of data */
	if (nand->bus16) {
		for (i = 0; i < (nand->oobblock + nand->oobsize); i += 2) {
			WRITE_NAND (nand->data_buf[i] +
				    (nand->data_buf[i + 1] << 8),
				    nand->IO_ADDR);
		}
	} else {
		for (i = 0; i < (nand->oobblock + nand->oobsize); i++)
			WRITE_NAND (nand->data_buf[i], nand->IO_ADDR);
	}

	/* Send command to actually program the data */
	//NanD_Command (nand, NAND_CMD_PAGEPROG);
	//NanD_Command (nand, NAND_CMD_STATUS);
#ifdef NAND_NO_RB
	{
		u_char ret_val;

		do {
			ret_val = READ_NAND (nandptr);	/* wait till ready */
		} while ((ret_val & 0x40) != 0x40);
	}
#endif
	/* See if device thinks it succeeded */
	if (READ_NAND (nand->IO_ADDR) & 0x01) {
		printf ("%s: Failed write, page 0x%08x, ", __FUNCTION__,
			page);
		return -1;
	}
#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
	/*
	 * The NAND device assumes that it is always writing to
	 * a cleanly erased page. Hence, it performs its internal
	 * write verification only on bits that transitioned from
	 * 1 to 0. The device does NOT verify the whole page on a
	 * byte by byte basis. It is possible that the page was
	 * not completely erased or the page is becoming unusable
	 * due to wear. The read with ECC would catch the error
	 * later when the ECC page check fails, but we would rather
	 * catch it early in the page write stage. Better to write
	 * no data than invalid data.
	 */

	/* Send command to read back the page */
	if (col < nand->eccsize)
		NanD_Command (nand, NAND_CMD_READ0);
	else
		NanD_Command (nand, NAND_CMD_READ1);
	if (nand->bus16) {
		NanD_Address (nand, ADDR_COLUMN_PAGE,
			      (page << nand->page_shift) + (col >> 1));
	} else {
		NanD_Address (nand, ADDR_COLUMN_PAGE,
			      (page << nand->page_shift) + col);
	}

	/* Loop through and verify the data */
	if (nand->bus16) {
		for (i = col; i < last; i = +2) {
			if ((nand->data_buf[i] +
			     (nand->data_buf[i + 1] << 8)) != READ_NAND (nand->IO_ADDR)) {
				printf ("%s: Failed write verify, page 0x%08x ",
					__FUNCTION__, page);
				return -1;
			}
		}
	} else {
		for (i = col; i < last; i++) {
			if (nand->data_buf[i] != READ_NAND (nand->IO_ADDR)) {
				printf ("%s: Failed write verify, page 0x%08x ",
					__FUNCTION__, page);
				return -1;
			}
		}
	}

#ifdef CONFIG_MTD_NAND_ECC
	/*
	 * We also want to check that the ECC bytes wrote
	 * correctly for the same reasons stated above.
	 */
	NanD_Command (nand, NAND_CMD_READOOB);
	if (nand->bus16) {
		NanD_Address (nand, ADDR_COLUMN_PAGE,
			      (page << nand->page_shift) + (col >> 1));
	} else {
		NanD_Address (nand, ADDR_COLUMN_PAGE,
			      (page << nand->page_shift) + col);
	}
	if (nand->bus16) {
		for (i = 0; i < nand->oobsize; i += 2) {
			u16 val;

			val = READ_NAND (nand->IO_ADDR);
			nand->data_buf[i] = val & 0xff;
			nand->data_buf[i + 1] = val >> 8;
		}
	} else {
		for (i = 0; i < nand->oobsize; i++) {
			nand->data_buf[i] = READ_NAND (nand->IO_ADDR);
		}
	}
	for (i = 0; i < ecc_bytes; i++) {
		if ((nand->data_buf[(oob_config.ecc_pos[i])] != ecc_code[i]) && ecc_code[i]) {
			printf ("%s: Failed ECC write "
				"verify, page 0x%08x, "
				"%6i bytes were succesful\n",
				__FUNCTION__, page, i);
			return -1;
		}
	}
#endif	/* CONFIG_MTD_NAND_ECC */
#endif	/* CONFIG_MTD_NAND_VERIFY_WRITE */
	return 0;
}
#endif
#if 0
static int nand_write_ecc (struct nand_chip* nand, size_t to, size_t len,
			   size_t * retlen, const u_char * buf, u_char * ecc_code)
{
	int i, page, col, cnt, ret = 0;

	/* Do not allow write past end of device */
	if ((to + len) > nand->totlen) {
		printf ("%s: Attempt to write past end of page\n", __FUNCTION__);
		return -1;
	}

	/* Shift to get page */
	page = ((int) to) >> nand->page_shift;

	/* Get the starting column */
	col = to & (nand->oobblock - 1);

	/* Initialize return length value */
	*retlen = 0;

	/* Select the NAND device */
#ifdef CONFIG_OMAP1510
	archflashwp(0,0);
#endif
#ifdef CFG_NAND_WP
	NAND_WP_OFF();
#endif

    	NAND_ENABLE_CE(nand, 0);  /* set pin low */

	/* Check the WP bit */
	/*NanD_Command(nand, NAND_CMD_STATUS);*/
	if (!(nand_read_status(NAND_STATUS) & 0x80)) {
		printf ("%s: Device is write protected!!!\n", __FUNCTION__);
		ret = -1;
		goto out;
	}

	/* Loop until all data is written */
	while (*retlen < len) {
		/* Invalidate cache, if we write to this page */
		if (nand->cache_page == page)
			nand->cache_page = -1;

		/* Write data into buffer */
		if ((col + len) >= nand->oobblock) {
			for (i = col, cnt = 0; i < nand->oobblock; i++, cnt++) {
				nand->data_buf[i] = buf[(*retlen + cnt)];
			}
		} else {
			for (i = col, cnt = 0; cnt < (len - *retlen); i++, cnt++) {
				nand->data_buf[i] = buf[(*retlen + cnt)];
			}
		}
		/* We use the same function for write and writev !) */
		/*ret = nand_write_page (nand, page, col, i, ecc_code);*/
		ret = nand_page_program(nand, page, (unsigned int)nand->data_buf, i);
		if (ret < 0 || ret & 0x01)
			goto out;

		/* Next data start at page boundary */
		col = 0;

		/* Update written bytes count */
		*retlen += cnt;

		/* Increment page address */
		page++;
	}

	/* Return happy */
	*retlen = len;

out:
	/* De-select the NAND device */
	NAND_DISABLE_CE(nand);  /* set pin high */
#ifdef CONFIG_OMAP1510
    	archflashwp(0,1);
#endif
#ifdef CFG_NAND_WP
	NAND_WP_ON();
#endif

	return ret;
}

/* read from the 16 bytes of oob data that correspond to a 512 byte
 * page or 2 256-byte pages.
 */
static int nand_read_oob(struct nand_chip* nand, size_t ofs, size_t len,
			 size_t * retlen, u_char * buf)
{
	/*int len256 = 0;*/
	struct Nand *mychip;
	int ret = 0;

	mychip = &nand->chips[ofs >> nand->chipshift];

	/* update address for 2M x 8bit devices. OOB starts on the second */
	/* page to maintain compatibility with nand_read_ecc. */
	/*if (nand->page256) {
		if (!(ofs & 0x8))
			ofs += 0x100;
		else
			ofs -= 0x8;
	}*/

	NAND_ENABLE_CE(nand, 0);  /* set pin low */
	/*NanD_Command(nand, NAND_CMD_READOOB);
	if (nand->bus16) {
 		NanD_Address(nand, ADDR_COLUMN_PAGE,
			     ((ofs >> nand->page_shift) << nand->page_shift) +
 				((ofs & (nand->oobblock - 1)) >> 1));
	} else {
		NanD_Address(nand, ADDR_COLUMN_PAGE, ofs);
	}*/
	if (nand->oobblock >= 2048) {
		pNFCRegs->NFCR9|= 0x2;/* read sidinfo */
		ret = nand->nfc_read_page(nand,
		ofs + (pNFCRegs->NFCR9&0x2),
		(unsigned int)&buf[0], 32);
	} else {
		ret = nand->nfc_read_page(nand, ofs,
		(unsigned int)nand->data_buf, nand->oobblock);

		memcpy(buf, (unsigned char *)&pNFCRegs->FIFO[0], 16);
	}
	
	if (ret) {
		printf("Read oob failed ret=%d at addr %x\n", ret, ofs);
		return ret;
	}
	if (nand->oobblock >= 2048)
		pNFCRegs->NFCR9 &= 0xFFFFFFFD;    /* return to default value */


	/* treat crossing 8-byte OOB data for 2M x 8bit devices */
	/* Note: datasheet says it should automaticaly wrap to the */
	/*       next OOB block, but it didn't work here. mf.      */
	/*if (nand->page256 && ofs + len > (ofs | 0x7) + 1) {
		len256 = (ofs | 0x7) + 1 - ofs;
		NanD_ReadBuf(nand, buf, len256);

		NanD_Command(nand, NAND_CMD_READOOB);
		NanD_Address(nand, ADDR_COLUMN_PAGE, ofs & (~0x1ff));
	}*/

	/*NanD_ReadBuf(nand, &buf[len256], len - len256);*/

	*retlen = len;
	/* Reading the full OOB data drops us off of the end of the page,
	 * causing the flash device to go into busy mode, so we need
	 * to wait until ready 11.4.1 and Toshiba TC58256FT nands */

	/*ret = NanD_WaitReady(nand, 1);*/
	NAND_DISABLE_CE(nand);  /* set pin high */

	return ret;
}

/* write to the 16 bytes of oob data that correspond to a 512 byte
 * page or 2 256-byte pages.
 */
static int nand_write_oob(struct nand_chip* nand, size_t ofs, size_t len,
		  size_t * retlen, const u_char * buf)
{
	int len256 = 0;
	int i;
	unsigned long nandptr = nand->IO_ADDR;

#ifdef PSYCHO_DEBUG
	printf("nand_write_oob(%lx, %d): %2.2X %2.2X %2.2X %2.2X ... %2.2X %2.2X .. %2.2X %2.2X\n",
	       (long)ofs, len, buf[0], buf[1], buf[2], buf[3],
	       buf[8], buf[9], buf[14],buf[15]);
#endif

	NAND_ENABLE_CE(nand, 0);  /* set pin low to enable chip */

	/* Reset the chip */
	/*NanD_Command(nand, NAND_CMD_RESET);*/

	/* issue the Read2 command to set the pointer to the Spare Data Area. */
	/*NanD_Command(nand, NAND_CMD_READOOB);
	if (nand->bus16) {
 		NanD_Address(nand, ADDR_COLUMN_PAGE,
			     ((ofs >> nand->page_shift) << nand->page_shift) +
 				((ofs & (nand->oobblock - 1)) >> 1));
	} else {
 		NanD_Address(nand, ADDR_COLUMN_PAGE, ofs);
	}*/

	/* update address for 2M x 8bit devices. OOB starts on the second */
	/* page to maintain compatibility with nand_read_ecc. */
	/*if (nand->page256) {
		if (!(ofs & 0x8))
			ofs += 0x100;
		else
			ofs -= 0x8;
	}*/

	/* issue the Serial Data In command to initial the Page Program process */
	/*NanD_Command(nand, NAND_CMD_SEQIN);
	if (nand->bus16) {
 		NanD_Address(nand, ADDR_COLUMN_PAGE,
			     ((ofs >> nand->page_shift) << nand->page_shift) +
 				((ofs & (nand->oobblock - 1)) >> 1));
	} else {
 		NanD_Address(nand, ADDR_COLUMN_PAGE, ofs);
	}*/

	/* treat crossing 8-byte OOB data for 2M x 8bit devices */
	/* Note: datasheet says it should automaticaly wrap to the */
	/*       next OOB block, but it didn't work here. mf.      */
	if (nand->page256 && ofs + len > (ofs | 0x7) + 1) {
		len256 = (ofs | 0x7) + 1 - ofs;
		for (i = 0; i < len256; i++)
			WRITE_NAND(buf[i], nandptr);

		NanD_Command(nand, NAND_CMD_PAGEPROG);
		NanD_Command(nand, NAND_CMD_STATUS);
#ifdef NAND_NO_RB
   		{ u_char ret_val;
			do {
				ret_val = READ_NAND(nandptr); /* wait till ready */
			} while ((ret_val & 0x40) != 0x40);
		}
#endif
		if (READ_NAND(nandptr) & 1) {
			puts ("Error programming oob data\n");
			/* There was an error */
			NAND_DISABLE_CE(nand);  /* set pin high */
			*retlen = 0;
			return -1;
		}
		NanD_Command(nand, NAND_CMD_SEQIN);
		NanD_Address(nand, ADDR_COLUMN_PAGE, ofs & (~0x1ff));
	}

	if (nand->bus16) {
		for (i = len256; i < len; i += 2) {
			WRITE_NAND(buf[i] + (buf[i+1] << 8), nandptr);
		}
	} else {
		for (i = len256; i < len; i++)
			WRITE_NAND(buf[i], nandptr);
	}

	NanD_Command(nand, NAND_CMD_PAGEPROG);
	NanD_Command(nand, NAND_CMD_STATUS);
#ifdef NAND_NO_RB
	{	u_char ret_val;
		do {
			ret_val = READ_NAND(nandptr); /* wait till ready */
		} while ((ret_val & 0x40) != 0x40);
	}
#endif
	if (READ_NAND(nandptr) & 1) {
		puts ("Error programming oob data\n");
		/* There was an error */
		NAND_DISABLE_CE(nand);  /* set pin high */
		*retlen = 0;
		return -1;
	}

	NAND_DISABLE_CE(nand);  /* set pin high */
	*retlen = len;
	return 0;

}
#endif
int nand_erase(struct nand_chip* nand, size_t ofs, size_t len, int clean)
{
	/* This is defined as a structure so it will work on any system
	 * using native endian jffs2 (the default).
	 */
/*	static struct jffs2_unknown_node clean_marker = {
		JFFS2_MAGIC_BITMASK,
		JFFS2_NODETYPE_CLEANMARKER,
		8		*//* 8 bytes in this node */
/*	};*/
	unsigned long nandptr;
	struct Nand *mychip;
	int ret = 0;
	if ((ofs & (nand->erasesize-1)) || (len & (nand->erasesize-1))) {
		printf ("Offset and size must be sector aligned, ofs = 0x%x, erasesize = %d len=0x%x\n",
			(int)ofs, (int) nand->erasesize, (int) len);
		return -1;
	}

	nandptr = nand->IO_ADDR;

	/* Select the NAND device */
#ifdef CONFIG_OMAP1510
	archflashwp(0,0);
#endif
#ifdef CFG_NAND_WP
	NAND_WP_OFF();
#endif
    NAND_ENABLE_CE(nand, 0);  /* set pin low */

	/* Check the WP bit */
	/*NanD_Command(nand, NAND_CMD_STATUS);*/
	if (!(nand_read_status(NAND_STATUS) & 0x80)) {
		printf ("nand_write_ecc: Device is write protected!!!\n");
		ret = -1;
		goto out;
	}

	/* Check the WP bit */
	/*NanD_Command(nand, NAND_CMD_STATUS);*/
	if (!(nand_read_status(NAND_STATUS) & 0x80)) {
		printf ("%s: Device is write protected!!!\n", __FUNCTION__);
		ret = -1;
		goto out;
	}
	if (check_block_table(nand, 0)) {
			NAND_DISABLE_CE(nand);  /* set pin high */
			return -1;
		}
	/* FIXME: Do nand in the background. Use timers or schedule_task() */
	while(len) {
		/*mychip = &nand->chips[shr(ofs, nand->chipshift)];*/
		mychip = &nand->chips[ofs >> nand->chipshift];

		/* always check for bad block first, genuine bad blocks
		 * should _never_  be erased.
		 */
		/*if (ALLOW_ERASE_BAD_DEBUG || !check_block(nand, ofs)) {*/
		if (ALLOW_ERASE_BAD_DEBUG || !nand->isbadblock(nand, ofs/nand->erasesize, 0)) {
			/* Select the NAND device */
			NAND_ENABLE_CE(nand, 0);  /* set pin low */

			//WMTEraseNAND(ofs/nand->erasesize, len/nand->erasesize, 0);
			ret = wmt_nand_erase(nand, ofs/nand->erasesize);
			/*printf ("erase finish ofs = 0x%x, ret = 0x%x len=0x%x\n",
			(int)ofs, (int) ret, (int) len);*/
/*		NanD_Command(nand, NAND_CMD_ERASE1);
			NanD_Address(nand, ADDR_PAGE, ofs);
			NanD_Command(nand, NAND_CMD_ERASE2);

			NanD_Command(nand, NAND_CMD_STATUS);
*/
#ifdef NAND_NO_RB
			{	u_char ret_val;
				do {
					ret_val = READ_NAND(nandptr); /* wait till ready */
				} while ((ret_val & 0x40) != 0x40);
			}
#endif
			if (ret < 0 || (ret&1)) {
				printf ("%s: Error erasing at 0x%lx\n",
					__FUNCTION__, (long)ofs);
				/* There was an error */
				ret = -1;
				goto out;
			} else
				ret = 0;
			if (clean) {
				/*int n;*/	/* return value not used */
				int p, l;

				/* clean marker position and size depend
				 * on the page size, since 256 byte pages
				 * only have 8 bytes of oob data
				 */
				if (nand->page256) {
					p = NAND_JFFS2_OOB8_FSDAPOS;
					l = NAND_JFFS2_OOB8_FSDALEN;
				} else {
					p = NAND_JFFS2_OOB16_FSDAPOS;
					l = NAND_JFFS2_OOB16_FSDALEN;
				}

				/*ret = nand_write_oob(nand, ofs + p, l, (size_t *)&n,
						     (u_char *)&clean_marker);*/
				/* quit here if write failed */
				/*if (ret)
					goto out;*/
			}
		}
		ofs += nand->erasesize;
		len -= nand->erasesize;
	}

out:
	/* De-select the NAND device */
	NAND_DISABLE_CE(nand);  /* set pin high */
#ifdef CONFIG_OMAP1510
    	archflashwp(0,1);
#endif
#ifdef CFG_NAND_WP
	NAND_WP_ON();
#endif

	return ret;
}

//get eslc and retry value
int get_parameter(struct nand_chip *nand, unsigned char *buf, unsigned char * offset, int num)
{
	int i, /*k,*/ status = -1;
	unsigned int cfg, reg_num = num;
	unsigned char *FIFO = (unsigned char *) &pNFCRegs->FIFO[48];
	unsigned char para[16] = {0};

	for (i = 0; i < reg_num; i++) {
		if (nfc_dma_cfg((unsigned int)&para[i], 1, 0))
			return -1;
		pNFCRegs->NFCRd |= HIGH64FIFO;
		if (i == 0) {
			FIFO[0] = NAND_GET_PARAM;
			FIFO[1] = offset[i];
			/*printf("FIFO:");
			for (k=0;k<2;k++)
				printf("[%d]=0x%x ", k, FIFO[k]);
			printf("\n");*/
			// set address latch ALE(high) and CLE(lower)	
			pNFCRegs->NFCRc = 0x00020001;
			cfg = (0x02<<1);
		} else {
			FIFO[0] = offset[i];
			// set address latch ALE(high) and CLE(lower)
			pNFCRegs->NFCRc = 0x00010000;
			cfg = (0x01<<1);
		}
		pNFCRegs->NFCR1 = NAND2NFC|cfg|NFC_TRIGGER;	 /* cfg & start*/

		/* wait command/address to finished */
		status = NFC_WAIT_CMD_READY();
		if (status) {
			printf("retry c1 wait cmd/addr ready time out\n");
			return status;
		}
	
		status = NFC_WAIT_READY();
		if (status) {
			printf("retry wait NFC ready time out\n");
			return status;
		}

		status = nand_pdma_handler();
		nand_free_pdma();
		if (status)
			return status;
	}
	status = NAND_WAIT_IDLE();
	if (status) {
		printf("retry c1 wait idle time out\n");
		return status;
	}
	pNFCRegs->NFCRd &= ~HIGH64FIFO;

//	printf("retry start cmd end para = 0x%x %x %x %x %x\n", para[0], para[1], para[2], para[3], para[4]);	
	for(i = 0; i < reg_num; i++) {
		buf[i] = para[i];
	}

	return 0;
}

/*
int my_get_parameter(struct nand_chip *nand)
{
	unsigned char offset[5] = {0xa0, 0xa1, 0xb2, 0xb1, 0xc9};
	unsigned char buf[16] = {0};
	NAND_ENABLE_CE(nand, 0);
	get_parameter(nand, buf, offset, 5);
	NAND_DISABLE_CE(nand);
	printf("%x %x %x %x %x\n", buf[0], buf[1], buf[2], buf[3], buf[4]);

}
*/

int hynix_get_parameter(struct nand_chip *nand, int mode)
{
	unsigned char buf[16] = {0};
	unsigned char *offset = NULL;
	unsigned char *set_value = NULL;
	unsigned char *def_value = NULL;
	unsigned int reg_num;
	int i = 0, j = 0;
	int rc = -1;

	if(mode == ESLC_MODE) {
		reg_num = cur_chip->eslc_reg_num;
		offset = cur_chip->eslc_offset;
		def_value = cur_chip->eslc_def_value;
		set_value = cur_chip->eslc_set_value;
	} else if(mode == READ_RETRY_MODE){
		reg_num = cur_chip->retry_reg_num;
		offset = cur_chip->retry_offset;
		def_value = cur_chip->retry_def_value;
	} else {
		printf("Not support this mode %d\n", mode);
		return rc;
	}

	rc = get_parameter(nand, buf, offset, reg_num);
	if(rc != 0)
		return rc;

	if(mode == ESLC_MODE) {
		if((def_value[reg_num] != 0xff) && (def_value[reg_num + 1] != 0xff)) {
			for(i = 0; i < reg_num; i++) {
				def_value[i] = buf[i];
				set_value[i] += buf[i];
			}
			def_value[reg_num] = 0xff;
			def_value[reg_num + 1] = 0xff;
		} else {
			printf("ESLC Current: ");
			for(i = 0; i < reg_num; i++)
				printf("0x%x ", buf[i]);
			printf("\n");
		}
	} else if(mode == READ_RETRY_MODE) {
		if((def_value[reg_num] != 0xff) && (def_value[reg_num + 1] != 0xff)) {
			for(i = 0; i < reg_num; i++)
				def_value[i] = buf[i];
			def_value[reg_num] = 0xff;
			def_value[reg_num + 1] = 0xff;
		} else {
			/*printf("Retry Current: ");
			for(i = 0; i < reg_num; i++) 
				printf("0x%x ", buf[i]);
			printf("\n");*/
			for (j = 0; j < cur_chip->total_try_times; j++) {
				for (i = 0; i < reg_num; i++) {
					if (buf[i] != cur_chip->retry_value[j*reg_num+i])
						break;
				}
				//printf("i = %d\n", i);
				if (i == reg_num) {
					cur_chip->cur_try_times = j;
					printf("Get current try times %d from kernel.\n", j);
					break;
				}
			}
		}
	} 
	return rc;
}

int set_parameter(struct nand_chip *nand,  unsigned char *buf, unsigned char *offset, int regn)
{

	int i, status = -1/*, k*/;
	unsigned int cfg;
	unsigned char *FIFO = (unsigned char *) &pNFCRegs->FIFO[48];
	unsigned int reg_num = regn;

	for (i = 0; i < (reg_num+1);i++) {
		if (i < reg_num) {
			if (nfc_dma_cfg((unsigned int)&buf[i], 1, 1))
				return -1;
		}

//		printf("retry c1 p2 i=%d mode = %d\n", i, mode);
		pNFCRegs->NFCRd |= HIGH64FIFO;
		if (i == 0) {
			FIFO[0] = 0x36;
			FIFO[1] = offset[i];
			/*printf("FIFO:");
			for (k=0;k<2;k++)
				printf("[%d]=0x%x ", k, FIFO[k]);
			printf("\n");*/
			// set address latch ALE(high) and CLE(lower)	
			pNFCRegs->NFCRc = 0x00020001;
			cfg = (0x02<<1);
			pNFCRegs->NFCR1 = cfg|NFC_TRIGGER;	 /* cfg & start*/
		} else if (i < reg_num) {
			FIFO[0] = offset[i];
			// set address latch ALE(high) and CLE(lower)	
			pNFCRegs->NFCRc = 0x00010000;
			cfg = (0x01<<1);
			pNFCRegs->NFCR1 = cfg|NFC_TRIGGER;	 /* cfg & start*/
		} else {
			FIFO[0] = 0x16;
			pNFCRegs->NFCRc = 0x00000001;
			cfg = (0x01<<1);
			pNFCRegs->NFCR1 = DPAHSE_DISABLE|cfg|NFC_TRIGGER;	 /* cfg & start*/
		}

		/* wait command/address to finished */
		status = NFC_WAIT_CMD_READY();
		if (status) {
			printf("retry c1 wait cmd/addr ready time out\n");
			return status;
		}
		
		status = NFC_WAIT_READY();
		if (status) {
			printf("retry wait NFC ready time out\n");
			pNFCRegs->NFCRd &= ~HIGH64FIFO;
			return status;
		}

		if (i < reg_num) {	
			status = nand_pdma_handler();
			nand_free_pdma();
			if (status) {
				pNFCRegs->NFCRd &= ~HIGH64FIFO;
				return status;
			}
		}
	}
//	printf("\n retry c1 p5\n");
	status = NAND_WAIT_IDLE();
	if (status) {
		pNFCRegs->NFCRd &= ~HIGH64FIFO;
		printf("retry c1 wait idle time out\n");
		return status;
	}
	pNFCRegs->NFCRd &= ~HIGH64FIFO;
//	printf("retry start cmd p1\n");
	return 0;
}

int dummy_read(struct nand_chip *nand)
{
	int status = -1;
	unsigned char buf[4];

	nfc_ecc_set(USE_SW_ECC, 0, nand);
	if (nfc_dma_cfg((unsigned int)buf, 4, 0))
		return -ERR_DMA_CFG;
	NanD_Address(nand, ADDR_COLUMN_PAGE, 0, 0);
	WRITE_NAND_COMMAND(NAND_READ0); /* set command cycle 1 */
	pNFCRegs->NFCRb |= B2R; /* write to clear */
	pNFCRegs->NFCR1 = DPAHSE_DISABLE|((nand->row+nand->col+1)<<1)|NFC_TRIGGER|0x400;
	if (NFC_WAIT_CMD_READY()) {
		set_ECC_mode(nand);
		return -ERR_NFC_CMD;
	}
	WRITE_NAND_COMMAND(NAND_READ_CONFIRM);
	pNFCRegs->NFCRb |= B2R; /* write to clear */
	pNFCRegs->NFCR1 = NAND2NFC|1<<1|NFC_TRIGGER|0x400;

	status = nand_pdma_handler();
	nand_free_pdma();
	if (status) {
		set_ECC_mode(nand);
		return status;
	}
	status = NAND_WAIT_IDLE();
	set_ECC_mode(nand);
	if (status) {
		printf("dummy read wait idle time out\n");
		return status;
	}
	return 0;
}


int hynix_set_parameter(struct nand_chip *nand, int mode, int def_value)
{
	unsigned char *offset = NULL;
	unsigned char *set_value = NULL;
	unsigned int reg_num;
	int rc = -1;


	if(mode == ESLC_MODE) {
		reg_num = cur_chip->eslc_reg_num;
		offset = cur_chip->eslc_offset;
		if(def_value == ECC_ERROR_VALUE) {
			set_value = cur_chip->eslc_set_value;
		} else {
			set_value = cur_chip->eslc_def_value;
		}
	} else {
		reg_num = cur_chip->retry_reg_num;
		offset = cur_chip->retry_offset;
		if(def_value == ECC_ERROR_VALUE) {
			cur_chip->cur_try_times++;
			if(cur_chip->cur_try_times >= cur_chip->total_try_times)
				cur_chip->cur_try_times = -1;
			if((cur_chip->cur_try_times >= 0) && (cur_chip->cur_try_times < cur_chip->total_try_times))
				set_value = cur_chip->retry_value + cur_chip->cur_try_times* cur_chip->retry_reg_num;
			else 
				set_value = cur_chip->retry_def_value;
		} else {
			set_value = cur_chip->retry_def_value;
			cur_chip->cur_try_times = -1;
		}
	}

#if 0
	printf("set value:\n");
	for(rc = 0; rc < reg_num; rc++)
		printf(" 0x%x:0x%x ", offset[rc], set_value[rc]);
	printf("reg_num = %d\n", reg_num);
#endif
	
	rc = set_parameter(nand, set_value, offset, reg_num);
	if(rc) {
		printf("set_parameter fail.\n");
		return rc;
	}

	//if(def_value == DEFAULT_VALUE && mode == ESLC_MODE)
		dummy_read(nand);

	return rc;
}

int nand_reset_no_read_status(unsigned int cmd)                                                                        
{
    int status = 0;

    pNFCRegs->NFCR2 = cmd; /* set command  */
    pNFCRegs->NFCRb |= B2R; /* write to clear*/
    pNFCRegs->NFCR1 = DPAHSE_DISABLE|(1<<1)|NFC_TRIGGER|0x400;
    status = NAND_WAIT_READY();
    if (status) {
        printf("NFCR11 chip enable 0x%x\r\n", pNFCRegs->NFCR11);
        printf("\r\n reset wait busy status = 0x%x\r\n", status);
        return status;
    }
    return status;
}

int write_bytes_param(int cmd_cnt, int addr_cnt, int data_cnt, uchar *cmd, uchar *addr, uchar *data)
{
    int i, status = 0;
    unsigned int cmd_addr_cycle = 0, cfg = 0, cfg_bit8 = 0;
    unsigned char *FIFO = (unsigned char *)&pNFCRegs->FIFO[48];

    if (data_cnt > 0) {
        if (nfc_dma_cfg((unsigned int)data, 1, 1))
            return -4;
    }
    pNFCRegs->NFCRd |= HIGH64FIFO;
    for (i = 0; i < cmd_cnt; i++) {
        FIFO[i] = cmd[i];
        cmd_addr_cycle |= (1<<i);
    }

    for (i = cmd_cnt; i < (addr_cnt+cmd_cnt); i++) {
        FIFO[i] = addr[i-cmd_cnt];
        cmd_addr_cycle |= (1<<(i+16));
    }
    pNFCRegs->NFCRc = cmd_addr_cycle;
    printf("FIFO = ");
    for (i = 0; i < (addr_cnt+cmd_cnt); i++)
        printf("0x%x ", FIFO[i]);
    if (data_cnt > 0) 
        printf("data = 0x%x\n", data[0]);
    printf(" NFCRc=0x%x\n", cmd_addr_cycle);
    cfg = ((cmd_cnt + addr_cnt)&0x7)<<1;
    cfg_bit8 = (((cmd_cnt + addr_cnt)&0x18)>>3)<<8;
                                                                                                                                             
    if (data_cnt > 0)
        pNFCRegs->NFCR1 = cfg_bit8|cfg|NFC_TRIGGER;  /* cfg & start*/
    else
        pNFCRegs->NFCR1 = DPAHSE_DISABLE|cfg_bit8|cfg|NFC_TRIGGER; /* cfg & start*/

    /* wait command/address to finished */
    status = NFC_WAIT_CMD_READY();
    if (status) {
        printf("retry c1 wait cmd/addr ready time out\n");
        goto go_fail;
    }
        
    status = NFC_WAIT_READY();
    if (status) {
        printf("retry wait NFC ready time out\n");
        goto go_fail;
    }

    status = NAND_WAIT_IDLE();
    if (status) {
        printf("retry c1 wait idle time out\n");
        goto go_fail;
    }

    if (data_cnt > 0) {
        status = nand_pdma_handler();
        nand_free_pdma();
        if (status) {
            goto go_fail;
        }
    }

go_fail:
    pNFCRegs->NFCRd &= ~HIGH64FIFO;
    return status;
}


int toshiba_send_data(void)
{
    unsigned int i = 0, j,/*k,*/ cfg;
    int status = -1;
    unsigned char *FIFO = (unsigned char *)&pNFCRegs->FIFO[48];
	unsigned char *set_value = NULL;
	unsigned char *offset = NULL;

//	printf("FIFO#0x%x, cur_try_times = %d, reg_num = %d\n", &pNFCRegs->FIFO[48], cur_chip->cur_try_times, cur_chip->retry_reg_num);
	set_value = cur_chip->retry_value + cur_chip->cur_try_times*cur_chip->retry_reg_num;
	offset = cur_chip->retry_offset;

	cur_chip->cur_try_times++;
	if(cur_chip->cur_try_times >= cur_chip->total_try_times)
		cur_chip->cur_try_times = 0;

    //printf("Set parameter: retry c1 p1\n");
    for (i=0,j=4;i<4;i++,j++) {
        if (nfc_dma_cfg((unsigned int)&set_value[i], 1, 1))
            return -4;
        pNFCRegs->NFCRd |= HIGH64FIFO;
        FIFO[0] = 0x55;
        FIFO[1] = offset[i];
        /*printf("FIFO:");
        for (k=0;k<2;k++)
            printf("[%d]=0x%x ", k, FIFO[k]);
        printf("\n");*/
        // set address latch ALE(high) and CLE(lower)
        pNFCRegs->NFCRc = 0x00020001;
        cfg = (0x02<<1);
        pNFCRegs->NFCR1 = cfg|NFC_TRIGGER;   /* cfg & start*/

        /* wait command/address to finished */
        status = NFC_WAIT_CMD_READY();
        if (status) {
            printf("retry c1 wait cmd/addr ready time out\n");
            return status;
        }
        
        status = NFC_WAIT_READY();
        if (status) {
            printf("retry wait NFC ready time out\n");
            return status;
        }
            
        status = nand_pdma_handler();
        nand_free_pdma();
        if (status)
            return status;
    }
    printf("retry c1 p5\n");
    status = NAND_WAIT_IDLE();
    if (status) {
        printf("retry c1 wait idle time out\n");                                                                                             
        return status;
    }
	printf("set parameter end.\n");
	return status;
}

int toshiba_pre_condition(void)
{
	int cfg;
    int status = 0;
	unsigned char cmd1[2] = {0x5c, 0xc5};

	pNFCRegs->NFCR2 = cmd1[0];
	pNFCRegs->NFCR3 = 0xff00;
	cfg = DPAHSE_DISABLE|(0x02<<1);
	pNFCRegs->NFCR1 = cfg|NFC_TRIGGER|0x400;	 /* cfg & start */
	status = NFC_WAIT_READY();
	if (status)
		return status;
	pNFCRegs->NFCR2 = cmd1[1];
	pNFCRegs->NFCR3 = 0xff00;
	cfg = DPAHSE_DISABLE|(0x02<<1);
	pNFCRegs->NFCR1 = cfg|NFC_TRIGGER|0x400;	 /* cfg & start */
	status = NFC_WAIT_READY();
	if (status)
		return status;
	printf("toshiba_pre_condition OK.\n");
	return status;
}

int toshiba_set_parameter(struct nand_chip *nand, int mode, int def_mode)
{
	int cfg;
    int status = 0;
	unsigned char cmd2[2] = {0x26, 0x5d};

	status = toshiba_send_data();
    if (status) {
        printf("pre condition cmd2 time out\n");
        return status;
    }
	pNFCRegs->NFCR2 = cmd2[0];
	pNFCRegs->NFCR3 = 0xff00;
	cfg = DPAHSE_DISABLE|(0x02<<1);
	pNFCRegs->NFCR1 = cfg|NFC_TRIGGER|0x400;	 /* cfg & start */
	status = NFC_WAIT_READY();
	if (status)
		return status;
	pNFCRegs->NFCR2 = cmd2[1];
	pNFCRegs->NFCR3 = 0xff00;
	cfg = DPAHSE_DISABLE|(0x02<<1);
	pNFCRegs->NFCR1 = cfg|NFC_TRIGGER|0x400;	 /* cfg & start */
	status = NFC_WAIT_READY();
	if (status)
		return status; 

	return status;
}

int hynix_get_otp(struct nand_chip *nand)
{
    int i, j, status = -1;
    unsigned char cmd[5] = {0x36, 0x16, 0x17, 0x04, 0x19};
	unsigned char *offset = cur_chip->otp_offset;
	unsigned char *data = cur_chip->otp_data;
    unsigned int page = 0x200;
    unsigned char reset = 0xFF, *buff, *buf;

    buf = nand->data_buf;
    printf("p0 offset: 0x%x, 0x%x\n", offset[0], offset[1]);
    status = nand_reset_no_read_status(reset);
    if (status) {
        printf("load_hynix_opt_reg: reset fail");
    }

    status = write_bytes_param(1, 1, 1, (uchar *)&cmd[0], (uchar *)&offset[0], (uchar *)&data[0]);
    if (status)
        printf("load_hynix_opt_reg: phase 1 fail");
    status = write_bytes_param(0, 1, 1, NULL, (uchar *)&offset[1], (uchar *)&data[1]);                                                    
    if (status)
        printf("load_hynix_opt_reg: phase 2 fail");
    status = write_bytes_param(4, 0, 0, (uchar *)&cmd[1], NULL, NULL);
    if (status)
        printf("load_hynix_opt_reg: phase 3 fail");
    nfc_ecc_set(USE_SW_ECC, ECC1bit, nand);
	status = nand->nfc_read_page(nand, page, (unsigned int)buf, 1026);
	set_ECC_mode(nand);
    if (status != 0) {
        printf("load_hynix_opt_reg: phase 3 fail status = %d\n", status);
        return -1;
    }
    status = nand_reset_no_read_status(reset);
    if (status) {
        printf("load_hynix_opt_reg: reset fail");
    }
    status = nand_reset_no_read_status(0x38);
    if (status) {
        printf("load_hynix_opt_reg: OTP end 0x38 fail");
    }
    //print_nand_buf((uchar *)buf, 1040);
    buff = (unsigned char *)buf;
    if (buff[0] > 8 || buff[1] > 8) {
        printf("retry_cmd buff is not big enough for size %d\n", buff[0]*buff[1]);
		return -1;
	}

    cur_chip->total_try_times = buff[0];
    cur_chip->retry_reg_num = buff[1];
    for (i = 0; i < buff[0]; i++) {
        for (j = 0; j < buff[1]; j++) {
			if(i == 0)
				cur_chip->retry_def_value[j] = buff[i*buff[1]+j+2];
			else 
		        cur_chip->retry_value[(i-1)*buff[1] + j] = buff[i*buff[1]+j+2];
			if ((buff[i*buff[1]+j+2] ^ buff[(buff[0]+i)*buff[1]+j+2]) != 0xFF)
				printf("inverse fail %x %x\n", buff[i*buff[1]+j+2], buff[(buff[0]+i)*buff[1]+j+2]);
        }
/*		if(i == 0)
			print_nand_buf(cur_chip->retry_def_value, buff[1]);
		else
            print_nand_buf(cur_chip->retry_value + (i-1)*buff[1], buff[1]);*/
    }
	cur_chip->total_try_times--;
                                                     
	//page read for Hardware Issue.
	nand->nfc_read_page(nand, page, (unsigned int)buf, nand->oobblock);
    return 0;
}


int toshiba_get_parameter(struct nand_chip *nand, int mode)
{
	return 0;
}



int read_retry_param_from_nand(struct nand_chip *nand, int chip)
{
	unsigned char *pbuf = nand->data_buf;
	int i = 0;//, j = 0;
	int index = 0;
	int rc = -1;
	int find = 0;
	struct nand_read_retry_param *p = NULL;
	int end_block = nand->dwBlockCount - 2*BBT_MAX_BLOCK;
	int start_block = nand->dwBlockCount - BBT_MAX_BLOCK -1;
	//unsigned char fifo[16];

	/*
	if(check_block_table(nand, 0)) {
		return -1;
	}*/

	NAND_ENABLE_CE(nand, chip);


	cur_chip->read_table = 1;
	for(i = start_block; i >= end_block; i--) {
		//printf("readretry block = %d\n", i);
		rc = nand->nfc_read_page(nand, i*nand->dwPageCount, (unsigned int)pbuf, nand->oobblock);
		if(rc) {
			printf("can't read nand default parameter from nand block %d page 0.\n", i);
			goto EXIT;
		}	
//		strncpy(fifo, pNFCRegs->FIFO, 16);
//		if(strncmp(pNFCRegs->FIFO, "retrytable", 10))
//			continue;
//		for(j = 0; j < sizeof(*p); j++)
//			printf("0x%x ", pbuf[j]);
		p = (struct nand_read_retry_param *)pbuf;
		if(!strncmp(p->magic, "readretry", 9) && (p->nand_id == nand->id) && (p->nand_id_5th == nand->id2)) {
			for(index = 0; index < cur_chip->eslc_reg_num; index++) {
				//printf("0x%x 0x%x 0x%x", p->eslc_offset[index], p->eslc_def_value[index], p->eslc_set_value[index]);
				//printf("\n");
				cur_chip->eslc_def_value[index] = p->eslc_def_value[index];
				cur_chip->eslc_set_value[index] = p->eslc_set_value[index];
			}
			//printf("\n");
			for(index = 0; index < cur_chip->retry_reg_num; index++) {
				//printf("0x%x 0x%x, 0x%x", p->retry_offset[index], p->retry_def_value[index], p->retry_value[index]);
				//printf("\n");
				cur_chip->retry_def_value[index] = p->retry_def_value[index];
			}
			//printf("\n");
			for(index = 0; index < cur_chip->retry_reg_num * cur_chip->total_try_times; index++) {
				//printf("0x%x ", p->retry_value[index]);
				cur_chip->retry_value[index] = p->retry_value[index];
			}
			//printf("\n");

			cur_chip->eslc_def_value[cur_chip->eslc_reg_num] = 0xff;
			cur_chip->eslc_def_value[cur_chip->eslc_reg_num+1] = 0xff;
			cur_chip->retry_def_value[cur_chip->retry_reg_num] = 0xff;
			cur_chip->retry_def_value[cur_chip->retry_reg_num+1] = 0xff;
			find = 1;
		} else {
			//uboot can't write default parameter, rc = -1, or rc = 1.
			rc = 1;
		}

		if(find == 1) {
			printf("sucess to read the nand default param.\n");
			rc = 0;
			break;
		}
	}
EXIT:
	cur_chip->read_table = 0;
	NAND_DISABLE_CE(nand);
	return rc;
}

int write_retry_param_to_nand(struct nand_chip *nand, int chip)
{
	unsigned char *pbuf = nand->data_buf;
	int i = 0;
	int rc = -1;
	unsigned char fifo[64];
	int end_block = nand->dwBlockCount - 2*BBT_MAX_BLOCK;
	int start_block = nand->dwBlockCount - BBT_MAX_BLOCK -1;

/*	if(check_block_table(nand, 0))
		return rc;*/

	memset(fifo, 0xff, 64);
	strcpy((char *)fifo, "retrytable");
	NAND_ENABLE_CE(nand, chip);

	//write default parameter in ESLC mode
	cur_chip->set_parameter(nand, ESLC_MODE, ECC_ERROR_VALUE);
	for(i = start_block; i >= end_block; i--) {
	/*	if(nand->isbadblock(nand, i, chip))
			continue;*/
		rc = nand_write_block(nand, (unsigned int)pbuf, i*nand->dwPageCount, 1, fifo);
		if(rc) {
			printf("can't write nand default parameter on block %d page 0.\n", i);
			continue;
		} else {
			printf("sucess to write nand default parameter on block %d page 0.\n", i);
			break;
		}
	}
	if(i == (end_block -1)) {
		printf("There is no good block for readretry parameter and readrety is disabled.\n");
		cur_chip->set_parameter(nand, ESLC_MODE, DEFAULT_VALUE);
		cur_chip = NULL;
	}
	if(cur_chip)	
		cur_chip->set_parameter(nand, ESLC_MODE, DEFAULT_VALUE);
	NAND_DISABLE_CE(nand);
	return rc;
}

static inline int nandcheck(unsigned long potential, unsigned long physadr)
{
	return 0;
}

int get_pattern_small(struct nand_chip *nand, unsigned int block, unsigned int *tag, unsigned int *version)
{
	unsigned int pos, pos1;
	unsigned char *buf;
	int rc = -1;
	buf = nand->data_buf;

	rc = nand->nfc_read_page(nand, (block*nand->dwPageCount), (unsigned int)buf,	nand->oobblock);
	if (rc) {
		printf("Read Tag failed rc=%d at page0x%x\n", rc, (block*nand->dwPageCount));
		return rc;
	}
	pos = NAND_SMALL_DWRESERVED1_OFS;
	pos1 = NAND_SMALL_DWRESERVED2_OFS;
	*tag = (pNFCRegs->FIFO[pos] << 24)|
	(pNFCRegs->FIFO[pos+1] << 16)|
	(pNFCRegs->FIFO[pos+2] << 8)|
	pNFCRegs->FIFO[pos+3];
	*version = pNFCRegs->FIFO[pos1]/*|
		(pNFCRegs->FIFO[pos1+1] << 8)|
		(pNFCRegs->FIFO[pos1+2] << 16)|
		(pNFCRegs->FIFO[pos1+3] << 24)*/;

	return 0;
}

int get_pattern_large(struct nand_chip *nand, unsigned int block, unsigned int *tag, unsigned int *version)
{
	unsigned int pos;
	unsigned char *buf;
	int rc = -1;

	pos = NAND_LARGE_DWRESERVED1_OFS;
	buf = nand->data_buf;
	rc = nand->nfc_read_page(nand, (block*nand->dwPageCount), (unsigned int)buf, nand->oobblock);
	if (rc) {
		printf("Read Tag failed rc=%d at page0x%x\n", rc, (block*nand->dwPageCount));
		return rc;
	}
	*tag = (pNFCRegs->FIFO[pos] << 24)|
	(pNFCRegs->FIFO[pos+1] << 16)|
	(pNFCRegs->FIFO[pos+2] << 8)|
	pNFCRegs->FIFO[pos+3];
	pos = NAND_LARGE_DWRESERVED2_OFS;

	*version = pNFCRegs->FIFO[pos];
	return 0;
}

int WMT_check_pattern(struct nand_chip *nand, unsigned int block, unsigned int *type, unsigned int *version)
{
	unsigned int tag = 0;

	*type = 0;
	if (nand->oobblock > 0x200)
		get_pattern_large(nand, block, &tag, version);
	else
		get_pattern_small(nand, block, &tag, version);
	printf("block%d tag=%x ", block, tag);
	switch (tag) {
	case 0x42627430:
		*type = 1;
		printf(" version =%x\n", *version);
		return 0;
	case 0x31746242:
		*type = 2;
		printf(" version =%x\n", *version);
		return 0;
	default:
		break;
	}
	printf(" no version\n");
	return 0;
}

int find_bbt(struct nand_chip *nand, int chip)
{
	int rc = -1;
	unsigned int i, type, page_count = 0;
	unsigned int count = 2, first = 0;
	unsigned int version = 0xff;

	NAND_ENABLE_CE(nand, chip);

	for (i = 0; i < 30; i++)
		bad_block_pos[chip][i] = 0;

	nand->update_table_inflash = NULL;
	nand->update_table_inram = NULL;
	nand->isbadblock = NULL;
	for (i = nand->dwBlockCount-1; i > (nand->dwBlockCount-1-BBT_MAX_BLOCK); i--) {
		WMT_check_pattern(nand, i, &type, &version);
		if (type) {
			bad_block_pos[chip][nand->dwBlockCount-i-1] = (type|(i<<16));
			count--;
		} else
			continue;
		if (!page_count) {
			if (i == (nand->dwBlockCount-BBT_MAX_BLOCK)) {
				printf("find first table at block%d , failed\n", i);
				rc = -1;
				goto EXIT;
			}
			nand->update_table_inflash = update_bbt_inflash;
			nand->update_table_inram = update_bbt_inram;
			nand->isbadblock = isbbtbadblock;
			count = 1;
			first = (i|1<<16);
			page_count = 1 + ((nand->dwBlockCount>>2) > nand->oobblock) ? 1 : 0;
			bbt_version = version;

			if (!bbt) {
				bbt = malloc(page_count * nand->oobblock * nand->numchips);
				if (!bbt) {
					printf("alloc bbt failed\n");
					rc = -1;
					goto EXIT;
				}
				/*printf("alloc bbt addr=0x%x\n", (unsigned int)bbt);*/
			}
			rc = nand_read_block(nand, (unsigned int)&bbt[(nand->oobblock*chip)/4], i*nand->dwPageCount, page_count);
			if (rc) {
				goto EXIT;
			}
		} else if (version > bbt_version) {
			bbt_version = version;
			rc = nand_read_block(nand, (unsigned int)&bbt[(nand->oobblock*chip)/4],	i*nand->dwPageCount, page_count);
			if (rc) {
				goto EXIT;
			}
		}
		//fixme: bbt1 replace bbt0 without merge.
		if (!count)
			break;
	}
	if (!first) {
		printf("bbt table is not found\n");
		rc = 1;
		goto EXIT;
	}
	printf("bbt table is found\n");
EXIT:
	return rc;
}

int check_block_table(struct nand_chip *nand, unsigned int scan)
{
	int rc = -1, i;

	if ((g_WMTNFCBASE != __NFC_BASE) || !bbt) {
		if (bbt) {
			printf("free bbt\n");
			free(bbt);
			bbt = NULL;
		}
		if (g_WMTNFCBASE != __NFC_BASE)
			rc = nand_probe(__NFC_BASE);
		/*if (!rc) {
			printf("Init Flash Failed rc=%d\r\n", rc);
			return -1;
		}*/
#ifdef USE_BBT
		for (i = 0; i < nand->numchips; i++) {
			rc = find_bbt(nand, i);
//			printf("return of find_bbt failed rc = %d , numchips=%d, scan = %d\n", rc, nand->numchips, scan);
			if (rc < 0) {
				printf("find_bbt of chip%d failed\n", i);
				return -1;
			}
			if (rc > 0 && scan) {
				if (creat_bbt(nand, i)) {
					printf("creat_bbt of chip%d failed\n", i);
					return -1;
				}
			} else if (rc > 0) {
				return -2;
			}
		}
#endif
	}
	return 0;
}

unsigned long nand_probe(unsigned long physadr)
{
	struct nand_chip *nand = NULL;
	unsigned char *dataBuf;
	int i = 0, ChipID = 1;
	int rc = -1;
	pNFCRegs = (WMT_NFC_CFG *) __NFC_BASE;
	pNand_PDma_Reg = (struct _NAND_PDMA_REG_ *) (__NFC_BASE + 0x100);
	g_WMTNFCBASE = __NFC_BASE;
#ifdef CONFIG_MTD_NAND_ECC_JFFS2
	oob_config.ecc_pos[0] = NAND_JFFS2_OOB_ECCPOS0;
	oob_config.ecc_pos[1] = NAND_JFFS2_OOB_ECCPOS1;
	oob_config.ecc_pos[2] = NAND_JFFS2_OOB_ECCPOS2;
	oob_config.ecc_pos[3] = NAND_JFFS2_OOB_ECCPOS3;
	oob_config.ecc_pos[4] = NAND_JFFS2_OOB_ECCPOS4;
	oob_config.ecc_pos[5] = NAND_JFFS2_OOB_ECCPOS5;
	oob_config.eccvalid_pos = 4;
#else
	oob_config.ecc_pos[0] = NAND_NOOB_ECCPOS0;
	oob_config.ecc_pos[1] = NAND_NOOB_ECCPOS1;
	oob_config.ecc_pos[2] = NAND_NOOB_ECCPOS2;
	oob_config.ecc_pos[3] = NAND_NOOB_ECCPOS3;
	oob_config.ecc_pos[4] = NAND_NOOB_ECCPOS4;
	oob_config.ecc_pos[5] = NAND_NOOB_ECCPOS5;
	oob_config.eccvalid_pos = NAND_NOOB_ECCVPOS;
#endif
	oob_config.badblock_pos = 5;

	for (i=0; i<CFG_MAX_NAND_DEVICE; i++) {
		if (nand_dev_desc[i].ChipID == NAND_ChipID_UNKNOWN) {
			nand = &nand_dev_desc[i];
			break;
		}
	}
	if (!nand)
		return (0);

	memset((char *)nand, 0, sizeof(struct nand_chip));
	nand->IO_ADDR = physadr;
	nand->cache_page = -1;  /* init the cache page */
	Nand_ScanChips(nand);

	if (nand->totlen == 0) {
		/* no chips found, clean up and quit */
		memset((char *)nand, 0, sizeof(struct nand_chip));
		nand->ChipID = NAND_ChipID_UNKNOWN;
		return 0;
	}

#ifdef CONFIG_WMT_RANDOMIZER
	if(nand->dwRdmz)
		printf("nand->id: 0x%x dwRdmz = %d\n", nand->id, nand->dwRdmz);
#endif

	nand->ChipID = ChipID;
	if (curr_device == -1)
		curr_device = i;

	dataBuf = malloc (nand->oobblock + nand->oobsize + 0x300);
	if (!dataBuf) {
		puts ("Cannot allocate memory for data structures.\n");
		return (0);
	}
	ReadDesc = (unsigned long *)((((unsigned int)dataBuf)&(~0x1f)) + 0x20);
	nand->data_buf = (unsigned char *)((unsigned int)ReadDesc) + 0x100;
	/*printf(" dataBuf = 0x%x\r\n", (unsigned int)dataBuf);
	printf(" ReadDesc = 0x%x\r\n", (unsigned int)ReadDesc);
	printf(" nand->data_buf = 0x%x\r\n", (unsigned int)nand->data_buf);*/

	switch(nand->dwFlashID)
	{
		case 0x2C88044B:
		case 0x2C68044A:
			NAND_ENABLE_CE(nand, i);
			if(nand->dwFlashID == 0x2C88044B)
				nand_set_feature(0x04); //set to mode 4
			//else if(nand->dwFlashID == 0x2C68044A)
			//	nand_set_feature(0x05); //set to mode 5
			nand_get_feature();
			NAND_DISABLE_CE(nand);
		break; 
	}

	/*scan currenct read retry chip*/
	for(i = 0; i < READ_RETRY_CHIP_NUM; i++) {
		if((nand->id == chip_table[i].nand_id) && (nand->id2 == chip_table[i].nand_id_5th)) {
			cur_chip = &chip_table[i];
		}
	}

	if(cur_chip != NULL) {
		if(nand->mfr == 0x98) {
			return (nand->totlen);
		}
		rc = read_retry_param_from_nand(nand, 0);
		if(rc < 0) {
			cur_chip = NULL;
			return (nand->totlen);
		}

		NAND_ENABLE_CE(nand, 0);
		if(rc == 0) {
			cur_chip->get_parameter(nand, READ_RETRY_MODE);
		}
		NAND_DISABLE_CE(nand);
		if(rc) {
			NAND_ENABLE_CE(nand, 0);
			if(cur_chip->get_otp_table) {
				rc = cur_chip->get_otp_table(nand);
				if(rc) {
					printf("fail to get default nand otp parameter.\n");
					cur_chip = NULL;
					return (nand->totlen);
				}
				rc = cur_chip->get_parameter(nand, ESLC_MODE);
				if(rc) {
					printf("fail to get default nand parameter.\n");
					cur_chip = NULL;
					return (nand->totlen);
				}
			} else {
				rc = cur_chip->get_parameter(nand, READ_RETRY_MODE);
				if(rc) {
					printf("fail to get default nand parameter.\n");
					cur_chip = NULL;
					return (nand->totlen);
				}
				rc = cur_chip->get_parameter(nand, ESLC_MODE);
				if(rc) {
					printf("fail to get default nand parameter.\n");
					cur_chip = NULL;
					return (nand->totlen);
				}
			}
			NAND_DISABLE_CE(nand);
#if 0
			memset(nand->data_buf, 0xff, sizeof(*cur_chip));
			memcpy(nand->data_buf, cur_chip, sizeof(*cur_chip));
			for(i = 0; i < sizeof(*cur_chip); i++)
				printf("0x%x ", nand->data_buf[i]);
			printf("\n");
			rc = write_retry_param_to_nand(nand, 0);
			if(rc) {
				cur_chip = NULL;
				printf("fail to write parameter.\n");
			}
#endif
		}
	} else {
		printf("This chip 0x%x 0x%x not need read retry.\n", nand->id, nand->id2);
	}

	return (nand->totlen);
}

#ifdef CONFIG_MTD_NAND_ECC
#if 0

/*
 * Pre-calculated 256-way 1 byte column parity
 */
static const u_char nand_ecc_precalc_table[] = {
	0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a,
	0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00,
	0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f,
	0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
	0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c,
	0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
	0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59,
	0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
	0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33,
	0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
	0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56,
	0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
	0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55,
	0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
	0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30,
	0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
	0x6a, 0x3f, 0x3c, 0x69, 0x33, 0x66, 0x65, 0x30,
	0x30, 0x65, 0x66, 0x33, 0x69, 0x3c, 0x3f, 0x6a,
	0x0f, 0x5a, 0x59, 0x0c, 0x56, 0x03, 0x00, 0x55,
	0x55, 0x00, 0x03, 0x56, 0x0c, 0x59, 0x5a, 0x0f,
	0x0c, 0x59, 0x5a, 0x0f, 0x55, 0x00, 0x03, 0x56,
	0x56, 0x03, 0x00, 0x55, 0x0f, 0x5a, 0x59, 0x0c,
	0x69, 0x3c, 0x3f, 0x6a, 0x30, 0x65, 0x66, 0x33,
	0x33, 0x66, 0x65, 0x30, 0x6a, 0x3f, 0x3c, 0x69,
	0x03, 0x56, 0x55, 0x00, 0x5a, 0x0f, 0x0c, 0x59,
	0x59, 0x0c, 0x0f, 0x5a, 0x00, 0x55, 0x56, 0x03,
	0x66, 0x33, 0x30, 0x65, 0x3f, 0x6a, 0x69, 0x3c,
	0x3c, 0x69, 0x6a, 0x3f, 0x65, 0x30, 0x33, 0x66,
	0x65, 0x30, 0x33, 0x66, 0x3c, 0x69, 0x6a, 0x3f,
	0x3f, 0x6a, 0x69, 0x3c, 0x66, 0x33, 0x30, 0x65,
	0x00, 0x55, 0x56, 0x03, 0x59, 0x0c, 0x0f, 0x5a,
	0x5a, 0x0f, 0x0c, 0x59, 0x03, 0x56, 0x55, 0x00
};


/*
 * Creates non-inverted ECC code from line parity
 */
#if 0
static void nand_trans_result(u_char reg2, u_char reg3,
	u_char *ecc_code)
{
	u_char a, b, i, tmp1, tmp2;

	/* Initialize variables */
	a = b = 0x80;
	tmp1 = tmp2 = 0;

	/* Calculate first ECC byte */
	for (i = 0; i < 4; i++) {
		if (reg3 & a)		/* LP15,13,11,9 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP14,12,10,8 --> ecc_code[0] */
			tmp1 |= b;
		b >>= 1;
		a >>= 1;
	}

	/* Calculate second ECC byte */
	b = 0x80;
	for (i = 0; i < 4; i++) {
		if (reg3 & a)		/* LP7,5,3,1 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
		if (reg2 & a)		/* LP6,4,2,0 --> ecc_code[1] */
			tmp2 |= b;
		b >>= 1;
		a >>= 1;
	}

	/* Store two of the ECC bytes */
	ecc_code[0] = tmp1;
	ecc_code[1] = tmp2;
}
#endif
/*
 * Calculate 3 byte ECC code for 256 byte block
 */

static void nand_calculate_ecc (const u_char *dat, u_char *ecc_code)
{
	u_char idx, reg1, reg3;
	int j;

	/* Initialize variables */
	reg1 = reg3 = 0;
	ecc_code[0] = ecc_code[1] = ecc_code[2] = 0;

	/* Build up column parity */
	for(j = 0; j < 256; j++) {

		/* Get CP0 - CP5 from table */
		idx = nand_ecc_precalc_table[dat[j]];
		reg1 ^= idx;

		/* All bit XOR = 1 ? */
		if (idx & 0x40) {
			reg3 ^= (u_char) j;
		}
	}

	/* Create non-inverted ECC code from line parity */
	nand_trans_result((reg1 & 0x40) ? ~reg3 : reg3, reg3, ecc_code);

	/* Calculate final ECC code */
	ecc_code[0] = ~ecc_code[0];
	ecc_code[1] = ~ecc_code[1];
	ecc_code[2] = ((~reg1) << 2) | 0x03;
}

/*
 * Detect and correct a 1 bit error for 256 byte block
 */
static int nand_correct_data (u_char *dat, u_char *read_ecc, u_char *calc_ecc)
{
	u_char a, b, c, d1, d2, d3, add, bit, i;

	/* Do error detection */
	d1 = calc_ecc[0] ^ read_ecc[0];
	d2 = calc_ecc[1] ^ read_ecc[1];
	d3 = calc_ecc[2] ^ read_ecc[2];

	if ((d1 | d2 | d3) == 0) {
		/* No errors */
		return 0;
	} else {
		a = (d1 ^ (d1 >> 1)) & 0x55;
		b = (d2 ^ (d2 >> 1)) & 0x55;
		c = (d3 ^ (d3 >> 1)) & 0x54;

		/* Found and will correct single bit error in the data */
		if ((a == 0x55) && (b == 0x55) && (c == 0x54)) {
			c = 0x80;
			add = 0;
			a = 0x80;
			for (i=0; i<4; i++) {
				if (d1 & c)
					add |= a;
				c >>= 2;
				a >>= 1;
			}
			c = 0x80;
			for (i=0; i<4; i++) {
				if (d2 & c)
					add |= a;
				c >>= 2;
				a >>= 1;
			}
			bit = 0;
			b = 0x04;
			c = 0x80;
			for (i=0; i<3; i++) {
				if (d3 & c)
					bit |= b;
				c >>= 2;
				b >>= 1;
			}
			b = 0x01;
			a = dat[add];
			a ^= (b << bit);
			dat[add] = a;
			return 1;
		}
		else {
			i = 0;
			while (d1) {
				if (d1 & 0x01)
					++i;
				d1 >>= 1;
			}
			while (d2) {
				if (d2 & 0x01)
					++i;
				d2 >>= 1;
			}
			while (d3) {
				if (d3 & 0x01)
					++i;
				d3 >>= 1;
			}
			if (i == 1) {
				/* ECC Code Error Correction */
				read_ecc[0] = calc_ecc[0];
				read_ecc[1] = calc_ecc[1];
				read_ecc[2] = calc_ecc[2];
				return 2;
			}
			else {
				/* Uncorrectable Error */
				return -1;
			}
		}
	}

	/* Should never happen */
	return -1;
}
#endif /* end of #if 0 by dannier*/
#endif

#ifdef CONFIG_JFFS2_NAND

int read_jffs2_nand(size_t start, size_t len,
		    size_t * retlen, u_char * buf, int nanddev)
{
	return nand_rw(nand_dev_desc + nanddev, NANDRW_READ | NANDRW_JFFS2,
		       start, len, retlen, buf);
}

#endif /* CONFIG_JFFS2_NAND */


//#endif /* (CONFIG_COMMANDS & CFG_CMD_NAND) */
