/*++
linux/drivers/mtd/nand/wmt_nand.c

Copyright (c) 2008  WonderMedia Technologies, Inc.

This program is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software Foundation,
either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

WonderMedia Technologies, Inc.
10F, 529, Chung-Cheng Road, Hsin-Tien, Taipei 231, R.O.C.
--*/

//#include <linux/config.h>
#include <linux/module.h>
/*#include <linux/types.h>*/
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/platform_device.h>
#include <linux/string.h>
#include <linux/ioport.h>
/*#include <linux/platform_device.h>*/
#include <linux/delay.h>
#include <linux/err.h>
#include <linux/slab.h>
#include <linux/dma-mapping.h>
/*#include <linux/clk.h>*/

#include <linux/mtd/mtd.h>
#include <linux/mtd/nand.h>
#include <linux/mtd/nand_ecc.h>
/*#include <linux/mtd/partitions.h>*/
#include <linux/interrupt.h>
#include <linux/completion.h>
#include <linux/reboot.h> //Lch
#include <asm/irq.h>
#include <asm/io.h>
#include <asm/dma.h>
#include <asm/sizes.h>
#include <mach/irqs.h>
#include <mach/hardware.h>
#include <linux/vmalloc.h>
#include "wmt_nand.h"


#ifndef memzero
#define memzero(s, n)     memset ((s), 0, (n))
#endif

#define WMT_RDMZ
#ifdef WMT_RDMZ
unsigned int rdmz[BYTE_SEED]= {
 0xC5F7B49E, 0x85AD42B6, 0x1888A48B, 0xFBA90A42, 0xE20E7129, 0x37E8086E, 0x6F1C1918, 0x31510E20,
 0x382771CB, 0x6107F49D, 0x901B6D0B, 0x3CD489E1, 0xA9B9CE07, 0x6B41AC61, 0x749F181D, 0xA7DDA658,
 0x405276C0, 0xB67EFB43, 0xC5EE35A6, 0xF8406534, 0x73D8093A, 0xD98028A3, 0x084CE1AF, 0xB4744210,
 0x951E02A0, 0xF657482D, 0x6C64F9D0, 0x68DB8651, 0xD1E64A45, 0x3A0FCB39, 0x9C9BB663, 0x05322DAE,
 0xA4F40077, 0x801BA102, 0xB73BE0DD, 0xA2E34B6A, 0x5A50E576, 0x83CD0C99, 0x63C1440B, 0x2F82661D,
 0x6846C973, 0xA74C29E6, 0x880E86A2, 0xB1D7E000, 0xF9B6F2B5, 0x71E5F26C, 0xE707DE1E, 0x439D5A63,
 0x1F697817, 0x23DFB560, 0xE87F6BD0, 0xBD1BBCC3, 0xB1D3A074, 0x6C1B7C0A, 0xE2823FDB, 0x17F45131,
 0x9082625D, 0xDFD364FD, 0x88DF4E2B, 0xB6FE752D, 0x5B04FF38, 0xB27648A9, 0x8C4EF297, 0x1C595F00,
 0x9E7B4520, 0x826ADDFF, 0xF83FE0EE, 0xF981B0B0, 0x1F9233D7, 0xA2C148CB, 0xF73C908E, 0x18F36125,
 0xE45D3D77, 0xB77BA7EA, 0x6D962E25, 0xFF4BF3B8, 0x7C06714F, 0x812DFFDA, 0xE499B45A, 0x73498684,
 0x11DCD8C1, 0x0FE5FAEC, 0x882C8503, 0x1CBB95F8, 0x62889F09, 0xF6798B10, 0x7FFE1FE9, 0x464DBD35,
 0x476EA249, 0xD7D7428D, 0xD885740A, 0xA034FA2C, 0xB37FD49C, 0x9AC07AD5, 0xAEFA9F54, 0x80B1AC25,
 0xAFE642C5, 0x55249024, 0xC3BD79F8, 0x78D3CAB0, 0x71523E07, 0x179AD53B, 0x4C6DE12B, 0x545E4957,
 0xE19CDBF1, 0xB9CA4748, 0xD401EF16, 0x0C7FD0DC, 0x2D55D75B, 0x8169F899, 0xBE415FAA, 0x45355DFD,
 0x1EE42A38, 0x3E167903, 0x838D4BAE, 0xACB42144, 0x8A9970D3, 0x978DB4A5, 0x45A09237, 0x431554E5,
 0xAAD8AFF7, 0x4F260392, 0xF60E8E22, 0xDEFCBB1D, 0xA6903D2E, 0x0C041572, 0x32A1E06E, 0xD41C2E5A,
 0xE43F79E1, 0xD562B75D, 0x53B35557, 0x871CF712, 0x06130B69, 0x4FE6CACB, 0xA79121F3, 0x31D1804E,
 0xA6CDBB55, 0x2B31D900, 0x6F8D96A6, 0xF90DFE42, 0x3F8E6A88, 0x5D5F338E, 0x19BEFA53, 0xA80B5EC5,
 0x33A4BCC7, 0x7C6435D9, 0xE334EF6D, 0xDABCCF28, 0x0B1E822E, 0x6BC9A2E7, 0xC12ECFFD, 0xCB2410AA,
 0x5E239332, 0xD599FC9D, 0xD2ADA8FC, 0x985F0C4C, 0xA3FBD68F, 0x1A6857C8, 0x7CF1FA13, 0xBEC591B0,
 0x4E7219DC, 0xC7B5CA12, 0x31730D81, 0x954B0433, 0xFA399921, 0x17871477, 0xA42D4816, 0xAC692951,
 0x3346763F, 0x8097EFF0, 0x9727B982, 0x5D7D302F, 0xB4D28FAB, 0x33353379, 0xB438C5BB, 0xE49DF42E,
 0xE6E4083B, 0x82BB1576, 0xFF1675C3, 0x5B33BD3D, 0xDC018912, 0xC9886442, 0xA8F895ED, 0x99E15C12,
 0x45E855E8, 0xA73B2CD4, 0x290C2256, 0x510A601B, 0xB2DC458E, 0x9493508F, 0xEB9E844E, 0x0796D9AE,
 0x79741BD6, 0xEAAC9AE2, 0xC1990396, 0x3BB91B8F, 0x51D3287A, 0x9EAECDDD, 0x10EEC66D, 0xC9EA20D4,
 0xCAE1855A, 0xA7C42760, 0x3DBF5142, 0xDD2E56F2, 0xE7C71747, 0x1202F5B2, 0xF0444344, 0x2382331B,
 0xCF4AA7A2, 0xE037CA0B, 0x9CC2706C, 0xB7AA6F63, 0x6ABFBB08, 0x5DF9FE35, 0xBF95CB8A, 0xEA64D353,
 0xBB5DB139, 0xF25BBBB3, 0xB069B05E, 0x1FA571D2, 0xCCB68970, 0xB2FA065B, 0xAC52ABC8, 0xE3C72445,
 0x70F92FFD, 0x3292E21F, 0x2FC6615E, 0x329E2283, 0x9130F29F, 0x8736745B, 0x802463EF, 0xF2173C18,
 0xC1EA46D0, 0x0F1631C4, 0x226965D6, 0x2537F5C9, 0x26875CB0, 0x05C9666E, 0x25EAFDDC, 0x9F585A5C,
 0x12D33D3B, 0xF76DD669, 0x81303E96, 0x0CD91D67, 0x8B7EE682, 0xC306750F, 0x36B85254, 0xCB0AD397,
 0x4DB9750B, 0xFB0FC7F9, 0x442540F0, 0x758785F8, 0xE7E514E6, 0xBF6E804A, 0x6B7A2EF8, 0xA41E4A67,
 0x57B36655, 0xE5E72D5D, 0xC4C5AA32, 0x43A2988E, 0x5A45A4D2, 0x40D6B8DA, 0xBD39BF62, 0x1CBFD58C,
 0xF72511B6, 0x651E46A7, 0x8F0D90C6, 0x9552850B, 0x87D4BEA3, 0x7CD7B9C6, 0x86046AF7, 0x462BB9D7,
 0xB0DA3C41, 0x7A95F448, 0x5021FF8F, 0x093EB834, 0xBD0EFD67, 0x72C81437, 0xB2E38763, 0xD1BF8C4A,
 0x889789F4, 0x52D00D1C, 0xD8D07299, 0xAC5A2B20, 0xC89C393B, 0x5636B492, 0xD375FC40, 0x89F81123,
 0xB3EA1B56, 0xC7310408, 0x3A3449A0, 0x4C1AE419, 0xF55CEDA3, 0x01415BEA, 0xF2A0F073, 0x31774DF5,
 0x00E68A8C, 0x695E5496, 0xE7749B58, 0x77327028, 0x6CD335BB, 0x98468D74, 0xDE16F10D, 0x7138FA79,
 0x5ED8D8F2, 0x54870136, 0xCDEE53A2, 0x3DB7D1AA, 0xF6754B8C, 0xC1088C28, 0xF3E5EBED, 0x567A3339,
 0xA2F60ACE, 0x994B5135, 0x5D35F7F0, 0x50FCF79A, 0xB0E1BED8, 0xAA14A632, 0xA04F3F82, 0xAC8BE3A9,
 0xCFB5AC16, 0xF484B91F, 0x10E64685, 0xE2B13DAA, 0xEC2E1E35, 0x4623393F, 0x9B81213F, 0x5C5A6F27,
 0xB1C6E1D0, 0xAF00C849, 0x3C7AC4B2, 0x24C9E2A0, 0x0FE1BA98, 0x1D810BBC, 0x8FDC584F, 0x927B1026,
 0x2566B32E, 0xBF440303, 0xED4D467E, 0x19EFBCB4, 0x31C80176, 0xDB209CD7, 0x406174B1, 0x4DA4B447,
 0x134F6EC4, 0xBC1220F6, 0xA75D2836, 0xDEB8BC5E, 0xFC48D6DE, 0x3A78CE0B, 0x3D991297, 0xE5EFADB5,
 0xEF9EB74C, 0x656D03E1, 0xBBA2BA8D, 0xE6E8C8A7, 0x3C4D86B7, 0x4ABE231B, 0x4A272C4D, 0xA920C151,
 0x8846417D, 0x55F99831, 0x7A627F14, 0x6FC991E5, 0xA3D515B2, 0x09F2B1F1, 0x5267C177, 0x284D79BC,
 0xA3AA9068, 0x83AB087B, 0x9475DA03, 0x82C0D0D8, 0xE0E242F6, 0x0E466BFE, 0x867FAF59, 0x59DF8EE2,
 0xE5AFEA82, 0x20EBD203, 0xC076152F, 0x4469C75B, 0x04047376, 0xF75654F0, 0x51B16CEC, 0xFCB7DD6A,
 0x2ECBBD1F, 0xB1BD247E, 0xB0F4FF7C, 0x690F1271, 0x7EB7C4EB, 0x9FB65038, 0x50D674D3, 0x36D6D65E,
 0x17E550E1, 0xC63458A1, 0x924C5223, 0x4B117295, 0xFA8295D6, 0x59EC8C93, 0x1E75A586, 0xF64A8961,
 0x842450ED, 0x90ECE657, 0x033CE78B, 0x03526381, 0xDFBDE0F7, 0x5430CD5D, 0x3D735887, 0x32476AE2,
 0xBD427ACC, 0x034BE2B9, 0xA250C775, 0x3F6060EC, 0x1F5A7A66, 0xD805FA64, 0x3EDE30B2, 0xF949F901,
 0x65568178, 0x6B23E8F7, 0x168608AA, 0x99F8DD2A, 0x3805726A, 0xCC6B8165, 0x0B2500B7, 0xBB48F09D,
 0x31400FF0, 0x6E914B37, 0x2C98C243, 0x53D551B5, 0x70A8691A, 0xAB51BDAC, 0xC742414E, 0x0E9B63EB,
 0x3FA0A9B5, 0x4EC5D5B7, 0x3728C137, 0x3E83B6C9, 0xDE7C3573, 0x387AF7B0, 0x463238EF, 0xCD371BC3,
 0x11C559F9, 0x7208DD6E, 0xE37C28B2, 0x3E92B719, 0x88CA0F8F, 0x75E5C16E, 0x85FC0451, 0x814BFB38,
 0x132D2A52, 0xDE0B3041, 0x99785344, 0xA6EFB8F4, 0x865DACF8, 0xF4B3FB1A, 0x7E91873E, 0xA777AB7F,
 0x588FD4D8, 0x41B9200D, 0x5C03A928, 0x035EA31D, 0x614B7336, 0xE1989B85, 0x2C67C9F7, 0x476622A1,
 0xFC8C5FF3, 0xFE4AEF65, 0x41D3E473, 0x1541A4E1, 0x1BB44300, 0xF8FB69C3, 0x3DB391DE, 0x63D8C533,
 0x526F419F, 0x031664C2, 0x85650B07, 0x624C1624, 0x324BAA7E, 0x03B4E90D, 0xB6E3B461, 0xB3445605,
 0x4A4128AF, 0x5E945F59, 0x2504F7B8, 0xDD5D13B4, 0xD3683D0C, 0x61B8B81E, 0x4BDD7B50, 0x15EBA9C6,
 0x0369E118, 0x0F3CB28D, 0xA45E0D50, 0x98C6031A, 0x40FC3B93, 0x3B0ED7E4, 0xA14E235F, 0x915E7695,
 0x5BD9F72D, 0x0BA94E45, 0x9B54A9C2, 0xCEDE74B5, 0x801321EA, 0x9C60FDA3, 0x842CD005, 0xBBB7FB29,
 0x25F37CE4, 0xE2B57DDE, 0x7983908A, 0xD544F488, 0x6B72AE10, 0x8F455719, 0x717CFD3A, 0x04003302,
 0x62FBDA4F, 0xC2D6A15B, 0x0C445245, 0xFDD48521, 0x71073894, 0x1BF40437, 0x378E0C8C, 0x98A88710,
 0x9C13B8E5, 0xB083FA4E, 0xC80DB685, 0x9E6A44F0, 0xD4DCE703, 0xB5A0D630, 0x3A4F8C0E, 0x53EED32C,
 0xA0293B60, 0x5B3F7DA1, 0x62F71AD3, 0x7C20329A, 0xB9EC049D, 0xECC01451, 0x042670D7, 0x5A3A2108,
 0xCA8F0150, 0x7B2BA416, 0xB6327CE8, 0xB46DC328, 0xE8F32522, 0x9D07E59C, 0x4E4DDB31, 0x829916D7,
 0x527A003B, 0xC00DD081, 0x5B9DF06E, 0x5171A5B5, 0xAD2872BB, 0xC1E6864C, 0xB1E0A205, 0x97C1330E,
 0x342364B9, 0x53A614F3, 0x44074351, 0xD8EBF000, 0x7CDB795A, 0x38F2F936, 0xF383EF0F, 0xA1CEAD31,
 0x0FB4BC0B, 0x11EFDAB0, 0xF43FB5E8, 0x5E8DDE61, 0x58E9D03A, 0xB60DBE05, 0xF1411FED, 0x8BFA2898,
 0xC841312E, 0xEFE9B27E, 0xC46FA715, 0x5B7F3A96, 0xAD827F9C, 0xD93B2454, 0x4627794B, 0x0E2CAF80,
 0xCF3DA290, 0x41356EFF, 0x7C1FF077, 0xFCC0D858, 0x8FC919EB, 0x5160A465, 0xFB9E4847, 0x8C79B092,
 0x722E9EBB, 0xDBBDD3F5, 0x36CB1712, 0xFFA5F9DC, 0x3E0338A7, 0x4096FFED, 0x724CDA2D, 0xB9A4C342,
 0x08EE6C60, 0x87F2FD76, 0x44164281, 0x8E5DCAFC, 0x31444F84, 0xFB3CC588, 0xBFFF0FF4, 0xA326DE9A,
 0xA3B75124, 0x6BEBA146, 0x6C42BA05, 0x501A7D16, 0xD9BFEA4E, 0x4D603D6A, 0xD77D4FAA, 0xC058D612,
 0x57F32162, 0x2A924812, 0x61DEBCFC, 0xBC69E558, 0xB8A91F03, 0x8BCD6A9D, 0xA636F095, 0xAA2F24AB,
 0x70CE6DF8, 0x5CE523A4, 0x6A00F78B, 0x863FE86E, 0x96AAEBAD, 0x40B4FC4C, 0xDF20AFD5, 0x229AAEFE,
 0x8F72151C, 0x1F0B3C81, 0x41C6A5D7, 0xD65A10A2, 0xC54CB869, 0xCBC6DA52, 0xA2D0491B, 0xA18AAA72,
 0x556C57FB, 0x279301C9, 0xFB074711, 0x6F7E5D8E, 0x53481E97, 0x06020AB9, 0x1950F037, 0xEA0E172D,
 0xF21FBCF0, 0xEAB15BAE, 0x29D9AAAB, 0xC38E7B89, 0x830985B4, 0xA7F36565, 0x53C890F9, 0x98E8C027,
 0x5366DDAA, 0x1598EC80, 0x37C6CB53, 0x7C86FF21, 0x1FC73544, 0xAEAF99C7, 0x8CDF7D29, 0xD405AF62,
 0x99D25E63, 0xBE321AEC, 0x719A77B6, 0x6D5E6794, 0x858F4117, 0xB5E4D173, 0x609767FE, 0x65920855,
 0xAF11C999, 0x6ACCFE4E, 0x6956D47E, 0xCC2F8626, 0x51FDEB47, 0x8D342BE4, 0x3E78FD09, 0x5F62C8D8,
 0x27390CEE, 0xE3DAE509, 0x98B986C0, 0xCAA58219, 0xFD1CCC90, 0x0BC38A3B, 0xD216A40B, 0xD63494A8,
 0x19A33B1F, 0x404BF7F8, 0xCB93DCC1, 0xAEBE9817, 0xDA6947D5, 0x999A99BC, 0x5A1C62DD, 0xF24EFA17,
 0x7372041D, 0xC15D8ABB, 0xFF8B3AE1, 0x2D99DE9E, 0x6E00C489, 0xE4C43221, 0x547C4AF6, 0x4CF0AE09,
 0x22F42AF4, 0x539D966A, 0x9486112B, 0x2885300D, 0xD96E22C7, 0x4A49A847, 0x75CF4227, 0x03CB6CD7,
 0x3CBA0DEB, 0x75564D71, 0xE0CC81CB, 0x1DDC8DC7, 0xA8E9943D, 0xCF5766EE, 0x08776336, 0x64F5106A,
 0x6570C2AD, 0x53E213B0, 0x1EDFA8A1, 0xEE972B79, 0x73E38BA3, 0x09017AD9, 0xF82221A2, 0x11C1198D,
 0xE7A553D1, 0x701BE505, 0xCE613836, 0x5BD537B1, 0xB55FDD84, 0x2EFCFF1A, 0xDFCAE5C5, 0xF53269A9,
 0xDDAED89C, 0x792DDDD9, 0x5834D82F, 0x0FD2B8E9, 0xE65B44B8, 0x597D032D, 0xD62955E4, 0xF1E39222,
 0xB87C97FE, 0x1949710F, 0x97E330AF, 0x994F1141, 0xC898794F, 0xC39B3A2D, 0x401231F7, 0x790B9E0C,
 0x60F52368, 0x078B18E2, 0x9134B2EB, 0x129BFAE4, 0x1343AE58, 0x02E4B337, 0x12F57EEE, 0xCFAC2D2E,
 0x89699E9D, 0x7BB6EB34, 0xC0981F4B, 0x066C8EB3, 0xC5BF7341, 0x61833A87, 0x9B5C292A, 0xE58569CB,
 0xA6DCBA85, 0x7D87E3FC, 0x2212A078, 0x3AC3C2FC, 0x73F28A73, 0x5FB74025, 0xB5BD177C, 0xD20F2533,
 0xABD9B32A, 0x72F396AE, 0x6262D519, 0x21D14C47, 0x2D22D269, 0x206B5C6D, 0x5E9CDFB1, 0x0E5FEAC6,
 0xFB9288DB, 0x328F2353, 0xC786C863, 0xCAA94285, 0x43EA5F51, 0xBE6BDCE3, 0xC302357B, 0xA315DCEB,
 0x586D1E20, 0xBD4AFA24, 0x2810FFC7, 0x849F5C1A, 0xDE877EB3, 0xB9640A1B, 0x5971C3B1, 0x68DFC625,
 0x444BC4FA, 0xA968068E, 0x6C68394C, 0xD62D1590, 0x644E1C9D, 0x2B1B5A49, 0xE9BAFE20, 0x44FC0891,
 0x59F50DAB, 0x63988204, 0x9D1A24D0, 0xA60D720C, 0x7AAE76D1, 0x80A0ADF5, 0xF9507839, 0x18BBA6FA,
 0x00734546, 0x34AF2A4B, 0x73BA4DAC, 0xBB993814, 0x36699ADD, 0xCC2346BA, 0xEF0B7886, 0x389C7D3C,
 0x2F6C6C79, 0x2A43809B, 0x66F729D1, 0x1EDBE8D5, 0x7B3AA5C6, 0xE0844614, 0xF9F2F5F6, 0x2B3D199C,
 0xD17B0567, 0x4CA5A89A, 0x2E9AFBF8, 0x287E7BCD, 0x5870DF6C, 0x550A5319, 0xD0279FC1, 0x5645F1D4,
 0xE7DAD60B, 0xFA425C8F, 0x08732342, 0xF1589ED5, 0xF6170F1A, 0xA3119C9F, 0xCDC0909F, 0x2E2D3793,
 0xD8E370E8, 0x57806424, 0x1E3D6259, 0x1264F150, 0x07F0DD4C, 0x8EC085DE, 0x47EE2C27, 0x493D8813,
 0x92B35997, 0x5FA20181, 0x76A6A33F, 0x0CF7DE5A, 0x98E400BB, 0xED904E6B, 0xA030BA58, 0x26D25A23,
 0x09A7B762, 0x5E09107B, 0x53AE941B, 0x6F5C5E2F, 0xFE246B6F, 0x9D3C6705, 0x9ECC894B, 0x72F7D6DA,
 0xF7CF5BA6, 0xB2B681F0, 0xDDD15D46, 0xF3746453, 0x9E26C35B, 0xA55F118D, 0xA5139626, 0xD49060A8,
 0xC42320BE, 0x2AFCCC18, 0xBD313F8A, 0x37E4C8F2, 0xD1EA8AD9, 0x84F958F8, 0x2933E0BB, 0x1426BCDE,
 0xD1D54834, 0xC1D5843D, 0x4A3AED01, 0x4160686C, 0x7071217B, 0x872335FF, 0x433FD7AC, 0x2CEFC771,
 0xF2D7F541, 0x9075E901, 0xE03B0A97, 0x2234E3AD, 0x020239BB, 0x7BAB2A78, 0x28D8B676, 0xFE5BEEB5,
 0x1765DE8F, 0x58DE923F, 0xD87A7FBE, 0xB4878938, 0x3F5BE275, 0xCFDB281C, 0x286B3A69, 0x9B6B6B2F,
 0x8BF2A870, 0xE31A2C50, 0xC9262911, 0x2588B94A, 0xFD414AEB, 0x2CF64649, 0x8F3AD2C3, 0xFB2544B0,
 0xC2122876, 0xC876732B, 0x819E73C5, 0x81A931C0, 0xEFDEF07B, 0xAA1866AE, 0x1EB9AC43, 0x1923B571,
 0xDEA13D66, 0x81A5F15C, 0x512863BA, 0x1FB03076, 0x0FAD3D33, 0x6C02FD32, 0x9F6F1859, 0x7CA4FC80,
 0xB2AB40BC, 0x3591F47B, 0x0B430455, 0x4CFC6E95, 0x9C02B935, 0xE635C0B2, 0x8592805B, 0x5DA4784E,
 0x98A007F8, 0xB748A59B, 0x964C6121, 0x29EAA8DA, 0x3854348D, 0x55A8DED6, 0xE3A120A7, 0x874DB1F5,
 0x9FD054DA, 0xA762EADB, 0x9B94609B, 0x9F41DB64, 0x6F3E1AB9, 0x9C3D7BD8, 0xA3191C77, 0xE69B8DE1,
 0x08E2ACFC, 0x39046EB7, 0xF1BE1459, 0x9F495B8C, 0x446507C7, 0xBAF2E0B7, 0x42FE0228, 0x40A5FD9C,
 0x89969529, 0x6F059820, 0x4CBC29A2, 0x5377DC7A, 0x432ED67C, 0x7A59FD8D, 0xBF48C39F, 0x53BBD5BF,
 0xAC47EA6C, 0x20DC9006, 0xAE01D494, 0x01AF518E, 0xB0A5B99B, 0xF0CC4DC2, 0x9633E4FB, 0xA3B31150,
 0xFE462FF9, 0xFF2577B2, 0xA0E9F239, 0x0AA0D270, 0x8DDA2180, 0x7C7DB4E1, 0x9ED9C8EF, 0xB1EC6299,
 0x2937A0CF, 0x818B3261, 0x42B28583, 0x31260B12, 0x9925D53F, 0x81DA7486, 0xDB71DA30, 0xD9A22B02,
 0xA5209457, 0x2F4A2FAC, 0x12827BDC, 0x6EAE89DA, 0x69B41E86, 0x30DC5C0F, 0x25EEBDA8, 0x0AF5D4E3,
 0x81B4F08C, 0x079E5946, 0x522F06A8, 0xCC63018D, 0x207E1DC9, 0x9D876BF2, 0xD0A711AF, 0xC8AF3B4A,
 0xADECFB96, 0x05D4A722, 0xCDAA54E1, 0x676F3A5A, 0xC00990F5, 0xCE307ED1, 0xC2166802, 0x5DDBFD94,
 0x12F9BE72, 0x715ABEEF, 0x3CC1C845, 0x6AA27A44, 0xB5B95708, 0x47A2AB8C, 0x38BE7E9D, 0x82001981,
 0xB17DED27, 0xE16B50AD, 0x86222922, 0x7EEA4290, 0xB8839C4A, 0x0DFA021B, 0x1BC70646, 0xCC544388,
 0x4E09DC72, 0xD841FD27, 0x6406DB42, 0xCF352278, 0x6A6E7381, 0x5AD06B18, 0x1D27C607, 0x29F76996,
 0xD0149DB0, 0xAD9FBED0, 0x317B8D69, 0xBE10194D, 0xDCF6024E, 0xF6600A28, 0x0213386B, 0x2D1D1084,
 0x654780A8, 0x3D95D20B, 0x5B193E74, 0x5A36E194, 0x74799291, 0xCE83F2CE, 0xA726ED98, 0xC14C8B6B,
 0xA93D001D, 0x6006E840, 0xADCEF837, 0xA8B8D2DA, 0x5694395D, 0xE0F34326, 0x58F05102, 0xCBE09987,
 0x9A11B25C, 0xA9D30A79, 0x2203A1A8, 0x6C75F800, 0x3E6DBCAD, 0x9C797C9B, 0xF9C1F787, 0xD0E75698,
 0x07DA5E05, 0x08F7ED58, 0xFA1FDAF4, 0x2F46EF30, 0xAC74E81D, 0xDB06DF02, 0x78A08FF6, 0x45FD144C,
 0x64209897, 0xF7F4D93F, 0x6237D38A, 0x2DBF9D4B, 0x56C13FCE, 0xEC9D922A, 0x2313BCA5, 0x071657C0,
 0xE79ED148, 0xA09AB77F, 0x3E0FF83B, 0xFE606C2C, 0xC7E48CF5, 0xA8B05232, 0x7DCF2423, 0xC63CD849,
 0xB9174F5D, 0x6DDEE9FA, 0x1B658B89, 0xFFD2FCEE, 0x9F019C53, 0xA04B7FF6, 0x39266D16, 0x5CD261A1,
 0x04773630, 0xC3F97EBB, 0x220B2140, 0x472EE57E, 0x18A227C2, 0x7D9E62C4, 0x5FFF87FA, 0x51936F4D,
 0x51DBA892, 0xB5F5D0A3, 0x36215D02, 0x280D3E8B, 0x6CDFF527, 0x26B01EB5, 0x6BBEA7D5, 0x602C6B09,
 0x2BF990B1, 0x15492409, 0x30EF5E7E, 0xDE34F2AC, 0xDC548F81, 0xC5E6B54E, 0xD31B784A, 0x55179255,
 0x386736FC, 0xAE7291D2, 0x35007BC5, 0xC31FF437, 0x4B5575D6, 0xA05A7E26, 0x6F9057EA, 0x114D577F,
 0xC7B90A8E, 0x8F859E40, 0x20E352EB, 0xEB2D0851, 0x62A65C34, 0xE5E36D29, 0x5168248D, 0xD0C55539,
 0xAAB62BFD, 0x93C980E4, 0x7D83A388, 0xB7BF2EC7, 0xA9A40F4B, 0x8301055C, 0x8CA8781B, 0x75070B96,
 0x790FDE78, 0xF558ADD7, 0x94ECD555, 0x61C73DC4, 0xC184C2DA, 0xD3F9B2B2, 0xA9E4487C, 0x4C746013,
 0x29B36ED5, 0x8ACC7640, 0x9BE365A9, 0x3E437F90, 0x8FE39AA2, 0xD757CCE3, 0x466FBE94, 0xEA02D7B1,
 0x4CE92F31, 0x5F190D76, 0x38CD3BDB, 0xB6AF33CA, 0xC2C7A08B, 0x5AF268B9, 0xB04BB3FF, 0xB2C9042A,
 0x5788E4CC, 0x35667F27, 0x34AB6A3F, 0xE617C313, 0x28FEF5A3, 0xC69A15F2, 0x1F3C7E84, 0x2FB1646C,
 0x939C8677, 0x71ED7284, 0xCC5CC360, 0x6552C10C, 0xFE8E6648, 0x85E1C51D, 0x690B5205, 0xEB1A4A54,
 0x0CD19D8F, 0xA025FBFC, 0xE5C9EE60, 0xD75F4C0B, 0x6D34A3EA, 0xCCCD4CDE, 0xAD0E316E, 0xF9277D0B,
 0xB9B9020E, 0xE0AEC55D, 0x7FC59D70, 0x96CCEF4F, 0xB7006244, 0x72621910, 0xAA3E257B, 0x26785704,
 0x117A157A, 0xA9CECB35, 0xCA430895, 0x94429806, 0xECB71163, 0xA524D423, 0xBAE7A113, 0x81E5B66B,
 0x9E5D06F5, 0xBAAB26B8, 0xF06640E5, 0x8EEE46E3, 0x5474CA1E, 0x67ABB377, 0x043BB19B, 0xB27A8835,
 0x32B86156, 0xA9F109D8, 0x8F6FD450, 0xF74B95BC, 0xB9F1C5D1, 0x0480BD6C, 0xFC1110D1, 0x88E08CC6,
 0xF3D2A9E8, 0x380DF282, 0xE7309C1B, 0x2DEA9BD8, 0x5AAFEEC2, 0x977E7F8D, 0xEFE572E2, 0x7A9934D4,
 0xEED76C4E, 0xBC96EEEC, 0xAC1A6C17, 0x07E95C74, 0xF32DA25C, 0x2CBE8196, 0x6B14AAF2, 0x78F1C911,
 0xDC3E4BFF, 0x8CA4B887, 0xCBF19857, 0xCCA788A0, 0xE44C3CA7, 0xE1CD9D16, 0x200918FB, 0x3C85CF06,
 0x307A91B4, 0x83C58C71, 0x489A5975, 0x094DFD72, 0x89A1D72C, 0x0172599B, 0x097ABF77, 0xE7D61697,
 0x44B4CF4E, 0xBDDB759A, 0xE04C0FA5, 0x83364759, 0xE2DFB9A0, 0x30C19D43, 0xCDAE1495, 0xF2C2B4E5,
 0x536E5D42, 0x3EC3F1FE, 0x1109503C, 0x9D61E17E, 0xB9F94539, 0x2FDBA012, 0xDADE8BBE, 0x69079299,
 0x55ECD995, 0xB979CB57, 0xB1316A8C, 0x90E8A623, 0x96916934, 0x9035AE36, 0x2F4E6FD8, 0x872FF563,
 0xFDC9446D, 0x994791A9, 0xE3C36431, 0xE554A142, 0xA1F52FA8, 0xDF35EE71, 0xE1811ABD, 0x518AEE75,
 0x2C368F10, 0xDEA57D12, 0x14087FE3, 0xC24FAE0D, 0xEF43BF59, 0xDCB2050D, 0xACB8E1D8, 0x346FE312,
 0x2225E27D, 0x54B40347, 0x36341CA6, 0xEB168AC8, 0xB2270E4E, 0x158DAD24, 0xF4DD7F10, 0xA27E0448,
 0x2CFA86D5, 0x31CC4102, 0x4E8D1268, 0xD306B906, 0xBD573B68, 0xC05056FA, 0x7CA83C1C, 0x0C5DD37D,
 0x8039A2A3, 0x1A579525, 0x39DD26D6, 0xDDCC9C0A, 0x1B34CD6E, 0x6611A35D, 0x7785BC43, 0x9C4E3E9E,
 0x97B6363C, 0x9521C04D, 0xB37B94E8, 0x0F6DF46A, 0x3D9D52E3, 0x7042230A, 0x7CF97AFB, 0x959E8CCE,
 0x68BD82B3, 0x2652D44D, 0x974D7DFC, 0x143F3DE6, 0xAC386FB6, 0xAA85298C, 0x6813CFE0, 0xAB22F8EA,
 0xF3ED6B05, 0x7D212E47, 0x843991A1, 0x78AC4F6A, 0xFB0B878D, 0xD188CE4F, 0xE6E0484F, 0x17169BC9,
 0x6C71B874, 0xABC03212, 0x0F1EB12C, 0x093278A8, 0x03F86EA6, 0xC76042EF, 0xA3F71613, 0xA49EC409,
 0xC959ACCB, 0xAFD100C0, 0x3B53519F, 0x867BEF2D, 0xCC72005D, 0x76C82735, 0xD0185D2C, 0x13692D11,
 0x84D3DBB1, 0xAF04883D, 0xA9D74A0D, 0xB7AE2F17, 0xFF1235B7, 0xCE9E3382, 0x4F6644A5, 0x397BEB6D,
 0x7BE7ADD3, 0x595B40F8, 0xEEE8AEA3, 0xF9BA3229, 0xCF1361AD, 0x52AF88C6, 0x5289CB13, 0x6A483054,
 0x6211905F, 0x157E660C, 0x5E989FC5, 0x9BF26479, 0x68F5456C, 0xC27CAC7C, 0x1499F05D, 0x0A135E6F,
 0xE8EAA41A, 0xE0EAC21E, 0x251D7680, 0xA0B03436, 0xB83890BD, 0x43919AFF, 0xA19FEBD6, 0x9677E3B8,
 0xF96BFAA0, 0xC83AF480, 0xF01D854B, 0x911A71D6, 0x01011CDD, 0x3DD5953C, 0x946C5B3B, 0xFF2DF75A,
 0x8BB2EF47, 0x2C6F491F, 0x6C3D3FDF, 0xDA43C49C, 0x1FADF13A, 0xE7ED940E, 0x94359D34, 0x4DB5B597,
 0x45F95438, 0xF18D1628, 0x64931488, 0x92C45CA5, 0xFEA0A575, 0x967B2324, 0x479D6961, 0x7D92A258,
 0xE109143B, 0xE43B3995, 0x40CF39E2, 0xC0D498E0, 0x77EF783D, 0xD50C3357, 0x8F5CD621, 0x0C91DAB8,
 0x6F509EB3, 0x40D2F8AE, 0x289431DD, 0x8FD8183B, 0x07D69E99, 0xB6017E99, 0x4FB78C2C, 0x3E527E40,
 0xD955A05E, 0x9AC8FA3D, 0x85A1822A, 0xA67E374A, 0x4E015C9A, 0xF31AE059, 0x42C9402D, 0x2ED23C27,
 0xCC5003FC, 0xDBA452CD, 0x4B263090, 0x94F5546D, 0x1C2A1A46, 0xAAD46F6B, 0xF1D09053, 0x43A6D8FA,
 0xCFE82A6D, 0xD3B1756D, 0x4DCA304D, 0xCFA0EDB2, 0x379F0D5C, 0xCE1EBDEC, 0xD18C8E3B, 0x734DC6F0,
 0x8471567E, 0x9C82375B, 0x78DF0A2C, 0xCFA4ADC6, 0xA23283E3, 0x5D79705B, 0x217F0114, 0xA052FECE,
 0x44CB4A94, 0x3782CC10, 0x265E14D1, 0x29BBEE3D, 0xA1976B3E, 0xBD2CFEC6, 0xDFA461CF, 0x29DDEADF,
 0x5623F536, 0x106E4803, 0x5700EA4A, 0x80D7A8C7, 0x5852DCCD, 0xF86626E1, 0x4B19F27D, 0xD1D988A8,
 0x7F2317FC, 0xFF92BBD9, 0x5074F91C, 0x05506938, 0xC6ED10C0, 0xBE3EDA70, 0xCF6CE477, 0xD8F6314C,
 0x949BD067, 0xC0C59930, 0x215942C1, 0x98930589, 0x4C92EA9F, 0x40ED3A43, 0x6DB8ED18, 0xECD11581,
 0x52904A2B, 0x17A517D6, 0x09413DEE, 0x375744ED, 0xB4DA0F43, 0x186E2E07, 0x92F75ED4, 0x057AEA71,
 0x40DA7846, 0x03CF2CA3, 0xA9178354, 0xE63180C6, 0x103F0EE4, 0xCEC3B5F9, 0x685388D7, 0x64579DA5,
 0x56F67DCB, 0x82EA5391, 0x66D52A70, 0xB3B79D2D, 0xE004C87A, 0x67183F68, 0x610B3401, 0x2EEDFECA,
 0x897CDF39, 0xB8AD5F77, 0x1E60E422, 0x35513D22, 0x5ADCAB84, 0xA3D155C6, 0x9C5F3F4E, 0xC1000CC0,
 0xD8BEF693, 0x70B5A856, 0x43111491, 0x3F752148, 0xDC41CE25, 0x06FD010D, 0x0DE38323, 0x662A21C4,
 0xA704EE39, 0x6C20FE93, 0x32036DA1, 0xE79A913C, 0x353739C0, 0xAD68358C, 0x0E93E303, 0x14FBB4CB,
 0x680A4ED8, 0xD6CFDF68, 0x98BDC6B4, 0x5F080CA6, 0x6E7B0127, 0xFB300514, 0x01099C35, 0x168E8842,
 0xB2A3C054, 0x1ECAE905, 0x2D8C9F3A, 0xAD1B70CA, 0x3A3CC948, 0x6741F967, 0xD39376CC, 0xE0A645B5,
 0x549E800E, 0xB0037420, 0x56E77C1B, 0xD45C696D, 0x2B4A1CAE, 0x7079A193, 0xAC782881, 0x65F04CC3,
 0xCD08D92E, 0x54E9853C, 0x1101D0D4, 0xB63AFC00, 0x9F36DE56, 0xCE3CBE4D, 0x7CE0FBC3, 0xE873AB4C,
 0x03ED2F02, 0x047BF6AC, 0x7D0FED7A, 0x97A37798, 0x563A740E, 0x6D836F81, 0x3C5047FB, 0xA2FE8A26,
 0xB2104C4B, 0x7BFA6C9F, 0xB11BE9C5, 0x16DFCEA5, 0x2B609FE7, 0xF64EC915, 0x1189DE52, 0x038B2BE0,
 0xF3CF68A4, 0xD04D5BBF, 0x1F07FC1D, 0xFF303616, 0x63F2467A, 0xD4582919, 0xBEE79211, 0xE31E6C24,
 0x5C8BA7AE, 0xB6EF74FD, 0x0DB2C5C4, 0xFFE97E77, 0x4F80CE29, 0x5025BFFB, 0x9C93368B, 0x2E6930D0,
 0x823B9B18, 0x61FCBF5D, 0x110590A0, 0x239772BF, 0x0C5113E1, 0x3ECF3162, 0xAFFFC3FD, 0x28C9B7A6,
 0xA8EDD449, 0x5AFAE851, 0x9B10AE81, 0x94069F45, 0xB66FFA93, 0x93580F5A, 0xB5DF53EA, 0xB0163584,
 0x95FCC858, 0x0AA49204, 0x1877AF3F, 0xEF1A7956, 0x6E2A47C0, 0x62F35AA7, 0xE98DBC25, 0x2A8BC92A,
 0x1C339B7E, 0xD73948E9, 0x9A803DE2, 0x618FFA1B, 0x25AABAEB, 0x502D3F13, 0xB7C82BF5, 0x08A6ABBF,
 0x63DC8547, 0xC7C2CF20, 0x9071A975, 0x75968428, 0xB1532E1A, 0xF2F1B694, 0xA8B41246, 0xE862AA9C,
 0x555B15FE, 0x49E4C072, 0xBEC1D1C4, 0xDBDF9763, 0x54D207A5, 0xC18082AE, 0x46543C0D, 0x3A8385CB,
 0xBC87EF3C, 0xFAAC56EB, 0x4A766AAA, 0x30E39EE2, 0x60C2616D, 0x69FCD959, 0xD4F2243E, 0xA63A3009,
 0x14D9B76A, 0xC5663B20, 0x4DF1B2D4, 0x1F21BFC8, 0xC7F1CD51, 0x6BABE671, 0xA337DF4A, 0xF5016BD8,
 0x26749798, 0xAF8C86BB, 0x1C669DED, 0xDB5799E5, 0xE163D045, 0xAD79345C, 0x5825D9FF, 0x59648215,
 0xABC47266, 0x9AB33F93, 0x9A55B51F, 0xF30BE189, 0x147F7AD1, 0x634D0AF9, 0x0F9E3F42, 0x97D8B236,
 0x49CE433B, 0x38F6B942, 0x662E61B0, 0x32A96086, 0xFF473324, 0xC2F0E28E, 0x3485A902, 0xF58D252A,
 0x0668CEC7, 0x5012FDFE, 0xF2E4F730, 0x6BAFA605, 0x369A51F5, 0x6666A66F, 0xD68718B7, 0x7C93BE85,
 0xDCDC8107, 0x705762AE, 0xBFE2CEB8, 0x4B6677A7, 0x5B803122, 0xB9310C88, 0x551F12BD, 0x133C2B82,
 0x88BD0ABD, 0xD4E7659A, 0x6521844A, 0xCA214C03, 0xF65B88B1, 0xD2926A11, 0xDD73D089, 0xC0F2DB35,
 0x4F2E837A, 0xDD55935C, 0xF8332072, 0x47772371, 0xAA3A650F, 0xB3D5D9BB, 0x821DD8CD, 0x593D441A,
 0x195C30AB, 0x54F884EC, 0x47B7EA28, 0xFBA5CADE, 0x5CF8E2E8, 0x82405EB6, 0x7E088868, 0x44704663,
 0x79E954F4, 0x9C06F941, 0x73984E0D, 0x16F54DEC, 0xAD57F761, 0x4BBF3FC6, 0x77F2B971, 0x3D4C9A6A,
 0x776BB627, 0xDE4B7776, 0x560D360B, 0x03F4AE3A, 0x7996D12E, 0x165F40CB, 0xB58A5579, 0xBC78E488,
 0xEE1F25FF, 0xC6525C43, 0x65F8CC2B, 0xE653C450, 0x72261E53, 0xF0E6CE8B, 0x10048C7D, 0x1E42E783,
 0x983D48DA, 0xC1E2C638, 0x244D2CBA, 0x04A6FEB9, 0xC4D0EB96, 0x80B92CCD, 0x84BD5FBB, 0x73EB0B4B,
 0x225A67A7, 0xDEEDBACD, 0xF02607D2, 0x419B23AC, 0xF16FDCD0, 0x9860CEA1, 0xE6D70A4A, 0x79615A72,
 0x29B72EA1, 0x1F61F8FF, 0x0884A81E, 0xCEB0F0BF, 0x5CFCA29C, 0x17EDD009, 0xED6F45DF, 0xB483C94C,
 0xAAF66CCA, 0x5CBCE5AB, 0xD898B546, 0x48745311, 0x4B48B49A, 0x481AD71B, 0x97A737EC, 0xC397FAB1,
 0xFEE4A236, 0xCCA3C8D4, 0x71E1B218, 0x72AA50A1, 0xD0FA97D4, 0xEF9AF738, 0xF0C08D5E, 0x28C5773A,
 0x161B4788, 0xEF52BE89, 0x8A043FF1, 0xE127D706, 0xF7A1DFAC, 0x6E590286, 0x565C70EC, 0x9A37F189,
 0x9112F13E, 0x2A5A01A3, 0x1B1A0E53, 0x758B4564, 0x59138727, 0x0AC6D692, 0x7A6EBF88, 0xD13F0224,
 0x167D436A, 0x18E62081, 0x27468934, 0x69835C83, 0x5EAB9DB4, 0x60282B7D, 0xBE541E0E, 0x862EE9BE,
 0xC01CD151, 0x0D2BCA92, 0x1CEE936B, 0x6EE64E05, 0x8D9A66B7, 0xB308D1AE, 0x3BC2DE21, 0x4E271F4F,
 0xCBDB1B1E, 0x4A90E026, 0x59BDCA74, 0x87B6FA35, 0x1ECEA971, 0xB8211185, 0x3E7CBD7D, 0xCACF4667,
 0xB45EC159, 0x13296A26, 0x4BA6BEFE, 0x0A1F9EF3, 0x561C37DB, 0x554294C6, 0x3409E7F0, 0xD5917C75,
 0xF9F6B582, 0xBE909723, 0x421CC8D0, 0xBC5627B5, 0xFD85C3C6, 0xE8C46727, 0xF3702427, 0x0B8B4DE4,
 0x3638DC3A, 0x55E01909, 0x078F5896, 0x04993C54, 0x81FC3753, 0xE3B02177, 0xD1FB8B09, 0xD24F6204,
 0x64ACD665, 0xD7E88060, 0x9DA9A8CF, 0xC33DF796, 0xE639002E, 0x3B64139A, 0xE80C2E96, 0x89B49688,
 0xC269EDD8, 0xD782441E, 0xD4EBA506, 0xDBD7178B, 0x7F891ADB, 0xE74F19C1, 0xA7B32252, 0x9CBDF5B6,
 0x3DF3D6E9, 0xACADA07C, 0xF7745751, 0xFCDD1914, 0x6789B0D6, 0xA957C463, 0x2944E589, 0xB524182A,
 0x3108C82F, 0x8ABF3306, 0xAF4C4FE2, 0x4DF9323C, 0x347AA2B6, 0xE13E563E, 0x8A4CF82E, 0x0509AF37,
 0x7475520D, 0x7075610F, 0x128EBB40, 0xD0581A1B, 0xDC1C485E, 0x21C8CD7F, 0x50CFF5EB, 0x4B3BF1DC,
 0x7CB5FD50, 0xE41D7A40, 0x780EC2A5, 0xC88D38EB, 0x00808E6E, 0x9EEACA9E, 0x4A362D9D, 0xFF96FBAD,
 0xC5D977A3, 0x9637A48F, 0x361E9FEF, 0x6D21E24E, 0x0FD6F89D, 0x73F6CA07, 0xCA1ACE9A, 0x26DADACB,
 0x22FCAA1C, 0x78C68B14, 0xB2498A44, 0xC9622E52, 0x7F5052BA, 0xCB3D9192, 0x23CEB4B0, 0xBEC9512C,
 0xF0848A1D, 0x721D9CCA, 0x20679CF1, 0xE06A4C70, 0xBBF7BC1E, 0xEA8619AB, 0x47AE6B10, 0x8648ED5C,
 0x37A84F59, 0xA0697C57, 0x944A18EE, 0xC7EC0C1D, 0x83EB4F4C, 0x5B00BF4C, 0x27DBC616, 0x1F293F20,
 0xECAAD02F, 0x4D647D1E, 0x42D0C115, 0x533F1BA5, 0xA700AE4D, 0xF98D702C, 0xA164A016, 0x17691E13,
 0xE62801FE, 0x6DD22966, 0xA5931848, 0x4A7AAA36, 0x8E150D23, 0xD56A37B5, 0x78E84829, 0xA1D36C7D,
 0xE7F41536, 0xE9D8BAB6, 0x26E51826, 0x67D076D9, 0x1BCF86AE, 0xE70F5EF6, 0x68C6471D, 0x39A6E378,
 0xC238AB3F, 0x4E411BAD, 0x3C6F8516, 0xE7D256E3, 0xD11941F1, 0x2EBCB82D, 0x10BF808A, 0x50297F67,
 0x2265A54A, 0x9BC16608, 0x932F0A68, 0x14DDF71E, 0x50CBB59F, 0xDE967F63, 0xEFD230E7, 0x14EEF56F,
 0xAB11FA9B, 0x08372401, 0xAB807525, 0xC06BD463, 0xAC296E66, 0xFC331370, 0x258CF93E, 0x68ECC454,
 0xBF918BFE, 0x7FC95DEC, 0x283A7C8E, 0x02A8349C, 0x63768860, 0xDF1F6D38, 0x67B6723B, 0xEC7B18A6,
 0x4A4DE833, 0xE062CC98, 0x90ACA160, 0xCC4982C4, 0xA649754F, 0x20769D21, 0xB6DC768C, 0xF6688AC0,
 0x29482515, 0x0BD28BEB, 0x84A09EF7, 0x9BABA276, 0xDA6D07A1, 0x0C371703, 0xC97BAF6A, 0x02BD7538,
 0xA06D3C23, 0x01E79651, 0x548BC1AA, 0x7318C063, 0x881F8772, 0xE761DAFC, 0xB429C46B, 0xB22BCED2,
 0xAB7B3EE5, 0x417529C8, 0xB36A9538, 0x59DBCE96, 0x7002643D, 0xB38C1FB4, 0x30859A00, 0x9776FF65,
 0xC4BE6F9C, 0x5C56AFBB, 0x0F307211, 0x1AA89E91, 0x2D6E55C2, 0x51E8AAE3, 0x4E2F9FA7, 0xE0800660,
 0x6C5F7B49, 0xB85AD42B, 0x21888A48, 0x9FBA90A4, 0xEE20E712, 0x837E8086, 0x06F1C191, 0xB31510E2,
 0xD382771C, 0xB6107F49, 0x1901B6D0, 0x73CD489E, 0x1A9B9CE0, 0xD6B41AC6, 0x8749F181, 0x0A7DDA65,
 0x3405276C, 0x6B67EFB4, 0x4C5EE35A, 0xAF840653, 0x373D8093, 0xFD98028A, 0x0084CE1A, 0x0B474421,
 0xD951E02A, 0x0F657482, 0x16C64F9D, 0x568DB865, 0x9D1E64A4, 0x33A0FCB3, 0xE9C9BB66, 0x705322DA,
 0x2A4F4007, 0xD801BA10, 0xAB73BE0D, 0x6A2E34B6, 0x95A50E57, 0xB83CD0C9, 0xD63C1440, 0x32F82661,
 0x66846C97, 0x2A74C29E, 0x0880E86A, 0x5B1D7E00, 0xCF9B6F2B, 0xE71E5F26, 0x3E707DE1, 0x7439D5A6,
 0x01F69781, 0x023DFB56, 0x3E87F6BD, 0x4BD1BBCC, 0xAB1D3A07, 0xB6C1B7C0, 0x1E2823FD, 0xD17F4513,
 0xD9082625, 0xBDFD364F, 0xD88DF4E2, 0x8B6FE752, 0x95B04FF3, 0x7B27648A, 0x08C4EF29, 0x01C595F0,
};
#endif

uint8_t *buf_rdmz;
/*#define NAND_DEBUG*/
unsigned int wmt_version;
#include <linux/mtd/partitions.h>
#define NUM_NAND_PARTITIONS ARRAY_SIZE(nand_partitions)
struct mtd_partition nand_partitions[] = {
	/*{
		.name		= "w-load-NAND",
		.offset		= 0x00000000,
		.size		= 0x00020000,
	},
	{
		.name		= "u-boot env. cfg. 1-NAND",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x00120000,
	},
	{
		.name		= "u-boot-NAND",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x00120000,
	},*/
	/*{
		.name		= "kernel-NAND",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x00800000,
	},*/
	/*{
		.name		= "filesystem-NAND",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x10000000,
	},*/
	{
		.name		= "misc",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x00200000,
	},
	{
		.name		= "u-boot-logo",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x200000,
	},
	{
		.name		= "kernel-logo",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x400000,
	},
	{
		.name		= "cache",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x8000000,
	},
	{
		.name		= "system",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x10000000,
	},
	/*{
		.name		= "sdcard",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x10000000,
	},*/
	{//6+5
		.name		= "recovery",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x1000000,
	},
	{//6+6
		.name		= "boot",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x1000000,
	},
	{//6+7
		.name		= "efs",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x200000,
	},
	{//6+8
		.name		= "radio",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x200000,
	},
	{//6+9
		.name		= "keydata",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x200000,
	},
	{//6+10
		.name		= "swap",
		.offset		= MTDPART_OFS_APPEND,
		.size		= 0x8000000,
	},
	{//6+11
		.name		= "userdata",
		.offset		= MTDPART_OFS_APPEND,
		.size		= MTDPART_SIZ_FULL,
	}
};
EXPORT_SYMBOL(nand_partitions);


#ifdef CONFIG_MTD_NAND_WMT_HWECC
	static int MAX_CHIP = CONFIG_MTD_NAND_CHIP_NUM;
	static int hardware_ecc = 1;
#else
	#define MAX_CHIP 1
	static int hardware_ecc = 0;
#endif

static unsigned char parity[MAX_PARITY_SIZE];
static unsigned int bch_err_pos[MAX_ECC_BIT_ERROR];
static unsigned int bch_err_pos[MAX_ECC_BIT_ERROR];


/*
 * hardware specific Out Of Band information
*/

/*
* new oob placement block for use with hardware ecc generation
*/

static struct nand_ecclayout wmt_oobinfo_2048 = {
/* nand flash new structure and BCH ECC oob info */
	.eccbytes = 7,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};


static struct nand_ecclayout wmt_12bit_oobinfo_4096 = {
/* nand flash old structure and Harming ECC oob info */
	.eccbytes = 20,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30,
							31, 32, 33, 34, 35, 36, 37,
							38, 39, 40, 41, 42, 43},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};
/*
static struct nand_ecclayout wmt_8bit_oobinfo_4096 = {
// nand flash old structure and Harming ECC oob info
	.eccbytes = 13,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30,
							31, 32, 33, 34, 35, 36},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};*/
static struct nand_ecclayout wmt_oobinfo_8192 = {
/* nand flash new structure and Harming ECC oob info */
	.eccbytes = 42,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30,
							31, 32, 33, 34, 35, 36, 37,
							38, 39, 40, 41, 42, 43, 44,
							45, 46, 47, 48, 49, 50, 51,
							52, 53, 54, 55, 56, 57, 58,
							59, 60, 61, 62, 63, 64, 65},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};

static struct nand_ecclayout wmt_oobinfo_16k = {
/* nand flash new structure and Harming ECC oob info */
	.eccbytes = 70,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30,
							31, 32, 33, 34, 35, 36, 37,
							38, 39, 40, 41, 42, 43, 44,
							45, 46, 47, 48, 49, 50, 51,
							52, 53, 54, 55, 56, 57, 58,
							59, 60, 61, 62, 63, 64, 65,
							66, 67, 68, 69, 70, 71, 72,
							73, 74, 75, 76, 77, 78, 79,
							80, 81, 82, 83, 84, 85, 86,
							87, 88, 89, 90, 91, 92, 93},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};
static struct nand_ecclayout wmt_oobinfo_4096 = {
/* nand flash old structure and Harming ECC oob info */
	.eccbytes = 7,
	.eccpos = { 24, 25, 26, 27, 28, 29, 30},
	.oobavail = 24,
	.oobfree = {{0, 24} }
};


	static struct nand_ecclayout wmt_oobinfo_512 = {
   .eccbytes = 8,
   .eccpos = { 4, 5, 6, 8, 9, 10, 12, 13},
   .oobfree = {{0, 4},{7, 1},{11,1},{14,2}}
	};

/* Ick. The BBT code really ought to be able to work this bit out
	 for itself from the above, at least for the 2KiB case
*/
#if 1
	static uint8_t wmt_bbt_pattern_2048[] = { 'B', 'b', 't', '0' };
	static uint8_t wmt_mirror_pattern_2048[] = { '1', 't', 'b', 'B' };
#endif
/*static uint8_t wmt_bbt_pattern_2048[] = { 0xFF, 0xFF };*/
/*static uint8_t wmt_mirror_pattern_2048[] = { 0xFF, 0xFF };*/


/*static uint8_t wmt_bbt_pattern_512[] = { 0xBB };*/
/*static uint8_t wmt_mirror_pattern_512[] = { 0xBC };*/
static uint8_t wmt_rdmz[] = { 'z', 'm', 'd', 'r' };
static uint8_t retry_table[] = {'r','e','t','r','y','t','a','b','l','e'};

static struct nand_bbt_descr wmt_rdtry_descr = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	0,
	.len = 10,
	.veroffs = 0,
	.maxblocks = 4,
	.pattern = retry_table,
};

static struct nand_bbt_descr wmt_bbt_main_descr_2048 = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	4,
	.len = 4,
	.veroffs = 0,
	.maxblocks = 4,
	.pattern = wmt_bbt_pattern_2048,
};

static struct nand_bbt_descr wmt_bbt_mirror_descr_2048 = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	4,
	.len = 4,
	.veroffs = 0,
	.maxblocks = 4,
	.pattern = wmt_mirror_pattern_2048,
};

static struct nand_bbt_descr wmt_bbt_main_descr_512 = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	0,
	.len = 4,
	.veroffs = 14,
	.maxblocks = 4,
	.pattern = wmt_bbt_pattern_2048,
};

static struct nand_bbt_descr wmt_bbt_mirror_descr_512 = {
	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
	.offs =	0,
	.len = 4,
	.veroffs = 14,
	.maxblocks = 4,
	.pattern = wmt_mirror_pattern_2048,
};


/* controller and mtd information */

static void print_nand_register(struct mtd_info *mtd);
void print_nand_buffer(char *value, unsigned int length);
#ifdef NAND_DEBUG
static void print_nand_buffer_int(unsigned int *value, unsigned int length);
#endif

struct wmt_nand_set {
	int	nr_chips;
	int	nr_partitions;
	char *name;
	int *nr_map;
	struct mtd_partition *partitions;
};

#if 0
	struct wmt_platform_nand {
		/* timing information for controller, all times in nanoseconds */

		int	tacls;	/* time for active CLE/ALE to nWE/nOE */
		int	twrph0;	/* active time for nWE/nOE */
		int	twrph1;	/* time for release CLE/ALE from nWE/nOE inactive */

		int nr_sets;
		struct wmt_nand_set *sets;
		void (*select_chip)(struct s3c2410_nand_set *, int chip);
	}
#endif

struct wmt_nand_info;

struct wmt_nand_mtd {
	struct mtd_info	mtd;
	struct nand_chip chip;
	/*struct wmt_nand_set* set;*/
	struct wmt_nand_info *info;
	int	scan_res;
};

/* overview of the wmt nand state */

struct wmt_nand_info {
	/* mtd info */
	struct nand_hw_control controller;
	struct wmt_nand_mtd *mtds;
	struct wmt_platform_nand *platform;

	/* device info */
	struct device *device;
	struct resource *area;
	void __iomem *reg;
	int cpu_type;
	int datalen;
	int nr_data;
	int data_pos;
	int page_addr;
	dma_addr_t dmaaddr;
	dma_addr_t last_bank_dmaaddr;
	int dma_finish;
	int phase;
	void *done_data;	/* completion	data */
	unsigned int isr_cmd;
	unsigned int cur_page;
	unsigned int last_bank_col;
	unsigned int oob_col;
	//void (*done)(void *data);/*	completion function	*/
	unsigned char *dmabuf;
	int ECC_bytes;
	int ECC_mode;
	int oob_ECC_bytes;
	int oob_ECC_mode;
	int oob_ecc_error;
	int data_ecc_uncor_err; /*  use read retry for data area has uncorrectable error*/
};

/* conversion functions */

static struct wmt_nand_mtd *wmt_nand_mtd_toours(struct mtd_info *mtd)
{
	return container_of(mtd, struct wmt_nand_mtd, mtd);
}

static struct wmt_nand_info *wmt_nand_mtd_toinfo(struct mtd_info *mtd)
{
	return wmt_nand_mtd_toours(mtd)->info;
}

/*
static struct wmt_nand_info *to_nand_info(struct platform_device *dev)
{
	return platform_get_drvdata(dev);
}
*/
/*
static struct platform_device *to_platform(struct device *dev)
{
	return container_of(dev, struct platform_device, dev);
}
*/
#if 0
static struct wmt_platform_nand *to_nand_plat(struct platform_device *dev)
{
	return dev->dev.platform_data;
}
#endif

/*
 * type : HW or SW ECc
 *
*/
static void nfc_ecc_set(struct wmt_nand_info *info, int type)
{
/* struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);*/

	if (type == hardware_ecc)
		writeb(readb(info->reg + WMT_NFC_MISC_CTRL) & 0xfb, info->reg + WMT_NFC_MISC_CTRL);
	else
		writeb(readb(info->reg + WMT_NFC_MISC_CTRL) | 0x04, info->reg + WMT_NFC_MISC_CTRL);
}

void copy_filename (char *dst, char *src, int size)
{
	if (*src && (*src == '"')) {
		++src;
		--size;
	}

	while ((--size > 0) && *src && (*src != '"')) {
		*dst++ = *src++;
	}
	*dst = '\0';
}

int set_ECC_mode(struct mtd_info *mtd)
{
	unsigned int ECCbit = mtd->dwECCBitNum;
	unsigned int ECC_mode;
	switch (ECCbit) {
		case 1:
			ECC_mode = ECC1bit;
			break;
		case 4:
			ECC_mode = ECC4bit;
			break;
		case 8:
			ECC_mode = ECC8bit;
			break;
		case 12:
			ECC_mode = ECC12bit;
			break;
		case 16:
			ECC_mode = ECC16bit;
			break;
		case 24:
			ECC_mode = ECC24bitPer1K;
			break;
		case 40:
			ECC_mode = ECC24bitPer1K;
			break;
		default:
			printk("ecc mode input not support ECCbit=%d\n", ECCbit);
			return -1;
	}
	//set_ecc_engine(info, ECC_mode);  /* BCH ECC new structure */
	return ECC_mode;
}
void calculate_ECC_info(struct mtd_info *mtd, struct ECC_size_info *ECC_size)
{
	switch (ECC_size->ecc_engine)	{
		case ECC4bit:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC4bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 4;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_size = 512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC4bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC4bit_byte_count;
		ECC_size->oob_ECC_mode = ECC4bit;
		ECC_size->unprotect = ECC4bit_unprotect;
		break;
		case ECC8bit:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC8bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 8;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_size = 512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC8bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC8bit_byte_count;
		ECC_size->oob_ECC_mode = ECC8bit;
		ECC_size->unprotect = ECC8bit_unprotect;
		break;
		case ECC12bit:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC12bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 12;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_size = 512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC12bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC12bit_byte_count;
		ECC_size->oob_ECC_mode = ECC12bit;
		ECC_size->unprotect = ECC12bit_unprotect;
		break;
		case ECC16bit:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC16bit_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 16;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_size = 512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC16bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC16bit_byte_count;
		ECC_size->oob_ECC_mode = ECC16bit;
		ECC_size->unprotect = ECC16bit_unprotect;
		break;
		case ECC24bitPer1K:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC24bitPer1K_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 24;
		ECC_size->banks = mtd->writesize/1024;
		ECC_size->bank_size = 1024;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC24bitPer1K_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC24bitPer1K_byte_count;
		ECC_size->oob_ECC_mode = ECC24bitPer1K;
		ECC_size->unprotect = ECC24bitPer1K_unprotect;
		break;
		case ECC40bitPer1K:
		ECC_size->ecc_bits_count = ECC40bitPer1K_bit_count;
		ECC_size->oob_ecc_bits_count = ECC24bitPer1K_bit_count;
		ECC_size->max_bit_error = 40;
		ECC_size->oob_max_bit_error = 24;
		ECC_size->banks = mtd->writesize/1024;
		ECC_size->bank_size = 1024;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC40bitPer1K_byte_count;
		ECC_size->ECC_bytes = ECC40bitPer1K_byte_count;
		ECC_size->oob_ECC_bytes = ECC24bitPer1K_byte_count;
		ECC_size->oob_ECC_mode = ECC24bitPer1K;
		ECC_size->unprotect = ECC40bitPer1K_unprotect;
		break;
		case ECC44bitPer1K:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC44bitPer1K_bit_count;
		ECC_size->oob_max_bit_error = ECC_size->max_bit_error = 44;
		ECC_size->banks = mtd->writesize/1024;
		ECC_size->bank_size = 1024;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC44bitPer1K_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC44bitPer1K_byte_count;
		ECC_size->oob_ECC_mode = ECC44bitPer1K;
		ECC_size->unprotect = ECC44bitPer1K_unprotect;
		break;
		/*case 8:
		ECC_size->oob_ecc_bits_count = ECC_size->ecc_bits_count = ECC44bit_bit_count;
		ECC_size->max_bit_error = 44;
		ECC_size->banks = mtd->writesize/512;
		ECC_size->bank_offset = mtd->writesize/ECC_size->banks + ECC44bit_byte_count;
		ECC_size->oob_ECC_bytes = ECC_size->ECC_bytes = ECC44bit_byte_count;
		ECC_size->unprotect = ECC44bitPer1K_unprotect;
		break;*/
		default:
		printk("%d-bit ECC engine is not support:\r\n", ECC_size->ecc_engine);
		break;;
	}
	return;
}

/*
 * Get the flash and manufacturer id and lookup if the type is supported
 */
static struct WMT_nand_flash_dev *get_flash_type(struct mtd_info *mtd,
						  struct nand_chip *chip,
						  int busw, unsigned int *maf_id, int CE, unsigned int *spec_clk, unsigned int *spec_tadl)
{
	struct WMT_nand_flash_dev *type = NULL, type_env;
	int i, dev_id, maf_idx, ret = 0;
	unsigned int id = 0, id_5th = 0;
	char varval[200], *s = NULL, *tmp, varname[] = "wmt.io.nand";
	unsigned int varlen = 200, value, tmp_id;
	uint64_t min_partition_size;

	/* Select the device */
	chip->select_chip(mtd, CE);

	/*  reset test: edwardwan add for debug 20071229  start*/
	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
	/*  reset test: edwardwan add for debug 20071229  end*/

	/* Send the command for reading device ID */
	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);

	/* Read manufacturer and device IDs */
	*maf_id = chip->read_byte(mtd);
	for (i = 0; i < 3; i++) {
		dev_id = chip->read_byte(mtd);
		id += ((unsigned char)dev_id) <<((2-i)*8);
	}
	for (i = 0; i < 4; i++) {
		dev_id = chip->read_byte(mtd);
		id_5th += ((unsigned char)dev_id) <<((3-i)*8);
	}
	printk("nand chip device id = 0x%x 0x%x\n", id, id_5th);
	#ifdef NAND_DEBUG
	printk("nand chip device maf_id is %x, and dev_id is %x\n",*maf_id,dev_id);
	#endif
	tmp_id = (unsigned int)id + ((*maf_id)<<24);
	/* Lookup the flash id */
	/*for (i = 0; nand_flash_ids[i].name != NULL; i++) {
		if (dev_id == nand_flash_ids[i].id) {
			type =  &nand_flash_ids[i];*/
	for (i = 0; WMT_nand_flash_ids[i].dwFlashID != 0; i++) {
		if (((unsigned int)id + ((*maf_id)<<24)) == WMT_nand_flash_ids[i].dwFlashID) {
			if (WMT_nand_flash_ids[i].dwFlashID == 0x98D79432)
				if (id_5th != WMT_nand_flash_ids[i].dwFlashID2)
					continue;
			type =  &WMT_nand_flash_ids[i];
			/*printk("find nand chip device id i=%d\n", i);*/
			break;
		}
	}
	value = *((volatile unsigned int *)(GPIO_BASE_ADDR + 0x100));
	if (!((value&6) == 2))
		ret = wmt_getsyspara(varname, varval, &varlen);
	if (!ret && !((value&6) == 2)) {
		s = varval;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwFlashID = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwBlockCount = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwPageSize = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwSpareSize = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwBlockSize = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwAddressCycle = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwBI0Position = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwBI1Position = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwBIOffset = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwDataWidth = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwPageProgramLimit = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwSeqRowReadSupport = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwSeqPageProgram = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwNandType = value; s = tmp+1;
		value = simple_strtoul(s, &tmp, 16);
		type_env.dwRWTimming = value; s = tmp+1;
		copy_filename(type_env.ProductName, s, MAX_PRODUCT_NAME_LENGTH);

		if (type_env.dwBlockCount < 1024 || type_env.dwBlockCount > 16384) {
			printk(KERN_INFO "dwBlockCount = 0x%x is abnormal\n", type_env.dwBlockCount);
			goto list;
		}
		if (type_env.dwPageSize < 512  || type_env.dwPageSize > 16384) {
			printk(KERN_INFO "dwPageSize = 0x%x is abnormal\n", type_env.dwPageSize);
			goto list;
		}
		if (type_env.dwPageSize > 512)
			type_env.options = NAND_SAMSUNG_LP_OPTIONS | NAND_NO_READRDY | NAND_NO_AUTOINCR;
		if (type_env.dwBlockSize < (1024*64)  || type_env.dwBlockSize > (16384*256)) {
			printk(KERN_INFO "dwBlockSize = 0x%x is abnormal\n", type_env.dwBlockSize);
			goto list;
		}
		if (type_env.dwAddressCycle < 3  || type_env.dwAddressCycle > 5) {
			printk(KERN_INFO "dwAddressCycle = 0x%x is abnoraml\n", type_env.dwAddressCycle);
			goto list;
		}
		if (type_env.dwBI0Position != 0  &&
		type_env.dwBI0Position > ((type_env.dwBlockSize/type_env.dwPageSize)-1)) {
			printk(KERN_INFO "dwBI0Position = 0x%x is abnoraml\n", type_env.dwBI0Position);
			goto list;
		}
		if (type_env.dwBI1Position != 0  &&
		type_env.dwBI1Position > ((type_env.dwBlockSize/type_env.dwPageSize)-1)) {
			printk(KERN_INFO "dwBI1Position = 0x%x is abnoraml\n", type_env.dwBI1Position);
			goto list;
		}
		if (type_env.dwBIOffset != 0 && type_env.dwBIOffset != 5) {
			printk(KERN_INFO "dwBIOffset = 0x%x is abnoraml\n", type_env.dwBIOffset);
			goto list;
		}
		if (type_env.dwDataWidth != 0/* && type_env.dwDataWidth != 1*/) {
			printk(KERN_INFO "dwDataWidth = 0x%x is abnoraml\n", type_env.dwDataWidth);
			goto list;
		}
		/*printk(KERN_INFO "dwFlashID = 0x%x\n", type_env.dwFlashID);
		printk(KERN_INFO "dwBlockCount = 0x%x\n", type_env.dwBlockCount);
		printk(KERN_INFO "dwPageSize = 0x%x\n", type_env.dwPageSize);
		printk(KERN_INFO "dwSpareSize = 0x%x\n", type_env.dwSpareSize);
		printk(KERN_INFO "dwBlockSize = 0x%x\n", type_env.dwBlockSize);
		printk(KERN_INFO "dwAddressCycle = 0x%x\n", type_env.dwAddressCycle);
		printk(KERN_INFO "dwBI0Position = 0x%x\n", type_env.dwBI0Position);
		printk(KERN_INFO "dwBI1Position = 0x%x\n", type_env.dwBI1Position);
		printk(KERN_INFO "dwBIOffset = 0x%x\n", type_env.dwBIOffset);
		printk(KERN_INFO "dwDataWidth = 0x%x\n", type_env.dwDataWidth);
		printk(KERN_INFO "dwPageProgramLimit = 0x%x\n", type_env.dwPageProgramLimit);
		printk(KERN_INFO "dwSeqRowReadSupport = 0x%x\n", type_env.dwSeqRowReadSupport);
		printk(KERN_INFO "dwSeqPageProgram = 0x%x\n", type_env.dwSeqPageProgram);
		printk(KERN_INFO "dwNandType = 0x%x\n", type_env.dwNandType);
		printk(KERN_INFO "dwECCBitNum = 0x%x\n", type_env.dwECCBitNum);
		printk(KERN_INFO "dwRWTimming = 0x%x\n", type_env.dwRWTimming);
		printk(KERN_INFO "cProductName = %s\n", type_env.ProductName);*/
		if (((unsigned int)id + ((*maf_id)<<24)) == type_env.dwFlashID) {
			if (type)
				printk(KERN_INFO "flash id has been established in flash id list\n");
			type = &type_env;
		}
	}
list:

	if (!type) {
		/*printk("before ERR_PTR(-ENODEV)\n");*/
		return ERR_PTR(-ENODEV);
	}
	if (!mtd->name)
		/*mtd->name = type->name;*/
		/*mtd->name = type->ProductName;*/
		mtd->name = "WMT.nand";

	/*chip->chipsize = type->chipsize << 20;*/
	chip->chipsize = (uint64_t)type->dwBlockCount * (uint64_t)type->dwBlockSize;

	/* get all information from table */
	chip->cellinfo = type->dwNandType << 2;
	mtd->writesize = type->dwPageSize;
	mtd->oobsize = type->dwSpareSize;
	mtd->erasesize = type->dwBlockSize;
	mtd->dwECCBitNum = type->dwECCBitNum;
	mtd->dwRetry = type->dwRetry;
	mtd->dwRdmz = type->dwRdmz;
	if (CE == 0) {
		mtd->id = type->dwFlashID;
		mtd->id2 = type->dwFlashID2;
	}
	mtd->blkcnt = type->dwBlockCount;
	mtd->pagecnt = mtd->erasesize/mtd->writesize;
	busw = type->dwDataWidth ? NAND_BUSWIDTH_16 : 0;
	if (mtd->writesize < 8192 && mtd->oobsize >= 218)
		ECC8BIT_ENGINE = 1;
	*spec_clk = type->dwRWTimming;
	*spec_tadl = type->dwTadl;

	/*if (((*(volatile unsigned long *)(GPIO_BASE_ADDR + 0x100))&2) == 2) {*/
	min_partition_size = ((type->dwBlockSize * 4) < 0x200000) ? 0x200000 : (type->dwBlockSize * 4);
	nand_partitions[0].size = min_partition_size;
	nand_partitions[1].size = min_partition_size;
	nand_partitions[2].size = 0x400000;
	nand_partitions[3].size = 0x8000000;
	nand_partitions[4].size = 0x10000000;
	nand_partitions[5].size = 0x1000000;
	nand_partitions[6].size = 0x1000000;
	nand_partitions[7].size = min_partition_size;
	nand_partitions[8].size = min_partition_size;
	nand_partitions[9].size = min_partition_size;
	nand_partitions[10].size = 0x8000000;
	//nand_partitions[11].size = MTDPART_SIZ_FULL;
	min_partition_size = 0;
	for (i = 0; i < 11; i++)
		min_partition_size += nand_partitions[i].size;
	nand_partitions[11].size = chip->chipsize -	min_partition_size - (type->dwBlockSize * 8);
	/*}*/

#if 0
	/* Newer devices have all the information in additional id bytes */
	if (!type->pagesize) {
		int extid;
		/*printk("calculate nand chip device type\n");*/
		/* The 3rd id byte holds MLC / multichip data */
		chip->cellinfo = chip->read_byte(mtd);
		/* The 4th id byte is the important one */
		extid = chip->read_byte(mtd);
		/* Calc pagesize */
		mtd->writesize = 1024 << (extid & 0x3);
		extid >>= 2;
		/* Calc oobsize */
		/* DannierChen add support 4096+218 page size */
		if((extid&0x03) == 2) {
			mtd->oobsize = 218;
			ECC8BIT_ENGINE = 1;
		} else
			mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
		extid >>= 2;
		/* Calc blocksize. Blocksize is multiples of 64KiB */
		mtd->erasesize = (64 * 1024) << (extid & 0x03);
		extid >>= 2;
		/* Get buswidth information */
		busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;

	} else {
		/*
		 * Old devices have chip data hardcoded in the device id table
		 */
		/*printk("find nand chip device id, and give device type\n");*/
		mtd->erasesize = type->erasesize;
		mtd->writesize = type->pagesize;
		mtd->oobsize = mtd->writesize / 32;
		busw = type->options & NAND_BUSWIDTH_16;
	}
#endif /* end of (#if 0) masked my Dannier*/

	/* Try to identify manufacturer */
	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
		if (nand_manuf_ids[maf_idx].id == *maf_id)
			break;
	}

	/*
	 * Check, if buswidth is correct. Hardware drivers should set
	 * chip correct !
	 */
	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
		printk(KERN_INFO "NAND device: Manufacturer ID:"
				" 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
				/*dev_id, nand_manuf_ids[maf_idx].name, mtd->name);*/
				id, nand_manuf_ids[maf_idx].name, mtd->name);
		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
				(chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
				busw ? 16 : 8);
		return ERR_PTR(-EINVAL);
	}

	/* Calculate the address shift from the page size */
	chip->page_shift = ffs(mtd->writesize) - 1;
	/* Convert chipsize to number of pages per chip -1. */
	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;

	chip->bbt_erase_shift = chip->phys_erase_shift =
		ffs(mtd->erasesize) - 1;
	chip->chip_shift = ffs(chip->chipsize) - 1;

	/* Set the bad block position */
	chip->badblockpos = mtd->writesize > 512 ?
		NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;

	/* Get chip options, preserve non chip based options */
	chip->options &= ~NAND_CHIPOPTIONS_MSK;
	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;

	/*
	 * Set chip as a default. Board drivers can override it, if necessary
	 */
	chip->options |= NAND_NO_AUTOINCR;

	/* Check if chip is a not a samsung device. Do not clear the
	 * options for chips which are not having an extended id.
	 */
	/*if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)*//* Dannier:to support new table*/
	if (*maf_id != NAND_MFR_SAMSUNG && type->dwPageSize > 512)
		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;

	/* Check for AND chips with 4 page planes */
	/*if (chip->options & NAND_4PAGE_ARRAY)
		chip->erase_cmd = multi_erase_cmd;
	else
		chip->erase_cmd = single_erase_cmd;*/

	/* Do not replace user supplied command function ! */
	/*if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
		chip->cmdfunc = nand_command_lp;*/

	printk(KERN_INFO "NAND device: Manufacturer ID:"
			" 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, id,
			nand_manuf_ids[maf_idx].name, type->ProductName);

	*maf_id = tmp_id;
	if (tmp_id == 0x2C88044B || tmp_id == 0x2C68044A) {
		//nand_set_feature(mtd, NAND_SET_FEATURE, 01, 04);
	}

	return type;
}
static int wmt_calc_clock(struct mtd_info *mtd, unsigned int spec_clk, unsigned int spec_tadl, struct NFC_RW_T *nfc_rw)
{
	unsigned int i, div1=0, div2, clk1, clk2=0, comp, T_setup, T1=0, T2=0, clk, PLLB;
	unsigned int tREA, tREH, Thold, Thold2, Ttmp, tADL, tWP, divisor, tWH;
	
	/*print_nand_register(mtd);*/
	PLLB = *(volatile unsigned int *)PMPMB_ADDR;
	PLLB = (2*(((PLLB>>16)&0x7F)+1))/((((PLLB>>8)&0x1F)+1)*(1<<(PLLB&3)));
	printk(KERN_WARNING "PLLB=0x%x, spec_clk=0x%x\n", PLLB, spec_clk);
	tREA = (spec_clk>>24)&0xFF;
	tREH = (spec_clk>>16)&0xFF;
	tWP  = (spec_clk>>8)&0xFF;
	tWH = spec_clk&0xFF;
	tADL = spec_tadl;
	for (i = 1; i < 16; i++) {
		if (MAX_SPEED_MHZ >= (PLLB*SOURCE_CLOCK)/i) {
			div1 = i;
			break;
		}
	}

	clk1 = (1000 * div1)/(PLLB*SOURCE_CLOCK);
	//printk("clk1=%d, div1=%d, spec_clk=%d\n", clk1, div1, spec_clk);
	for (T1 = 1; T1 < 10; T1++) {
		if ((T1*clk1) >= (tREA + MAX_READ_DELAY))
			break;
	}
	i = 1;
	while (i*clk1 <= tREH) {
		i++;
	}
	Thold = i;
	printk("T1=%d, clk1=%d, div1=%d, Thold=%d, tREA=%d+delay(%d)\n", T1, clk1, div1, Thold, tREA, MAX_READ_DELAY);
	Ttmp = T_setup = T1;
	clk = clk1;
	divisor = div1;
	div2 = div1;
	while (Ttmp > 1 && clk != 0) {
		div2++;
		clk2 = (1000 * div2)/(PLLB*SOURCE_CLOCK);
		comp = 0;
		for (T2 = 1; T2 < Ttmp; T2++) {
			if ((T2*clk2) >= (tREA + MAX_READ_DELAY)) {
				Ttmp = T2;
				comp = 1;
				i = 1;
				while (i*clk2 <= tREH) {
					i++;
				}
				Thold2 = i;
				printk("T2=%d, clk2=%d, div2=%d, Thold2=%d, comp=1\n", T2, clk2, div2, Thold2);
				break;
			}
		}
		if (comp == 1) {
			clk1 = clk * (T_setup+Thold) * mtd->writesize;
			div1 = clk2 * (T2+Thold2) * mtd->writesize;
			printk("Tim1=%d , Tim2=%d\n", clk1, div1);
			if ((clk * (T_setup+Thold) * mtd->writesize) > (clk2 * (T2+Thold2) * mtd->writesize)) {
				T_setup = T2;
				clk = clk2;
				divisor = div2;
				Thold = Thold2;
			} else {
				printk("T2 is greater and not use\n");
			}
		}
	} /* end of while */
	nfc_rw->T_R_hold = Thold;
	nfc_rw->T_R_setup = T_setup;
	nfc_rw->divisor = divisor;

	i = 1;
	nfc_rw->T_W_setup = 0x1; /* set write setup/hold time */
	while (/*((i*2+2)*clk) <= (tADL-tWP) ||*/ (i*clk) <= (tWP+MAX_WRITE_DELAY)) {
		nfc_rw->T_W_setup += 1;
		i++;
	}
	nfc_rw->T_W_hold = 1;

	if ((nfc_rw->T_W_hold * 2) == 2)
		Thold = 4;
	else if ((nfc_rw->T_W_hold * 2) == 4)
		Thold = 6;
	i = 0;
	while (((i+Thold)*clk) < tADL && i < 15) {
		i++;
	}
	nfc_rw->T_TADL_delay = i;
	//printk("Tad i=%d\n", i);
	nfc_rw->T_RHC_THC =
	((nfc_rw->T_R_hold&0xFF) << 12) + 
	(((nfc_rw->T_R_setup&0xFF) + (nfc_rw->T_R_hold&0xFF)) << 8) +
	((nfc_rw->T_W_hold&0xF) << 4) + 
	((nfc_rw->T_W_setup + nfc_rw->T_W_hold)&0xF);

	if ((MAX_SPEED_MHZ < (PLLB*SOURCE_CLOCK)/(divisor)) || clk == 0 || T_setup == 0 || clk > 45)
		return 1;

	return 0;
}

static int wmt_nfc_init(struct wmt_nand_info *info, struct mtd_info *mtd)
{
	int busw, nand_maf_id, page_per_block, CE = 0, nand_maf_id1 = 0;
	unsigned int spec_clk, divisor, status = 0, spec_clk1, spec_tadl, spec_tadl1;
	struct nand_chip *chip = mtd->priv;
	struct WMT_nand_flash_dev *type;
	struct NFC_RW_T nfc_rw;


	/* Get buswidth to select the correct functions */
	busw = chip->options & NAND_BUSWIDTH_16;

	/*  struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);*/
	/* enable chip select */
	/* new structure  */

	/* old structure */
	/* writeb(PAGE_2K|WIDTH_8|WP_DISABLE|DIRECT_MAP|OLDDATA_EN,
	info->reg + WMT_NFC_NAND_TYPE_SEL);*/
	/* writeb((PAGE_2K|WIDTH_8|WP_DISABLE|DIRECT_MAP)&(~OLDDATA_EN),
	info->reg + WMT_NFC_NAND_TYPE_SEL);*/

	writeb((PAGE_2K|WIDTH_8|WP_DISABLE|DIRECT_MAP|CHECK_ALLFF)&(~OLDDATA_EN),
	info->reg + WMT_NFC_NAND_TYPE_SEL);
	
	writel(readl(info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL) & 0xffff0000,
	info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL);
	writel(readl(info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL) | NFC_RWTimming,
	info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL);
	
	writel(B2R,	info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writel(0x0,	info->reg + WMT_NFC_CALC_CTRL);
	
	/* DannierChen add to identify the page size and block size */
	type = get_flash_type(mtd, chip, busw, &nand_maf_id, CE, &spec_clk, &spec_tadl);
	if (IS_ERR(type)) {
		printk(KERN_WARNING "No NAND device found!!!\n");
		chip->select_chip(mtd, -1);
			if (nand_maf_id) {
				printk(KERN_WARNING "nand flash identify fail(unknow id), nand_maf_id=0x%x\n", nand_maf_id);
				/*return PTR_ERR(type);*/
			}
			return 2;
	}
	CE = 1;
	get_flash_type(mtd, chip, busw, &nand_maf_id1, CE, &spec_clk1, &spec_tadl1);
	if (nand_maf_id == nand_maf_id1)
		nand_partitions[11].size += chip->chipsize;
	//printk("mtdpartition11 size=0x%Lx\n", nand_partitions[11].size);

	page_per_block = chip->phys_erase_shift - chip->page_shift;
	/*printk(KERN_INFO "page per block = 2^%x \n", page_per_block);*/
	switch (page_per_block) {
	case 4:
		writel(0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL); /*32 page per block*/
	break;
	case 5:/*32 page per block*/
		writel((1 << 5) | 0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL);
	break;
	case 6:/*64 page per block*/
		writel((2 << 5) | 0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL);
	break;
	case 7:/*128 page per block*/
		writel((3 << 5) | 0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL);
	break;
	case 8:/*256 page per block*/
		writel((4 << 5) | 0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL);
	break;
	case 9:/*512 page per block*/
		writel((5 << 5) | 0x1F, info->reg + WMT_NFC_PAGESIZE_DIVIDER_SEL);
	break;
	default:
		printk(KERN_ERR "page per block not support\n");
	break;
	}

	#ifdef NAND_DEBUG
	printk(KERN_ERR "mtd->writesize = %x \n", mtd->writesize);
	#endif
	if (mtd->writesize == 2048) {
		writeb((PAGE_2K|WIDTH_8|WP_DISABLE|DIRECT_MAP|CHECK_ALLFF)&(~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (mtd->writesize == 4096) {
		writeb((PAGE_4K|WIDTH_8|WP_DISABLE|DIRECT_MAP|CHECK_ALLFF)&(~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (mtd->writesize == 8192) {
		writeb((PAGE_8K|WIDTH_8|WP_DISABLE|DIRECT_MAP|CHECK_ALLFF)&(~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (mtd->writesize == 16384) {
		writew((PAGE_16K|WIDTH_8|WP_DISABLE|DIRECT_MAP|CHECK_ALLFF)&(~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else {
		writeb((PAGE_512|WIDTH_8|WP_DISABLE|DIRECT_MAP)&(~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL); /*new structure*/
	}
	chip->select_chip(mtd, -1);
	status = wmt_calc_clock(mtd, spec_clk, spec_tadl, &nfc_rw);
	if (status) {
		printk("timming setting fail");
		return 1;
	}
	NFC_RWTimming = nfc_rw.T_RHC_THC;
	divisor = nfc_rw.divisor;
	//NFC_RWTimming = ((Thold&0xFF) << 12) + ((T + (Thold&0xFF)) << 8) +
	/* nand write timing 1T2T has bug, will cause write fail only can set 2T4T */
	//(2 << 4) + 4;/*(((Thold>>8)&0xFF) << 4) + 2*((Thold>>8)&0xFF);*/

	switch(nand_maf_id)
	{
		case 0x2C88044B:
		case 0x2C68044A:
			NFC_RWTimming = 0x2424;
			divisor = 9;
		break;
	}
	*(volatile unsigned long *)PMNAND_ADDR = (divisor&NFC_ClockMask);
	while ((*(volatile unsigned long *)(PMCS_ADDR+0x18))&0x7F0038)
	;
	divisor = *(volatile unsigned long *)PMNAND_ADDR;
	printk(KERN_WARNING "nand tadl=%dT, divisor set 0x%x, NFC_timing=0x%x\n",
	nfc_rw.T_TADL_delay, divisor, NFC_RWTimming);
	writeb((readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF) |	nfc_rw.T_TADL_delay<<4,
	info->reg + WMT_NFC_CALC_CTRL);
	writel((readl(info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL) & 0xffff0000) | NFC_RWTimming,
	info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL);

	return 0;
}

#if 0
static void disable_redunt_out_bch_ctrl(struct wmt_nand_info *info, int flag)
{
	if (flag == 1)
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL)|0x02, info->reg + WMT_NFC_CALC_CTRL);
	else
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL)&0xfd, info->reg + WMT_NFC_CALC_CTRL);
}
static void redunt_read_hm_ecc_ctrl(struct wmt_nand_info *info, int flag)
{
	if (flag == 1)
		writeb(readb(info->reg + WMT_NFC_SMC_ENABLE) | 0x02, info->reg + WMT_NFC_SMC_ENABLE);
	else
		writeb(readb(info->reg + WMT_NFC_SMC_ENABLE) & 0xfd, info->reg + WMT_NFC_SMC_ENABLE);
}
#endif

static void set_ecc_engine(struct wmt_nand_info *info, int type)
{
	/*struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);*/
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & 0xfffffff8, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | type, info->reg + WMT_NFC_ECC_BCH_CTRL);

	/* enable BCH ecc interrupt and new structure */
	if (type == ECC16bit || type == ECC24bitPer1K || type == ECC40bitPer1K) { /*to support read page twice*/
	/*if (type == ECC16bit) {*/
		/*printk(KERN_ERR "set_ecc_engine for bch 16 bit\n");*/
		writew(eccBCH_inetrrupt_enable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		writel(readl(info->reg + WMT_NFC_NAND_TYPE_SEL) & (~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (type == ECC12bit) {
		/*printk(KERN_ERR "set_ecc_engine for bch 12 bit\n");*/
		writew(eccBCH_inetrrupt_enable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		writel(readl(info->reg + WMT_NFC_NAND_TYPE_SEL) & (~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (type == ECC8bit) {
		/*printk(KERN_ERR "set_ecc_engine for bch 8 bit\n");*/
		writew(eccBCH_inetrrupt_enable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		writel(readl(info->reg + WMT_NFC_NAND_TYPE_SEL) & (~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	} else if (type == ECC4bit) {
		/*printk(KERN_ERR "set_ecc_engine for bch 4 bit\n");*/
		writew(eccBCH_inetrrupt_enable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		writel(readl(info->reg + WMT_NFC_NAND_TYPE_SEL) & (~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	}	else { /*disable 4bit ecc interrupt and old structure*/
		writew(eccBCH_inetrrupt_disable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		#ifdef NAND_DEBUG
		printk(KERN_ERR "set_ecc_engine for harmming\n");
		#endif
		writel(readl(info->reg + WMT_NFC_NAND_TYPE_SEL) & (~OLDDATA_EN),
		info->reg + WMT_NFC_NAND_TYPE_SEL);
	}
}


static int wmt_nand_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	//unsigned int b2r_stat;
	int i = 0;

	while (1)	{
		if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R)
			break;
		if ((++i>>20)) {
			printk(KERN_ERR "nand flash is not ready\n");
			/*print_nand_register(mtd);*/
			/*    while (1);*/
			return -1;
		}
	}
	//b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R, info->reg + WMT_NFC_HOST_STAT_CHANGE);
	if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R)	{
		printk(KERN_ERR "NFC err : B2R status not clean\n");
		return -2;
	}
	return 0;
}


static int wmt_nfc_transfer_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1)	{
		if (!(readb(info->reg + WMT_NFC_MISC_STAT_PORT) & NFC_BUSY))
			break;

		if (++i>>20)
			return -3;
	}
	return 0;
}
/* Vincent  2008.11.3*/
static int wmt_wait_chip_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1) {
		if ((readb(info->reg + WMT_NFC_MISC_STAT_PORT) & FLASH_RDY))
			break;
		if (++i>>20)
			return -3;
	}
	return 0;
}
static int wmt_wait_cmd_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1)	{
		if (!(readb(info->reg + WMT_NFC_MISC_STAT_PORT) & NFC_CMD_RDY))
			break;
		if (++i>>20)
			return -3;
	}
	return 0;
}

/* #if (NAND_PAGE_SIZE == 512) Vincent 2008.11.4
static int wmt_wait_dma_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1) {
		if (!(readb(info->reg + NFC_IDLE) & 0x02))
			break;
		if (++i>>20) {
			printk(KERN_ERR"\r DMA NOT Ready!\n");
			print_nand_register(mtd);
			return -3;
		}
	}
	return 0;
}
#endif  Vincent 2008.11.4*/

static void wmt_wait_nfc_ready(struct wmt_nand_info *info)
{
	unsigned int bank_stat1, i = 0;
	while (1) {
		bank_stat1 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);/* Vincent 2008.11.14 */
		if (!(readb(info->reg + WMT_NFC_MISC_STAT_PORT) & NFC_BUSY))
			break;
		else if ((bank_stat1 & 0x101) == (ERR_CORRECT | BCH_ERR))
			break;

		if (i>>20)
			return;
		i++;
	}
}

static void bit_correct(uint8_t *c, uint8_t pos)
{
	c[0] = (((c[0] ^ (0x01<<pos)) & (0x01<<pos)) | (c[0] & (~(0x01<<pos))));
	#if 0
	temp = info->dmabuf[bch_err_idx[0] >> 3];
	temp >>= ((bch_err_idx[0] & 0x07) - 1);
	#endif
}

/*
 * flag = 0, need check BCH ECC
 * flag = 1, don't check ECC
 * flag = 2, need check Harming ECC
 *
*/

static int NFC_WAIT_IDLE(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1) {
		if (readb(info->reg + WMT_NFC_IDLE_STAT) & NFC_IDLE)
			break;
		if (i>>20) {
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
			printk(KERN_NOTICE "in nfc_wait_idle(): while 1 \n");
			print_nand_register(mtd);
			while(i);
			return -1;
		}
		i++;
	}
	return 0;
	
}

static int wmt_nfc_wait_idle(struct mtd_info *mtd, unsigned int flag, int command,
int column, unsigned int page_addr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int i = 0;

	while (1) {
		if (readb(info->reg + WMT_NFC_IDLE_STAT) & NFC_IDLE)
			break;
		if (i>>20) {
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
			printk(KERN_NOTICE "in nfc_wait_idle(): while 1 \n");
			print_nand_register(mtd);
			//while(i);
			return -1;
		}
		i++;
	}
	/* continue read next bank and calc BCH ECC */
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);

	return 0;
}

void bch_data_ecc_correct(struct mtd_info *mtd)
{
	int i;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_chip *this = mtd->priv;
	unsigned int bank_stat1, bank_stat2, bch_ecc_idx, bank, ecc_engine;
	unsigned int bank_size;
	struct ECC_size_info ECC_size;

	bank_stat1 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	if ((bank_stat1 & 0x101) == (ERR_CORRECT | BCH_ERR)) {
		/* BCH ECC err process */
		bank_stat2 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT2);
		bch_ecc_idx = bank_stat2 & BCH_ERR_CNT;
		bank = (bank_stat2 & 0xF00) >> 8;
		/* for data area */
		#ifdef NAND_DEBUG
		printk(KERN_NOTICE "in nfc_wait_idle(): Read data \n");
		#endif
		ecc_engine = info->ECC_mode;
		ECC_size.ecc_engine = ecc_engine;
		calculate_ECC_info(mtd, &ECC_size);
		/*if (this->cur_chip && (info->cur_page%4) == 0)
		if ((info->cur_page < 0x7FB00) && this->cur_chip->cur_try_times < 5 && this->cur_chip != 0 && info->isr_cmd == 0x0) {
			printk("----------------------------------set unc error by dannier info->cur_page0x%x\n", info->cur_page);
			bch_ecc_idx = BCH_ERR_CNT;
		}*/
		if (bch_ecc_idx >= BCH_ERR_CNT) {
			if (info->isr_cmd == 0x50) {
				info->oob_ecc_error = 0x50;
				//printk("re ob u cur_page=%d\n",info->cur_page);
				writew(readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1)|(ERR_CORRECT|BCH_ERR),
				info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
				writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
				info->reg + WMT_NFC_ECC_BCH_CTRL);
				return;
			}

			writew(readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1)|(ERR_CORRECT | BCH_ERR),
			info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
			
			if (info->isr_cmd == 0x0 && mtd->dwRetry && this->cur_chip) {
				info->data_ecc_uncor_err = 1;
				if (info->cur_page >= ((mtd->blkcnt-8)*mtd->pagecnt) &&
				info->cur_page < ((mtd->blkcnt-4)*mtd->pagecnt)) {
					/* read retry table not allowed to use read retry */
					info->data_ecc_uncor_err = 2;
					printk(KERN_ERR "data area bank %d uncor err page=0x%x no retry\n", bank, info->cur_page);
				} /*else
					printk(KERN_ERR "data area bank %d uncor err page=0x%x use retry\n", bank, info->cur_page);*/
				return;
			} else
				printk(KERN_ERR "data area uncor err page=0x%x no retry\n", info->cur_page);
			mtd->ecc_stats.failed++;
			return; /* uncorrected err */
		}
		bank_size = ECC_size.bank_size;
		/* mtd->ecc_stats.corrected += (bank_stat2 & BCH_ERR_CNT);*/
		/* BCH ECC correct */
		#ifdef NAND_DEBUG
		printk(KERN_NOTICE "data area %d bit corrected err on bank %d \n", bch_ecc_idx, bank);
		#endif
		for (i = 0; i < bch_ecc_idx; i++) {
			bch_err_pos[i] = (readw(info->reg +	WMT_NFC_ECC_BCH_ERR_POS1 + 2*i) & BCH_ERRPOS0);
			//printk(KERN_NOTICE "data area byte=%d corrected err on bank %d bs=%d, banks=%d\n", bch_err_pos[i]>>3, bank, bank_size,ECC_size.banks);
			if (bank >= (ECC_size.banks-1)) {
				if((bch_err_pos[i] >> 3) < bank_size) {
					//printk(KERN_NOTICE "b7 area value=%d ", info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)]);
					bit_correct(&info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)], bch_err_pos[i] & 0x07);
					//printk(KERN_NOTICE "b7 area value=%d \n", info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)]);
				} else if ((bch_err_pos[i] >> 3) < (bank_size + 24)) {//oob area of last bank
					//printk(KERN_NOTICE "redundant area value=%d ", *((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size));
					bit_correct((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size, (bch_err_pos[i] & 0x07));
					//printk(KERN_NOTICE "redundant area value=%d \n", *((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size));
				}
			} else {
				if((bch_err_pos[i] >> 3) < bank_size) {
					//printk(KERN_NOTICE "area value=%d ", info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)]);
					if (info->oob_ecc_error == 0x50 && bank == 0)
						bit_correct(&info->dmabuf[bank_size * (ECC_size.banks-1) + (bch_err_pos[i] >> 3)], bch_err_pos[i] & 0x07);
					else
						bit_correct(&info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)], bch_err_pos[i] & 0x07);
					//printk(KERN_NOTICE "area value=%d \n", info->dmabuf[bank_size* bank + (bch_err_pos[i] >> 3)]);
				}
			}

			#ifdef NAND_DEBUG
			printk(KERN_NOTICE "in nfc_wait_idle(): data area %xth ecc error position is byte%d bit%d\n",
			i, bank_size * bank + (bch_err_pos[i] >> 3), (bch_err_pos[i] & 0x07));
			#endif
		}
	} /* end of if ((bank_stat1 & 0x101) */
	/* continue read next bank and calc BCH ECC */
	writew(readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1)|(ERR_CORRECT | BCH_ERR),
	info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);
}

void bch_redunt_ecc_correct(struct mtd_info *mtd)
{
	int i;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_chip *this = mtd->priv;
	unsigned int bank_stat1, bank_stat2, bch_ecc_idx, bank, ecc_engine;
	unsigned int bank_size;
	struct ECC_size_info ECC_size;

	
	/* BCH ECC err process */
	bank_stat2 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT2);
	bch_ecc_idx = bank_stat2 & BCH_ERR_CNT;

	/* bank = (bank_stat2 & 0x700) >> 8; */
	bank_stat1 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	bch_ecc_idx = bank_stat2 & BCH_ERR_CNT;
	bank = (bank_stat2 & 0xF00) >> 8;
	if ((bank_stat1 & 0x101) == (ERR_CORRECT | BCH_ERR)) {
		/* mtd->ecc_stats.corrected += (bank_stat2 & BCH_ERR_CNT);*/
		/* BCH ECC correct */
		/* for reduntant area */
		ecc_engine = info->ECC_mode;
		ECC_size.ecc_engine = ecc_engine;
		calculate_ECC_info(mtd, &ECC_size);
		bank_size = ECC_size.bank_size;
		if (bch_ecc_idx >= BCH_ERR_CNT) {
			writew(readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1)|(ERR_CORRECT | BCH_ERR),
			info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
			if (info->isr_cmd == 0x50) {
				info->oob_ecc_error = 0x50;
				printk("red re oob uncor err cur_page=%d\n",info->cur_page);
				return;
			}
			if (info->isr_cmd == 0x0 && mtd->dwRetry && this->cur_chip) {
				info->data_ecc_uncor_err = 1;
				printk(KERN_ERR
				"last bank data area uncorrected err cur_page=%d use retry\n",info->cur_page);
				return;
			} else
				printk(KERN_ERR
				"last bank data area uncorrected err cur_page=%d no retry\n",info->cur_page);
			mtd->ecc_stats.failed++;
			//while(bank_stat1);
			return;
			/* return -4;*/  /* uncorrected err */
		}
		/* mtd->ecc_stats.corrected += (bank_stat2 & BCH_ERR_CNT);*/
		/* BCH ECC correct */
		#ifdef NAND_DEBUG
		printk(KERN_NOTICE "reduntant %d bit corrected error\n", bch_ecc_idx);
		#endif
		for (i = 0; i < bch_ecc_idx; i++) {
			bch_err_pos[i] = (readw(info->reg +	WMT_NFC_ECC_BCH_ERR_POS1 + 2*i) & BCH_ERRPOS0);
			//printk(KERN_NOTICE "data area byte=%d corrected err on bank %d bs=%d, banks=%d\n", bch_err_pos[i]>>3, bank, bank_size,ECC_size.banks);
			if((bch_err_pos[i] >> 3) < bank_size) {
				if (info->oob_ecc_error == 0x50 && bank == 0)
					bit_correct(&info->dmabuf[bank_size * (ECC_size.banks-1) + (bch_err_pos[i] >> 3)], bch_err_pos[i] & 0x07);
				else
					printk("read last bank error \n");
			} else if ((bch_err_pos[i] >> 3) < (bank_size + 24)) {//oob area of last bank
				//printk(KERN_NOTICE "redundant area value=%d ", *((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size));
				bit_correct((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size, (bch_err_pos[i] & 0x07));
				//printk(KERN_NOTICE "redundant area value=%d \n", *((uint8_t *)(info->reg+ECC_FIFO_0)+(bch_err_pos[i] >> 3) - bank_size));
			}

			#ifdef NAND_DEBUG
			printk(KERN_NOTICE "in nfc_wait_idle(): data area %xth ecc error position is byte%d bit%d\n",
			i, bank_size * bank + (bch_err_pos[i] >> 3), (bch_err_pos[i] & 0x07));
			#endif
		}
	}
	/* continue read next bank and calc BCH ECC */
	writew(readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1)|(ERR_CORRECT | BCH_ERR),
	info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);
}

/*
*   [Routine Description]
*	read status
*   [Arguments]
*	cmd : nand read status command
*   [Return]
*	the result of command
*/
static int wmt_read_nand_status(struct mtd_info *mtd, unsigned char cmd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int cfg = 0, status = -1;
	unsigned int b2r_stat;

	writeb(cmd, info->reg + WMT_NFC_COMPORT0);
	cfg = DPAHSE_DISABLE|NFC2NAND|(1<<1);

	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

	writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
	status = wmt_wait_cmd_ready(mtd);
	if (status) {
		printk(KERN_ERR "NFC command transfer1 is not ready\n");
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		return status;
	}
	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

	cfg = SING_RW|NAND2NFC;
	writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

	status = wmt_wait_cmd_ready(mtd);
	if (status) {
		printk(KERN_ERR "NFC command transfer2 is not ready\n");
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		return status;
	}
	status = wmt_nfc_transfer_ready(mtd);
	/* status = wmt_nand_wait_idle(mtd);*/
	if (status) {
		printk(KERN_ERR "NFC IO transfer is not ready\n");
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		/*print_nand_register(mtd);*/
		return status;
	}
		 /* return read status  */
	/*   return readb(info->reg + WMT_NFC_DATAPORT) & 0xff;*/
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "read status is %x\n", readb(info->reg + WMT_NFC_DATAPORT) & 0xff);
	#endif
	info->datalen = 0;
	info->dmabuf[0] = readb(info->reg + WMT_NFC_DATAPORT) & 0xff;
	status = info->dmabuf[0];
	return status;
}


/* data_flag = 0:  set data ecc fifo */
static int wmt_nfc_dma_cfg(struct mtd_info *mtd, unsigned int len, unsigned int wr,
int data_flag, int Nbank)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int status;
	unsigned long *ReadDesc, *WriteDesc;
	ReadDesc = (unsigned long *)(info->dmabuf + mtd->writesize + mtd->oobsize
	+ (16-(mtd->oobsize)%16) + 0x100);
	WriteDesc = (unsigned long *)(info->dmabuf + mtd->writesize + mtd->oobsize
	+ (16-(mtd->oobsize)%16) + 0x200);
	/*
	printk(KERN_ERR "info->dmabuf = 0x%x\r\n", (unsigned int) info->dmabuf);
	printk(KERN_ERR "info->dmaaddr = 0x%x\r\n", (unsigned int) info->dmaaddr);
	printk(KERN_ERR "ReadDesc addr = 0x%x\r\n", (unsigned int) ReadDesc);
	printk(KERN_ERR "WriteDesc addr = 0x%x\r\n", (unsigned int) WriteDesc);
	*/

	if (len == 0)	{
		printk(KERN_ERR "DMA transfer length = 0\r\n");
		return 1;
	}
	if (data_flag == 0) {
		/* data:  set data ecc fifo */
		if (mtd->writesize == 512) {
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_0));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_1));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_2));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_3));
		} else { /* pagesize = 2048 or 4096 */
			if (mtd->writesize == 2048)
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7, info->reg + WMT_NFC_CALC_CTRL);
			else { /*if (NAND_PAGE_SIZE == 4096)*/
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7, info->reg + WMT_NFC_CALC_CTRL);

				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_0));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_1));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_2));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_3));
		
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_4));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_5));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_6));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_7));
		
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_8));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_9));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_a));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_b));
		
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_c));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_d));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_e));
				writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_f));
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | 0x08, info->reg + WMT_NFC_CALC_CTRL);
			}
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_0));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_1));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_2));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_3));
	
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_4));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_5));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_6));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_7));
	
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_8));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_9));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_a));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_b));
	
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_c));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_d));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_e));
			writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_f));
			writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7, info->reg + WMT_NFC_CALC_CTRL);
		}
	} else if (data_flag == 1) {
		/* reduntant area:  set reduntant data ecc fifo  BCH ECC */
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7, info->reg + WMT_NFC_CALC_CTRL);
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_0));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_1));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_2));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_3));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_4));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_5));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_6));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_7));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_8));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_9));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_a));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_b));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_c));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_d));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_e));
		writel(0xffffffff, (unsigned int *)(info->reg + ECC_FIFO_f));
	} else if (data_flag == 2) {
		/* reduntant area:  set reduntant data ecc fifo  Harming ECC */
		writel(readl(info->reg + ECC_FIFO_c) | 0xffff0000, info->reg + ECC_FIFO_c);
	}
	writew(len - 1, info->reg + WMT_NFC_DMA_COUNTER);
	if (readl(info->reg + NFC_DMA_ISR) & NAND_PDMA_IER_INT_STS)
		writel(NAND_PDMA_IER_INT_STS, info->reg + NFC_DMA_ISR);

	if (readl(info->reg + NFC_DMA_ISR) & NAND_PDMA_IER_INT_STS) {
		printk(KERN_ERR "PDMA interrupt status can't be clear ");
		printk(KERN_ERR "NFC_DMA_ISR = 0x%8.8x \n", (unsigned int)readl(info->reg + NFC_DMA_ISR));
	}

	status = nand_init_pdma(mtd);
	if (status)
		printk(KERN_ERR "nand_init_pdma fail status = 0x%x", status);
	nand_alloc_desc_pool((wr) ? WriteDesc : ReadDesc);
	/*nand_init_short_desc((wr)?WriteDesc : ReadDesc, len, (unsigned long *)buf);*/
	if (info->oob_ecc_error == 0x50 && len != 1) {
		nand_init_long_desc((wr) ? WriteDesc : ReadDesc, len, (unsigned long *)info->last_bank_dmaaddr, 0, 1);
		if (len != 1024 && len != 512)
			printk("oob_ecc_error len!=1024, len=%d \n", len);
	} else
		nand_init_long_desc((wr) ? WriteDesc : ReadDesc, len, (unsigned long *)info->dmaaddr , 0, 1);
	/*printk(KERN_ERR "dma wr=%d, len=0x%x\n", wr, len);*/

	nand_config_pdma(mtd,
	(wr) ? (unsigned long *)(info->dmaaddr + mtd->writesize + mtd->oobsize + (16-(mtd->oobsize)%16) + 0x200)
	: (unsigned long *)(info->dmaaddr + mtd->writesize + mtd->oobsize + (16-(mtd->oobsize)%16) + 0x100), wr);

	return 0;
}

int nand_init_pdma(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);

	writel(NAND_PDMA_GCR_SOFTRESET, info->reg + NFC_DMA_GCR);
	writel(NAND_PDMA_GCR_DMA_EN, info->reg + NFC_DMA_GCR);
	if (readl(info->reg + NFC_DMA_GCR) & NAND_PDMA_GCR_DMA_EN)
		return 0;
	else
		return 1;
}


int nand_free_pdma(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	writel(0, info->reg + NFC_DMA_DESPR);
	writel(0, info->reg + NFC_DMA_GCR);
	return 0;
}


int nand_alloc_desc_pool(unsigned long *DescAddr)
{
	memset(DescAddr, 0x00, 0x100);
	return 0;
}

int nand_init_short_desc(unsigned long *DescAddr, unsigned int ReqCount, unsigned long *BufferAddr)
{
	struct _NAND_PDMA_DESC_S *CurDes_S;
	CurDes_S = (struct _NAND_PDMA_DESC_S *) DescAddr;
	CurDes_S->ReqCount = ReqCount;
	CurDes_S->i = 1;
	CurDes_S->end = 1;
	CurDes_S->format = 0;
	CurDes_S->DataBufferAddr = (unsigned long)BufferAddr;
	return 0;
}

int nand_init_long_desc(unsigned long *DescAddr, unsigned int ReqCount, unsigned long *BufferAddr,
unsigned long *BranchAddr, int End)
{
	struct _NAND_PDMA_DESC_L *CurDes_L;
	CurDes_L = (struct _NAND_PDMA_DESC_L *) DescAddr;
	CurDes_L->ReqCount = ReqCount;
	CurDes_L->i = 0;
	CurDes_L->format = 1;
	CurDes_L->DataBufferAddr = (unsigned long)BufferAddr;
	CurDes_L->BranchAddr = (unsigned long)BranchAddr;
	if (End) {
		CurDes_L->end = 1;
		CurDes_L->i = 1;
	}

	return 0;
}
/*
int nand_config_desc(unsigned long *DescAddr, unsigned long *BufferAddr, int Blk_Cnt)
{
	int i = 0 ;
	unsigned long *CurDes = DescAddr;

	nand_alloc_desc_pool(CurDes);


	for (i = 0 ; i < 3 ; i++) {
		nand_init_short_desc(CurDes, 0x80, BufferAddr);
		BufferAddr += (i * 0x80);
		CurDes += (i * sizeof(NAND_PDMA_DESC_S));
	}
	if (Blk_Cnt > 1) {
		nand_init_long_desc(CurDes, 0x80, BufferAddr, CurDes + sizeof(NAND_PDMA_DESC_L), 0);
		BufferAddr += (i * 0x80);
		CurDes += (i * sizeof(NAND_PDMA_DESC_L));

		nand_init_long_desc(CurDes, (Blk_Cnt - 1) * 512, BufferAddr,
		CurDes + sizeof(NAND_PDMA_DESC_L), 1);
	} else {
		nand_init_long_desc(CurDes, 0x80, BufferAddr, CurDes + sizeof(NAND_PDMA_DESC_L), 1);
	}

	return 0;
}
*/

int nand_config_pdma(struct mtd_info *mtd, unsigned long *DescAddr, unsigned int dir)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	if (info->isr_cmd != NAND_SET_FEATURE && info->isr_cmd != 0x37 && info->isr_cmd != 0x36)
		writel(NAND_PDMA_IER_INT_EN, info->reg + NFC_DMA_IER);
	writel((unsigned long)DescAddr, info->reg + NFC_DMA_DESPR);
	if (dir == NAND_PDMA_READ)
		writel(readl(info->reg + NFC_DMA_CCR)|NAND_PDMA_CCR_peripheral_to_IF,
		info->reg + NFC_DMA_CCR);
	else
		writel(readl(info->reg + NFC_DMA_CCR)&(~NAND_PDMA_CCR_IF_to_peripheral),
		info->reg + NFC_DMA_CCR);

	/*mask_interrupt(IRQ_NFC_DMA);*/
	writel(readl(info->reg + NFC_DMA_CCR)|NAND_PDMA_CCR_RUN, info->reg + NFC_DMA_CCR);
	/*printk(KERN_ERR "NFC_DMA_CCR = 0x%8.8x\r\n", readl(info->reg + NFC_DMA_CCR));*/
	/*print_nand_register(mtd);*/
	return 0;
}

int nand_pdma_handler(struct mtd_info *mtd)
{
	unsigned long status = 0;
	unsigned long count = 0;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);

	count = 0x100000;
#if 0
	/*	 polling CSR TC status	*/
	if (!(readl(info->reg + NFC_DMA_CCR)|NAND_PDMA_CCR_peripheral_to_IF)) {
	do {
		count--;
		if (readl(info->reg + NFC_DMA_ISR) & NAND_PDMA_IER_INT_STS) {
			status = readl(info->reg + NFC_DMA_CCR) & NAND_PDMA_CCR_EvtCode;
			writel(readl(info->reg + NFC_DMA_ISR)&NAND_PDMA_IER_INT_STS, info->reg + NFC_DMA_ISR);
			printk(KERN_ERR "NFC_DMA_ISR = 0x%8.8x\r\n",
			(unsigned int)readl(info->reg + NFC_DMA_ISR));
			break;
		}
		if (count == 0) {
			printk(KERN_ERR "PDMA Time Out!\n");
			printk(KERN_ERR "NFC_DMA_CCR = 0x%8.8x\r\n",
			(unsigned int)readl(info->reg + NFC_DMA_CCR));
			/*print_nand_register(mtd);*/
			count = 0x100000;
			/*break;*/
		}
	} while (1);
} else
#endif
	status = readl(info->reg + NFC_DMA_CCR) & NAND_PDMA_CCR_EvtCode;
	writel(readl(info->reg + NFC_DMA_ISR)&NAND_PDMA_IER_INT_STS, info->reg + NFC_DMA_ISR);
	if (status == NAND_PDMA_CCR_Evt_ff_underrun)
		printk(KERN_ERR "PDMA Buffer under run!\n");

	if (status == NAND_PDMA_CCR_Evt_ff_overrun)
		printk(KERN_ERR "PDMA Buffer over run!\n");

	if (status == NAND_PDMA_CCR_Evt_desp_read)
		printk(KERN_ERR "PDMA read Descriptor error!\n");

	if (status == NAND_PDMA_CCR_Evt_data_rw)
		printk(KERN_ERR "PDMA read/write memory descriptor error!\n");

	if (status == NAND_PDMA_CCR_Evt_early_end)
		printk(KERN_ERR "PDMA read early end!\n");

	if (count == 0) {
		printk(KERN_ERR "PDMA TimeOut!\n");
		while (1)
			;
	}
	return 0;
}

int nand_get_feature(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned int cfg = 0, i = 0;
	int status = -1;

	writeb(0xEE, info->reg + WMT_NFC_COMPORT0);
	writeb(0x01, info->reg + WMT_NFC_COMPORT1_2);
	cfg = DPAHSE_DISABLE|(0x02<<1);
	writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

	status = wmt_wait_cmd_ready(mtd);

	if (status) {
		printk(KERN_ERR "in nand_get_feature(): wait cmd is not ready\n");
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		return status;
	}
	cfg = NAND2NFC|SING_RW;
	for (i = 0; i < 4; i++) {
		writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		status = wmt_wait_cmd_ready(mtd);
		if (status)
				return status;
		status = wmt_nfc_transfer_ready(mtd);
		if (status) {
			printk(KERN_ERR "in nand_get_feature(): wait transfer cmd is not ready\n");
			return status;
		}
		info->dmabuf[i] = readb(info->reg + WMT_NFC_DATAPORT) & 0xff;

		#ifdef NAND_DEBUG
			printk(KERN_NOTICE "nand feature is %x\n", readb(info->reg + WMT_NFC_DATAPORT));
		#endif
	}
	info->datalen = 0;
	return 0;
}

int nand_set_feature(struct mtd_info *mtd, int cmd, int addrss, int value)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned int cfg = 0, len = 4;
	int status = -1;
	DECLARE_COMPLETION(complete);
	//unsigned char id[4] = {value, 0, 0, 0};
	info->dmabuf[0] = value;
	info->dmabuf[1] = 0;
	info->dmabuf[2] = 0;
	info->dmabuf[3] = 0;
	info->isr_cmd = cmd;
	info->done_data = &complete;
	//nfc->reg->NFCR23 |= USE_SW_ECC;
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	//printk("set feature cycle1\n");

	//nfc->reg->NFCR13 = 0x0F;
	writeb(0x0F, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	//nfc->reg->NFCRb |= B2R; /* write to clear */
	writel(B2R,	info->reg + WMT_NFC_HOST_STAT_CHANGE);
	if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R)
		printk("nand get feature B2R can't clear\n");
	//nfc->reg->NFCR13 = 0x07;
	writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);

	//printk("set feature cycle2\n");
	
	wmt_nfc_dma_cfg(mtd, len, 1, 0, -1);
	//print_nand_register(nfc);

	writeb(cmd, info->reg + WMT_NFC_COMPORT0);
	writeb(addrss, info->reg + WMT_NFC_COMPORT1_2);
	cfg = (0x02<<1);
	//print_nand_register(mtd);
	//printk("set feature cycle trigg = 0x%x\n", cfg|NFC_TRIGGER|OLD_CMD);
	writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
	//print_nand_register(mtd);
	//printk("set feature cycle3\n");
	wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
	status = NFC_WAIT_IDLE(mtd);
	if (status) {
		printk("get feature nand flash idle time out\n");
		return status;
	}

	writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	//printk("set feature cycle5\n");
	status = wmt_nfc_transfer_ready(mtd);
	/* status = wmt_nand_wait_idle(mtd);*/
	if (status) {
		printk(KERN_ERR "NFC IO transfer is not ready\n");
		/*print_nand_register(mtd);*/
		return status;
	}

	status = NFC_WAIT_IDLE(mtd);
	if (status) {
		printk("set feature nand flash idle time out\n");
		return status;
	}

	status = nand_pdma_handler(mtd);
	nand_free_pdma(mtd);
	if (status)
		printk(KERN_ERR "check write pdma handler status= %x \n", status);
	//nfc->reg->NFCR23 &= ~USE_SW_ECC;
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & ~DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	return status;
}

int get_parameter(struct mtd_info *mtd, uint8_t *buf, uint8_t *addr, int size)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned int cfg = 0, len = 1;
	int i, status = -1, regc = size;
	unsigned char *FIFO = (unsigned char *) (info->reg+ECC_FIFO_c);
	
	//nfc->reg->NFCR23 |= USE_SW_ECC;
	//writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	//nfc->reg->NFCR13 = 0x07;
	//writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	
	for (i = 0; i < regc;i++) {
		//DECLARE_COMPLETION(complete);
		info->isr_cmd = 0x37;
		//info->done_data = &complete;
		//printk("hynix retry get c1\n");
		//nfc->reg->NFCR13 = 0x0F;
		writeb(0x0F, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		//nfc->reg->NFCRb |= B2R; /* write to clear */
		writel(B2R,	info->reg + WMT_NFC_HOST_STAT_CHANGE);
		if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R)
			printk("B2R can't clear\n");
	
		//printk("hynix retry get c2\n");
		wmt_nfc_dma_cfg(mtd, len, 0, 0, -1);
		//print_nand_register(nfc);
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | HIGH64FIFO,	info->reg + WMT_NFC_CALC_CTRL);
		if (i == 0) {
			FIFO[0] = 0x37;
			FIFO[1] = addr[0];
			//nfc->reg->NFCRc = 0x00020001;
			writel(0x00020001,	info->reg + WMT_NFC_SMC_DMA_COUNTER);
			cfg = (0x02<<1);
		} else {
			FIFO[0] = addr[i];
			// set address latch ALE(high) and CLE(lower)	
			//nfc->reg->NFCRc = 0x00010000;
			writel(0x00010000,	info->reg + WMT_NFC_SMC_DMA_COUNTER);
			cfg = (0x01<<1);
		}
		//print_nand_register(mtd);
		//printk("hynix get retry param trigg = 0x%x\n", NAND2NFC|cfg|NFC_TRIGGER);
		//nfc->reg->NFCR1 = NAND2NFC|cfg|NFC_TRIGGER;	 /* cfg & start*/
		writew(NAND2NFC|cfg|NFC_TRIGGER, info->reg + WMT_NFC_COMCTRL);
		//print_nand_register(mtd);
		//wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
		//j = 0;
		while (!readl(info->reg + NFC_DMA_ISR)&NAND_PDMA_IER_INT_STS);
		status = NFC_WAIT_IDLE(mtd);
		if (status) {
			printk("get feature nand flash idle time out\n");
			return status;
		}
		writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		//printk("set feature cycle5\n");
		status = wmt_nfc_transfer_ready(mtd);
		/* status = wmt_nand_wait_idle(mtd);*/
		if (status) {
			printk(KERN_ERR "NFC IO transfer is not ready\n");
			/*print_nand_register(mtd);*/
			return status;
		}

		status = NFC_WAIT_IDLE(mtd);
		if (status) {
			printk("set feature nand flash idle time out\n");
			return status;
		}

		status = nand_pdma_handler(mtd);
		nand_free_pdma(mtd);
		if (status)
			printk(KERN_ERR "check write pdma handler status= %x \n", status);
		//printk("para info->dmabuf[0]= 0x%x\n", info->dmabuf[0]);
		buf[i] = info->dmabuf[0];
	}
	//nfc->reg->NFCR23 &= ~USE_SW_ECC;
	//writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & ~DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & ~HIGH64FIFO,	info->reg + WMT_NFC_CALC_CTRL);
	return status;
}

int hynix_get_parameter(struct mtd_info *mtd, int mode)
{
	struct nand_chip *this = mtd->priv;
	struct nand_read_retry_param *cur_chip = this->cur_chip;
	unsigned char buf[16] = {0};
	unsigned char *offset = NULL;
	unsigned char *set_value = NULL;
	unsigned char *def_value = NULL;
	unsigned int reg_num;
	int i = 0, j = 0;
	int rc = -1;

	if (mode == ESLC_MODE) {
		reg_num = cur_chip->eslc_reg_num;
		offset = cur_chip->eslc_offset;
		def_value = cur_chip->eslc_def_value;
		set_value = cur_chip->eslc_set_value;
	} else if (mode == READ_RETRY_MODE) {
		reg_num = cur_chip->retry_reg_num;
		offset = cur_chip->retry_offset;
		def_value = cur_chip->retry_def_value;
	} else {
		printk("Not support this mode %d\n", mode);
		return rc;
	}

	rc = get_parameter(mtd, buf, offset, reg_num);
	if (rc != 0)
		return rc;

	if (mode == ESLC_MODE) {
		if((def_value[reg_num] != 0xff) && (def_value[reg_num + 1] != 0xff)) {
			for(i = 0; i < reg_num; i++) {
				def_value[i] = buf[i];
				set_value[i] += buf[i];
			}
			def_value[reg_num] = 0xff;
			def_value[reg_num + 1] = 0xff;
			//printk("ESLC: ");
			print_nand_buffer(buf, reg_num);
		} else {
			//printk("ESLC Current: ");
			//print_nand_buffer(buf, reg_num);
		}
	} else if (mode == READ_RETRY_MODE) {
		if ((def_value[reg_num] != 0xff) && (def_value[reg_num + 1] != 0xff)) {
			for (i = 0; i < reg_num; i++)
				def_value[i] = buf[i];
			def_value[reg_num] = 0xff;
			def_value[reg_num + 1] = 0xff;
			//printk("Retry : ");
			//print_nand_buffer(buf, reg_num);
		} else {
			//printk("Retry Current: ");
			//print_nand_buffer(buf, reg_num);
			//printk("\n");
			for (j = 0; j < cur_chip->total_try_times; j++) {
				for (i = 0; i < reg_num; i++) {
					if (buf[i] != cur_chip->retry_value[j*reg_num+i])
						break;
				}
				//printk("i = %d\n", i);
				if (i == reg_num) {
					cur_chip->cur_try_times = j;
					//printk("@@@@@@@@@@@@@@@@@@@@@@@Get current try times %d from uboot.\n", j);
					break;
				}
			}
		}
	}
	return rc;
}

int write_bytes_cmd(struct mtd_info *mtd, int cmd_cnt, int addr_cnt, int data_cnt, uint8_t *cmd, uint8_t *addr, uint8_t *data)
{
	int i, status = 0;
	unsigned int cmd_addr_cycle = 0, cfg = 0, cfg_bit8 = 0, len = 1, counter = 10000;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned char *FIFO = (unsigned char *) (info->reg+ECC_FIFO_c);


	writeb(0x0F, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);

	status = NFC_WAIT_IDLE(mtd);
	if (status) {
		printk("nand flash idle time out\n");
		return status;
	}

	if (data_cnt > 0) {
		info->isr_cmd = 0x36;
		memcpy(info->dmabuf, data, data_cnt);
		wmt_nfc_dma_cfg(mtd, len, 1, 0, -1);
	}
	writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | HIGH64FIFO,	info->reg + WMT_NFC_CALC_CTRL);
	for (i = 0; i < cmd_cnt; i++) {
		FIFO[i] = cmd[i];
		cmd_addr_cycle |= (1<<i);
	}
	for (i = cmd_cnt; i < (addr_cnt+cmd_cnt); i++) {
		FIFO[i] = addr[i-cmd_cnt];
		cmd_addr_cycle |= (1<<(i+16));
	}
	writel(cmd_addr_cycle,	info->reg + WMT_NFC_SMC_DMA_COUNTER);
	/*printk("FIFO = ");
	for (i = 0; i < (addr_cnt+cmd_cnt); i++)
		printk("0x%x ", FIFO[i]);
	if (data_cnt > 0) 
		printk("data = 0x%x\n", data[0]);*/
	//printk(" NFCRc=0x%x\n", cmd_addr_cycle);
	cfg = ((cmd_cnt + addr_cnt)&0x7)<<1;
	cfg_bit8 = (((cmd_cnt + addr_cnt)&0x18)>>3)<<8;

	if (data_cnt == 0)
		cfg |= DPAHSE_DISABLE;

	writew(cfg_bit8|cfg|NFC_TRIGGER, info->reg + WMT_NFC_COMCTRL);

//print_nand_register(mtd);
	status = wmt_nfc_transfer_ready(mtd);
	if (status) {
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & ~HIGH64FIFO,	info->reg + WMT_NFC_CALC_CTRL);
		printk(KERN_ERR "NFC IO transfer is not ready\n");
			/*print_nand_register(mtd);*/
		goto go_fail;
	}
	status = NFC_WAIT_IDLE(mtd);
	if (status) {
		printk("retry c1 wait idle time out\n");
		goto go_fail;
	}
	if (cmd_cnt > 0 && cmd)
		if (cmd[0] == NAND_CMD_RESET) {
			status = wmt_nand_ready(mtd);
			if (status) {
				printk(KERN_ERR "Reset err, nand device is not ready\n");
				writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
				info->reg + WMT_NFC_ECC_BCH_CTRL);
			}
		}
	if (data_cnt > 0)
		while (!readl(info->reg + NFC_DMA_ISR)&NAND_PDMA_IER_INT_STS) {
			if (counter <= 0) {
				break;
			}
			counter--;
		}
	if (data_cnt > 0) {
		status = nand_pdma_handler(mtd);
		nand_free_pdma(mtd);
		if (status) {
			printk(KERN_ERR "check write pdma handler status= %x \n", status);
			goto go_fail;
		}
	}

go_fail:
	writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & ~HIGH64FIFO,	info->reg + WMT_NFC_CALC_CTRL);

	return status;
}

int set_parameter(struct mtd_info *mtd, unsigned char *buf, unsigned char *offset, int regn)
{
	int i, status = -1, regc = regn;
	unsigned char cmd[2] = {0x36, 0x16};

	status = write_bytes_cmd(mtd, 1, 1, 1, (uint8_t *)&cmd[0], offset, buf);
	if (status)
		printk("hynix_set read retry reg: phase 0 fail");
	for (i = 1; i < regc; i++) {
		status = write_bytes_cmd(mtd, 0, 1, 1, NULL, &offset[i], &buf[i]);
		if (status)
			printk("hynix_set read retry reg: phase %d fail", i);
	}
	status = write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&cmd[1], NULL, NULL);
	if (status)
		printk("load_hynix_opt_reg: phase 3 fail");
	
	return status;
}

void dummy_read(struct mtd_info *mtd)
{
	int status = -1;
	uint8_t cmd[2] = {0x00, 0x30}, addr[5] = {0, 0, 0, 0, 0};

	status = write_bytes_cmd(mtd, 1, 5, 0, &cmd[0], addr, NULL);
	if (status)
		printk("dummy read cmd(00) + addr fail\n");
	status = write_bytes_cmd(mtd, 1, 0, 0, &cmd[1], NULL, NULL);
	if (status)
		printk("dummy read cmd(0x30) fail\n");

	/* check busy to ready status*/
	status = wmt_nand_ready(mtd);
	if (status) {
		printk(KERN_ERR "NFC check B2R time out\n");
	}
}

int hynix_set_parameter(struct mtd_info *mtd, int mode, int def_value)
{
	struct nand_chip *this = mtd->priv;
	struct nand_read_retry_param *cur_chip = this->cur_chip;
	unsigned char *offset = NULL;
	unsigned char *set_value = NULL;
	unsigned int reg_num;
	int rc = -1;


	if (mode == ESLC_MODE) {
		reg_num = cur_chip->eslc_reg_num;
		offset = cur_chip->eslc_offset;
		if (def_value == ECC_ERROR_VALUE) {
			set_value = cur_chip->eslc_set_value;
		} else {
			set_value = cur_chip->eslc_def_value;
		}
	} else {
		reg_num = cur_chip->retry_reg_num;
		offset = cur_chip->retry_offset;
		if (def_value == ECC_ERROR_VALUE) {
			cur_chip->cur_try_times++;
			if (cur_chip->cur_try_times >= cur_chip->total_try_times)
				cur_chip->cur_try_times = -1;
			if ((cur_chip->cur_try_times >= 0) && (cur_chip->cur_try_times < cur_chip->total_try_times))
				set_value = cur_chip->retry_value + cur_chip->cur_try_times* cur_chip->retry_reg_num;
			else 
				set_value = cur_chip->retry_def_value;

		} else {
			set_value = cur_chip->retry_def_value;
			cur_chip->cur_try_times = -1;
		}
	}
#if 0
	printk("hynix set value: cur_try_times=%d\n", cur_chip->cur_try_times);
	for(rc = 0; rc < reg_num; rc++)
		printk(" 0x%x:0x%x ", offset[rc], set_value[rc]);
	printk("reg_num = %d\n", reg_num);
#endif
	rc = set_parameter(mtd, set_value, offset, reg_num);
	if(rc) {
		printk("set_parameter fail.\n");
		return rc;
	}

	if(def_value == DEFAULT_VALUE && mode == ESLC_MODE) {
		printk("dummy read:\n");
		dummy_read(mtd);
	}

	return rc;
}

int toshiba_pre_condition(struct mtd_info *mtd)
{
	int status = 0;
	unsigned char cmd1[2] = {0x5c, 0xc5};

	status = write_bytes_cmd(mtd, 2, 0, 0, cmd1, NULL, NULL);
	if(status)
		printk("toshiba pre condition cmd1 time out.\n");
	else
		printk("toshiba pre condition OK.\n");

	return status;
}

int toshiba_get_parameter(struct mtd_info *mtd, int mode)
{
	return 0;
}

int toshiba_set_parameter(struct mtd_info *mtd, int mode, int def_mode)
{
	int i, status = -1;
	struct nand_chip *this = mtd->priv;
	struct nand_read_retry_param *cur_chip = this->cur_chip;
	unsigned char cmd2[1] = {0x55};
	unsigned char cmd3[2] = {0x26, 0x5d};
	unsigned char *set_value = NULL;
	unsigned char *offset = NULL;

	if (cur_chip->cur_try_times >= cur_chip->total_try_times)
		cur_chip->cur_try_times = 0;
	set_value = cur_chip->retry_value + cur_chip->cur_try_times*cur_chip->retry_reg_num;
	offset = cur_chip->retry_offset;

	cur_chip->cur_try_times++;
	printk("toshiba set cur_try_times=%d\n", cur_chip->cur_try_times);	
	for (i = 0; i < 4; i++) {
		status = write_bytes_cmd(mtd, 1, 1, 1, cmd2, &offset[i], &set_value[i]);
		if (status)
			printk("toshiba set read retry reg: phase %d fail", i);
	}

  status = write_bytes_cmd(mtd, 2, 0, 0, cmd3, NULL, NULL);
  if (status) {
		printk("pre condition cmd2 time out\n");
	}

	return status;
}

static int wmt_nand_read_raw_page(struct mtd_info *mtd, struct nand_chip *chip, int page);
int hynix_get_otp(struct mtd_info *mtd, struct nand_chip *chip)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_read_retry_param *cur_chip = chip->cur_chip;
	int i, j, status = -1;
	//unsigned char data[2] = {0x00, 0x4D};
	unsigned char cmd[5] = {0x36, 0x16, 0x17, 0x04, 0x19};
	//unsigned char addr[2] = {0xAE , 0xB0};
	unsigned int page = 0x200;
	unsigned char *buff, reset = NAND_CMD_RESET, retry_end = NAND_CMD_HYNIX_RETRY_END;
	unsigned char *offset = cur_chip->otp_offset;
	unsigned char *data = cur_chip->otp_data;


	printk("get otp offset addr: 0x%x, 0x%x\n", offset[0], offset[1]);
	//chip->cmdfunc(mtd, NAND_CMD_RESET_NO_STATUS_READ, -1, -1);

	status = write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&reset, NULL, NULL);
	if (status) {
		printk("load_hynix_opt_reg: reset fail");
	}
	status = write_bytes_cmd(mtd, 1, 1, 1, (uint8_t *)&cmd[0], (uint8_t *)&offset[0], (uint8_t *)&data[0]);
	if (status)
		printk("load_hynix_opt_reg: phase 1 fail");
	status = write_bytes_cmd(mtd, 0, 1, 1, NULL, (uint8_t *)&offset[1], (uint8_t *)&data[1]);
	if (status)
		printk("load_hynix_opt_reg: phase 2 fail");
	status = write_bytes_cmd(mtd, 4, 0, 0, (uint8_t *)&cmd[1], NULL, NULL);
	if (status)
		printk("load_hynix_opt_reg: phase 3 fail");
	//nfc_ecc_set(USE_SW_ECC, nfc);
	//status = HY_nand_read(0, page, buf, 1026, ecc_code, nfc, 0);
	//nfc_ecc_set(USE_SW_ECC, nfc);
	wmt_nand_read_raw_page(mtd, chip, page);
	/*if (status != 0) {
		printk("load_hynix_opt_reg: phase 3 fail status = %d\n", status);
		//return -1;
	}*/
	status = write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&reset, NULL, NULL);
	if (status) {
		printk("load_hynix_opt_reg: reset fail");
	}
	status = write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&retry_end, NULL, NULL);
	if (status) {
		printk("load_hynix_opt_reg: OTP end 0x38 fail");
	}
	print_nand_buffer((uint8_t *)info->dmabuf, 1040);
	buff = info->dmabuf;
	if (buff[0] > 8 || buff[1] > 8) {
		printk("retry_cmd buff is not big enough for size %d\n", buff[0]*buff[1]);
		return -1;
	}

	cur_chip->total_try_times = buff[0];
	cur_chip->retry_reg_num = buff[1];
	for (i = 0; i < buff[0]; i++) {
		for (j = 0; j < buff[1]; j++) {
			if (i == 0)
				cur_chip->retry_def_value[j] = buff[j+2];
			else
				cur_chip->retry_value[(i-1)*buff[1]+j] = buff[i*buff[1]+j+2];
			if ((buff[i*buff[1]+j+2] ^ buff[(buff[0]+i)*buff[1]+j+2]) != 0xFF)
				printk("inverse check fail %x %x\n", buff[i*buff[1]+j+2], buff[(buff[0]+i)*buff[1]+j+2]);
		}
		if (i == 0)
			print_nand_buffer(cur_chip->retry_def_value, buff[1]);
		else
			print_nand_buffer(&cur_chip->retry_value[(i-1)*buff[1]], buff[1]);
	}
	cur_chip->retry_def_value[buff[1]] = 0xff;
	cur_chip->retry_def_value[buff[1]+1] = 0xff;
	cur_chip->total_try_times--;


	return 0;
}

int nand_get_para(struct mtd_info *mtd, struct nand_chip *chip)
{
	int ret = 0;
	struct nand_read_retry_param *cur_chip = chip->cur_chip;

	if (cur_chip->get_otp_table) {
		ret = cur_chip->get_otp_table(mtd, chip);
	} else if (cur_chip->get_parameter) {
		ret = cur_chip->get_parameter(mtd, READ_RETRY_MODE);
	}
	if (ret) {
		printk("get otp/default retry para error\n");
		chip->cur_chip = NULL;
		return ret;
	} else
		printk("get otp/default retry para end\n");

	if (cur_chip->eslc_reg_num)
		ret = cur_chip->get_parameter(mtd, ESLC_MODE);
	if (ret) {
		printk("get default eslc error\n");
		chip->cur_chip = NULL;
	} else
		printk("get eslc param end\n");

	print_nand_buffer((uint8_t *)cur_chip, sizeof(chip_table[0]));

	return ret;
}

static int wmt_nand_readID(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned int cfg = 0, i = 0;
	int status = -1;

	writeb(NAND_CMD_READID, info->reg + WMT_NFC_COMPORT0);
	writeb(0x00, info->reg + WMT_NFC_COMPORT1_2);
	cfg = DPAHSE_DISABLE|(0x02<<1);
	writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

	status = wmt_wait_cmd_ready(mtd);
	/*	status = wmt_nfc_ready(mtd);*/

	if (status) {
		printk(KERN_ERR "in wmt_nand_readID(): wait cmd is not ready\n");
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		return status;
	}
	cfg = NAND2NFC|SING_RW;
	for (i = 0; i < 6; i++) {
		writew(cfg|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		status = wmt_wait_cmd_ready(mtd);
		/*	status = wmt_nfc_ready(mtd);*/
		if (status)
				return status;
		status = wmt_nfc_transfer_ready(mtd);
		/* status = wmt_nand_wait_idle(mtd);*/
		if (status) {
			printk(KERN_ERR "in wmt_nand_readID(): wait transfer cmd is not ready\n");
			return status;
		}
		info->dmabuf[i] = readb(info->reg + WMT_NFC_DATAPORT) & 0xff;

		#ifdef NAND_DEBUG
			printk(KERN_NOTICE "readID is %x\n", readb(info->reg + WMT_NFC_DATAPORT));
		#endif
	}
	info->datalen = 0;
	return 0;
}

/* check flash busy pin is ready => return 1 else return 0 */
static int wmt_device_ready(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	return readb(info->reg + WMT_NFC_MISC_STAT_PORT) & 0x01;
}


static void wmt_nand_enable_hwecc(struct mtd_info *mtd, int mode)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	if (mode == hardware_ecc)
		writeb(readb(info->reg + WMT_NFC_MISC_CTRL) & 0xfb, info->reg + WMT_NFC_MISC_CTRL);
	else
		writeb(readb(info->reg + WMT_NFC_MISC_CTRL) | 0x04, info->reg + WMT_NFC_MISC_CTRL);
}

static void print_nand_register(struct mtd_info *mtd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	int j;
	
	for (j = 0; j < 0x130; j += 16)                                                 
			printk(KERN_NOTICE "NFCR%x ~ NFCR%x = 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x\r\n",
			j/4, (j+12)/4,                                                             
			readl(info->reg + j + 0),                                                  
			readl(info->reg + j + 4),                                                  
			readl(info->reg + j + 8),                                                  
			readl(info->reg + j + 12));
}

void print_nand_buffer(char *value, unsigned int length)
{
	int j;
	for (j = 0; j < length; j += 16)
		printk(KERN_NOTICE "Row%3.3x:%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x"
		"-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x-%2.2x\n",
		j, value[j+0], value[j+1], value[j+2], value[j+3], value[j+4],
		value[j+5], value[j+6], value[j+7], value[j+8], value[j+9],
		value[j+10], value[j+11], value[j+12], value[j+13], value[j+14], value[j+15]);
}
void print_nand_buffer_int(unsigned int *value, unsigned int length)
{
	int j;
	for (j = 0; j < length; j += 8)
		printk(KERN_NOTICE"Row%3.3x:%8.2x-%8.2x-%8.2x-%8.2x-%8.2x-%8.2x-%8.2x-%8.2x\n",
		j, value[j+0], value[j+1], value[j+2], value[j+3], value[j+4], value[j+5], value[j+6], value[j+7]);
}

static void set_read_addr(struct mtd_info *mtd, unsigned int *address_cycle, int column, int page_addr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_chip *chip = mtd->priv;
	unsigned int addr_cycle = 0;
	
	if (column != -1) {
		writeb(column, info->reg + WMT_NFC_COMPORT1_2);
		addr_cycle++;
		if (mtd->writesize != 512) {
			writeb(column >> 8, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
			addr_cycle++;
		}
		if (page_addr != -1) {
			if (mtd->writesize != 512) {
				writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
				page_addr >>= 8;
				writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
				addr_cycle += 2;
			} else {
				writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
				page_addr >>= 8;
				writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle += 2;
			}

			if (mtd->writesize == 2048) {
				/* One more address cycle for devices > 128MiB */
				if (chip->chipsize > (128 << 20)) {
					page_addr >>= 8;
					if (mtd->writesize != 512)
						writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
					else
						writeb(page_addr,
						(unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
					addr_cycle++;
				}
			} else if (mtd->writesize == 4096) {
				/* One more address cycle for devices > 256MiB */
				if (chip->chipsize > (256 << 20)) {
					page_addr >>= 8;
					if (mtd->writesize != 512)
						writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
					else
						writeb(page_addr,
						(unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
					addr_cycle++;
				}
			} else if (mtd->writesize == 8192) {
				/* One more address cycle for devices > 512MiB */
				if (chip->chipsize > (512 << 20)) {
					page_addr >>= 8;
					if (mtd->writesize != 512)
						writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
					else
						writeb(page_addr,
						(unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
					addr_cycle++;
				}
			} else if (mtd->writesize == 16384) {
				/* One more address cycle for devices > 1024MiB */
				if (chip->chipsize > (1024 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
					addr_cycle++;
				}
			} else {/*page size 512*/
				/* One more address cycle for devices > 32MiB */
				if (chip->chipsize > (32 << 20)) {
					page_addr >>= 8;
					if (mtd->writesize != 512)
						writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
					else
						writeb(page_addr,
						(unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
					addr_cycle++;
				}
			}
		}
	/* } else if (page_addr != -1) {*/
	} else if ((page_addr != -1) && (column == -1)) {
		writeb(page_addr & 0xff, info->reg + WMT_NFC_COMPORT1_2);
		page_addr >>= 8;
		writeb(page_addr & 0xff, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
		addr_cycle += 2;

		if (mtd->writesize == 2048) {
			/* One more address cycle for devices > 128MiB */
			if (chip->chipsize > (128 << 20)) {
				page_addr >>= 8;
				writeb(page_addr & 0xff,
				info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle++;
			}
		} else if (mtd->writesize == 4096) {
			/* One more address cycle for devices > 256MiB */
			if (chip->chipsize > (256 << 20)) {
				page_addr >>= 8;
				writeb(page_addr & 0xff,
				info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle++;
			}
		} else if (mtd->writesize == 8192) {
			/* One more address cycle for devices > 512MiB */
			if (chip->chipsize > (512 << 20)) {
				page_addr >>= 8;
				writeb(page_addr & 0xff,
				info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle++;
			}
		} else if (mtd->writesize == 16384) {
			/* One more address cycle for devices > 1024MiB */
			if (chip->chipsize > (1024 << 20)) {
				page_addr >>= 8;
				writeb(page_addr & 0xff,
				info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle++;
			}
		} else {/*page size = 512 bytes */
			/* One more address cycle for devices > 32MiB */
			if (chip->chipsize > (32 << 20)) {

				/* One more address cycle for devices > 128MiB */
				/* if (chip->chipsize > (128 << 20)) {*/
				page_addr >>= 8;
				/*  writeb(page_addr,
				info->reg + WMT_NFC_COMPORT3_4 + 1); */
				/* before, may be a little error */
				writeb(page_addr & 0xff,
				info->reg + WMT_NFC_COMPORT3_4);
				addr_cycle++;
			}
		}
	}
	*address_cycle = addr_cycle;
}

static int wmt_nand_page_read(struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_chip *chip = mtd->priv;
	struct nand_read_retry_param *cur_chip = chip->cur_chip;
	unsigned int addr_cycle = 0, b2r_stat;
	int status = -1;
	unsigned int bank_stat;
	int i, total_times = 1;
	unsigned char reset = NAND_CMD_RESET;
	DECLARE_COMPLETION(complete);

	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "read data cmd: 0x%x col:0x%x, page:0x%x\n",	command, column, page_addr);
	#endif
	/*info->phase = 0;
	if (readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & DIS_BCH_ECC)
		info->phase = 2;*/

	if (cur_chip != NULL) {
		total_times = cur_chip->total_try_times + 1;
		//printk("read page--cur_times = %d, totoal_times = %d \n", cur_times, total_times);
	}
	//cur_chip->cur_try_times = 4;
	for (i = 0; i < total_times; i++) {
		if (i > 0)
			info->isr_cmd = command;

		info->data_ecc_uncor_err = 0;
		info->dma_finish = 0;
		writeb(0x0F, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		info->done_data = &complete;
		/* 1: read, 0:data, -1:  */
		if (info->phase == 2) {
			wmt_nfc_dma_cfg(mtd, mtd->writesize+mtd->oobsize-(mtd->oobsize%16), 0, -1, -1);
		} else {
			if (info->oob_ecc_error == 0x50)//read last bank when read oob ecc happen
				wmt_nfc_dma_cfg(mtd, chip->ecc.size, 0, -1, -1);
			else
				wmt_nfc_dma_cfg(mtd, mtd->writesize, 0, -1, -1);
		}
		/*print_nand_register(mtd);*/
	
		info->datalen = 0;
		/* write to clear B2R */
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
		/* printk(KERN_NOTICE "RB is %d\n", b2r_stat & 0x02);*/
	
		set_read_addr(mtd, &addr_cycle, column, page_addr);
	
		bank_stat = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
		writew(bank_stat|0x101, info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	
		status = wmt_wait_chip_ready(mtd); /*Vincent 2008.11.3*/
		if (status)
			printk(KERN_ERR "The chip is not ready\n");
		writeb(NAND_CMD_READ0, info->reg + WMT_NFC_COMPORT0);
		if (addr_cycle == 4)
			writeb(NAND_CMD_READSTART, info->reg + WMT_NFC_COMPORT5_6);
		else if (addr_cycle == 5)
			writeb(NAND_CMD_READSTART, (unsigned char *)(info->reg + WMT_NFC_COMPORT5_6) + 1);
	
		writew(NAND2NFC|MUL_CMDS|((addr_cycle + 2)<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
	
		
		//printk("read wait for completion\n");
		wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
		if (info->dma_finish != 1)
			printk("read page wait dma time out");
		status = nand_pdma_handler(mtd);
		//printk(KERN_ERR "check status pdma handler status= %x \n", status);
		nand_free_pdma(mtd);
		if (status)
			printk(KERN_ERR "dma transfer data time out: %x\n",
			readb(info->reg + WMT_NFC_MISC_STAT_PORT));
	
		wmt_nfc_transfer_ready(mtd);
		status = wmt_nand_ready(mtd);
		if (status)
			printk(KERN_NOTICE"B2R not clear status=0x%x\n", status);
		writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);	

		status = wmt_nfc_wait_idle(mtd, 0, command, column, page_addr);

		if (status) {
			printk(KERN_NOTICE"read page wait idle status =%d\n", status);
			/*print_nand_register(mtd);*/
			/*while(1);*/
		}

		if(info->data_ecc_uncor_err == 1) {
			if((cur_chip != NULL)) {
				printk("Uncor Ecc Err %d_th, on page 0x%x fail., cur_try_time=%d\n", i, page_addr, cur_chip->cur_try_times);
				if ((cur_chip->nand_id>>24) == NAND_MFR_HYNIX) {
					//printk("set retry mode cur_try_times=%d\n", cur_chip->cur_try_times);
					cur_chip->set_parameter(mtd, READ_RETRY_MODE, ECC_ERROR_VALUE);
					cur_chip->retry = 1;
					
					if (i == (total_times-1)) {
						/* read retry many times still ecc uncorrectable error */
						printk("read page after retry still uncor err\n");
						mtd->ecc_stats.failed++;
						//while(cur_chip);
						return status;
					}
				} else if ((cur_chip->nand_id>>24) == NAND_MFR_TOSHIBA) {
					if (cur_chip->cur_try_times >= cur_chip->total_try_times) {
						/* send reset cmd after read retry finish(fail) for toshiba */
						write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&reset, NULL, NULL);
						cur_chip->cur_try_times = 0;
						cur_chip->retry = 0;
						printk("read page after retry still uncor err\n");
						mtd->ecc_stats.failed++;
						//while(cur_chip);
						return status;
					}
					if (cur_chip->cur_try_times == 0 && cur_chip->retry != 1)
						toshiba_pre_condition(mtd);
					cur_chip->set_parameter(mtd, 0, 0);
					cur_chip->retry = 1;
				}
			} else {
				printk("read page uncor err but cur_chip = NULL!\n");
				break;
			}
		} else {
			if (cur_chip) {
				if (cur_chip->retry == 1)
					printk("read retry PASS cur_try_times=%d\n", cur_chip->cur_try_times);
				/* send reset cmd after read retry finish(pass) for toshiba */
				if (cur_chip != NULL && (cur_chip->nand_id>>24) == NAND_MFR_TOSHIBA && cur_chip->retry == 1) {
					write_bytes_cmd(mtd, 1, 0, 0, (uint8_t *)&reset, NULL, NULL);
					printk("reset cmd to finish retry\n");
					cur_chip->cur_try_times = 0;
				}
				cur_chip->retry = 0;
			}
			break;
		}
	} //end of retry for loop

	return 0;
}

static void wmt_nand_oob_read(struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	//struct nand_chip *chip = mtd->priv;
	unsigned int addr_cycle = 0, b2r_stat;
	int status = -1;
	unsigned int bank_stat;
	int mycolumn = column, mypage_addr = page_addr;
	DECLARE_COMPLETION(complete);

	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "wmt_nand_oob_read: readoob col=0x%x, page=0x%x\n", column, page_addr);
	#endif
	/*  memcpy(info->dmabuf + info->datalen, 0x00, 64);*/
	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	info->done_data = &complete;

	info->datalen = 0;
	/* write to clear B2R */
	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
	/* printk(KERN_NOTICE "RB is %d\n", b2r_stat & 0x02);*/

	set_read_addr(mtd, &addr_cycle, column, page_addr);

	bank_stat = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
	writew(bank_stat|0x101, info->reg + WMT_NFC_ECC_BCH_INT_STAT1);

	/* printk(KERN_NOTICE "\r ECC OOB MODE(9)0x024 %8.8x\n",
	readl(info->reg + WMT_NFC_SMC_ENABLE));*/
	
	status = wmt_wait_chip_ready(mtd); /*Vincent 2008.11.3*/
	if (status)
		printk(KERN_ERR "The chip is not ready\n");
	writeb(NAND_CMD_READ0, info->reg + WMT_NFC_COMPORT0);
	if (addr_cycle == 4)
		writeb(NAND_CMD_READSTART, info->reg + WMT_NFC_COMPORT5_6);
	else if (addr_cycle == 5)
		writeb(NAND_CMD_READSTART, (unsigned char *)(info->reg + WMT_NFC_COMPORT5_6) + 1);

	writew(NAND2NFC|MUL_CMDS|((addr_cycle + 2)<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

	
	/* read oob has no dma but assert B2R status */
	//printk("read oob wait for completion");
	wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
	status = wmt_nfc_transfer_ready(mtd);
	if (status)
		printk(KERN_NOTICE"oob read wait NFC_BUSY time out\n");
	//wmt_nand_ready(mtd);
	writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);

	status = wmt_nfc_wait_idle(mtd, 0, command, mycolumn, mypage_addr);
	if (command == NAND_CMD_READOOB) {
		/* disable_redunt_out_bch_ctrl(info, 0);*/
		/* writeb(readb(info->reg + WMT_NFC_CALC_CTRL) &0xFFFFFFFD ,
		info->reg + WMT_NFC_CALC_CTRL);*/ /*Vincent 2008.11.3*/
	}

	if (status) {
		if (status == -4)
			return;
		printk(KERN_ERR "wmt_nfc_wait_idle status =%d\n", status);
		printk(KERN_ERR "command =0x%x\n", command);
		printk(KERN_ERR "Read ERR ,NFC is not idle\n");
		/*print_nand_register(mtd);*/
		writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
		info->reg + WMT_NFC_ECC_BCH_CTRL);
		/*while(1);*/
	}
	return;
}

/*
 * wmt_nand_cmdfunc - Send command to NAND large page device
 * @mtd:	MTD device structure
 * @command:	the command to be sent
 * @column:	the column address for this command, -1 if none
 * @page_addr:	the page address for this command, -1 if none
 *
 * Send command to NAND device. This is the version for the new large page
 * devices We dont have the separate regions as we have in the small page
 * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
 */
static void wmt_nand_cmdfunc(struct mtd_info *mtd, unsigned command, int column, int page_addr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct nand_chip *chip = mtd->priv;
	unsigned int addr_cycle = 0, b2r_stat, pmc_nand, chip_en;
	int status = -1;
	int mycolumn, mypage_addr;
	DECLARE_COMPLETION(complete);

	if (mtd->id == 0xECDED57A) {
		if (page_addr >= (4096*128)) {
			page_addr = page_addr + 0x80000;
			//printk(KERN_NOTICE "cmd %x col:%x, page:0x%x\n", command, column, page_addr);
		}
	}
	mycolumn = column;
	mypage_addr = page_addr;
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_cmdfunc() command: %x column:%x, page_addr:%x\n",
	command, column, page_addr);
	#endif
	info->isr_cmd = command;
	info->cur_page = page_addr;
	info->phase = 0;
	if (readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & DIS_BCH_ECC)
		info->phase = 2;
	pmc_nand = *(volatile unsigned long *)PMCEU_ADDR;// |= (0x0010000);//add by vincent
	if (!(pmc_nand&0x0010000))
		printk(KERN_NOTICE "pmc_nand=0x%x\n", pmc_nand);

	chip_en = readb(info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
	if ((chip_en&3) == 3) {
		printk(KERN_NOTICE "chip 0, or 1, is not select chip_sel=%x\n", chip_en);
		writeb(0xfe, info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
	}

	switch (command) {
	case NAND_CMD_READ0:
		wmt_nand_page_read(mtd, command, column, page_addr);
		return;
	case NAND_CMD_READOOB:
		wmt_nand_oob_read(mtd, command, column, page_addr);
		return;
	case NAND_CMD_SEQIN:
	case NAND_CMD_ERASE1:
		/* printk(KERN_NOTICE "command is %x\n", command);*/
		if (column != -1) {
			writeb(column, info->reg + WMT_NFC_COMPORT1_2);
			addr_cycle++;
			/*#ifndef PAGE_ADDR*/
			if (mtd->writesize != 512) {
				writeb(column >> 8, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
				addr_cycle++;
			}/*#endif*/
			if (page_addr != -1) {
				/*#ifndef PAGE_ADDR*/
				if (mtd->writesize != 512) {
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					page_addr >>= 8;
					writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
					addr_cycle += 2;
				/*#else*/
				} else {
					writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle += 2;
				} /*#endif*/

				if (mtd->writesize == 2048) {
				/* One more address cycle for devices > 128MiB */
					if (chip->chipsize > (128 << 20)) {
						page_addr >>= 8;
						/*#ifndef PAGE_ADDR*/
						if (mtd->writesize != 512)
							writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
						else /*#else*/
							writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
						/*#endif*/
						addr_cycle++;
					}
				} else if (mtd->writesize == 4096) {
					/* One more address cycle for devices > 256MiB */
					if (chip->chipsize > (256 << 20)) {
						page_addr >>= 8;
						/*#ifndef PAGE_ADDR*/
						if (mtd->writesize != 512)
							writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
						else /*#else*/
							writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
						/*#endif*/
						addr_cycle++;
					}
				} else if (mtd->writesize == 8192) {
					/* One more address cycle for devices > 512MiB */
					if (chip->chipsize > (512 << 20)) {
						page_addr >>= 8;
						if (mtd->writesize != 512)
							writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
						addr_cycle++;
					}
				} else if (mtd->writesize == 16384) {
					/* One more address cycle for devices > 1024MiB */
					if (chip->chipsize > (1024 << 20)) {
						page_addr >>= 8;
						writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
						addr_cycle++;
					}
				} else {
					/* One more address cycle for devices > 32MiB */
					if (chip->chipsize > (32 << 20)) {
						page_addr >>= 8;
						/*#ifndef PAGE_ADDR*/
						if (mtd->writesize != 512)
							writeb(page_addr, info->reg + WMT_NFC_COMPORT5_6);
						else /*#else*/
							writeb(page_addr, (unsigned char *)(info->reg + WMT_NFC_COMPORT3_4) + 1);
						/*#endif*/
						addr_cycle++;
					}
				}
			}
		/*} else if (page_addr != -1) {*/
		} else if ((page_addr != -1) && (column == -1)) {
			writeb(page_addr & 0xff, info->reg + WMT_NFC_COMPORT1_2);
			page_addr >>= 8;
			writeb(page_addr & 0xff, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
			addr_cycle += 2;

			if (mtd->writesize == 2048) {
				/* One more address cycle for devices > 128MiB */
				if (chip->chipsize > (128 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle++;
				}
			} else if (mtd->writesize == 4096) {
				/* One more address cycle for devices > 256MiB */
				if (chip->chipsize > (256 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle++;
				}
			} else if (mtd->writesize == 8192) {
				/* One more address cycle for devices > 512MiB */
				if (chip->chipsize > (512 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle++;
				}
			} else if (mtd->writesize == 16384) {
				/* One more address cycle for devices > 1024MiB */
				if (chip->chipsize > (1024 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle++;
				}
			} else {
				/* One more address cycle for devices > 32MiB */
				if (chip->chipsize > (32 << 20)) {
					page_addr >>= 8;
					writeb(page_addr, info->reg + WMT_NFC_COMPORT3_4);
					addr_cycle++;
				}
			}
		}

		/* set command 1 cycle */
		writeb(command, info->reg + WMT_NFC_COMPORT0);
		if (command == NAND_CMD_SEQIN) {
			info->done_data = &complete;
			writew(((addr_cycle + 1)<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		} else {
			/* writeb(read(info->reg + WMT_NFC_NAND_TYPE_SEL) | WP_DISABLE ,
			info->reg + WMT_NFC_NAND_TYPE_SEL);*/
			writew(DPAHSE_DISABLE|((addr_cycle + 1)<<1)|NFC_TRIGGER|OLD_CMD,
			info->reg + WMT_NFC_COMCTRL);
		}

		if (command == NAND_CMD_ERASE1) {
			status = wmt_wait_cmd_ready(mtd);
			/* status = wmt_nfc_ready(mtd); */
			if (status)
					printk(KERN_ERR "command is not ready\n");
					writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
					info->reg + WMT_NFC_ECC_BCH_CTRL);
		}	else {
			wmt_wait_nfc_ready(info);
			status = wmt_nfc_transfer_ready(mtd);
			wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
			/*status = wmt_wait_dma_ready(mtd);*/ /*dannier mask*/
			if (status)	{
				printk(KERN_ERR "dma transfer data is not ready: %x\n",
				readb(info->reg + WMT_NFC_MISC_STAT_PORT));
				writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
				info->reg + WMT_NFC_ECC_BCH_CTRL);
				/*printk(KERN_NOTICE "\rwait transfer data is not ready: %x\n",
				readb(info->reg + WMT_NFC_MISC_STAT_PORT));*/
				/*print_nand_register(mtd);*/
				/* while (1);*/
				/* return;*/
			}
		}
		return;

	case NAND_CMD_PAGEPROG:
		/* case NAND_CMD_READSTART:*/
	case NAND_CMD_ERASE2:
		/* printk(KERN_NOTICE "command is %x\n", command);*/
		writeb(command, info->reg + WMT_NFC_COMPORT0);
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		if (B2R&b2r_stat) {
			printk(KERN_NOTICE"flash B2R status assert command=0x%x\n",command);
			writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
			status = wmt_wait_chip_ready(mtd); /*Vincent 2008.11.3*/
			if (status)
				printk(KERN_NOTICE"The chip is not ready\n");
		}

		if (NAND_CMD_ERASE2 == command) {
			b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
			writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
			writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		}
		info->done_data = &complete;
		writew(DPAHSE_DISABLE|(1<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

		info->datalen = 0;
		wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
		writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		#if 0  /* for debug */
		if (command == NAND_CMD_ERASE2) {
			wmt_read_nand_status(mtd, NAND_CMD_STATUS);
			if ((readb(info->reg + WMT_NFC_DATAPORT) & 0xff) == 0xc0) {
				printk(KERN_NOTICE "wmt_func: erase block OK\n");
				printk(KERN_NOTICE "read nand status is %x\n",
				readb(info->reg + WMT_NFC_DATAPORT) & 0xff);
			}	else
				printk(KERN_NOTICE "wmt_func: erase block failed\n");
		}
		#endif

		status = wmt_nfc_wait_idle(mtd, 1, 1, -1, -1); /* write page, don't check ecc */
		if (status < 0) {
			printk(KERN_ERR "page program or erase err, nand controller is not idle\n");
			/*print_nand_register(mtd);*/
			/* writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);*/
			/* while (1);*/
			/* return;*/
			/* }*/
			#if 0
			status = wmt_read_nand_status(mtd, NAND_CMD_STATUS);
			if (status < 0)
				printk(KERN_NOTICE "\rNFC or NAND is not ready\n");
			else if (status & NAND_STATUS_FAIL)
				printk(KERN_NOTICE "\r status : fail\n");
			else if (!(status & NAND_STATUS_READY))
				printk(KERN_NOTICE "\r status : busy\n");
			else if (!(status & NAND_STATUS_WP))
				printk(KERN_NOTICE "\r status : protect\n");
			#endif
			return;
		}

		return;

	case NAND_CMD_RESET_NO_STATUS_READ:
	case NAND_CMD_HYNIX_RETRY_END:

		if (!chip->dev_ready)
			break;
		udelay(chip->chip_delay);
		writeb(command, info->reg + WMT_NFC_COMPORT0);
		/* write to clear B2R */
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

		writew(DPAHSE_DISABLE|(0x01<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		status = wmt_nand_ready(mtd);
		if (status) {
			printk(KERN_ERR "Reset err, nand device is not ready\n");
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
		}

		return;
	
	case NAND_CMD_RESET:

		if (!chip->dev_ready)
			break;
		udelay(chip->chip_delay);
		writeb(command, info->reg + WMT_NFC_COMPORT0);
		/* write to clear B2R */
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

		writew(DPAHSE_DISABLE|(0x01<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		status = wmt_nand_ready(mtd);
		if (status) {
			printk(KERN_ERR "Reset err, nand device is not ready\n");
			writew(readw(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
			info->reg + WMT_NFC_ECC_BCH_CTRL);
		}

		wmt_read_nand_status(mtd, NAND_CMD_STATUS);
		/*  while (!(chip->read_byte(mtd) & NAND_STATUS_READY));*/
		while (!((readb(info->reg + WMT_NFC_DATAPORT) & 0xff) & NAND_STATUS_READY))
			;
		#ifdef NAND_DEBUG
		printk(KERN_NOTICE "Reset status is ok\n");
		#endif
		return;

	case NAND_CMD_READID:

		status = wmt_nand_readID(mtd);
		#ifdef NAND_DEBUG
		printk(KERN_NOTICE "readID status is %d\n", status);
		#endif
		return;

	case NAND_GET_FEATURE:		
		status = nand_get_feature(mtd);		
	return;

	case NAND_CMD_STATUS:

		wmt_read_nand_status(mtd, command);
		return;

	case NAND_CMD_RNDIN:
		if (column != -1) {
			writeb(column, info->reg + WMT_NFC_COMPORT1_2);
			addr_cycle++;
			if (mtd->writesize != 512) {
				writeb(column >> 8, (unsigned char *)(info->reg + WMT_NFC_COMPORT1_2) + 1);
				addr_cycle++;
			}
		}
		info->done_data = &complete;
		/* set command 1 cycle */
		writeb(command, info->reg + WMT_NFC_COMPORT0);

		writew(((addr_cycle + 1)<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);
		wait_for_completion_timeout(&complete, NFC_TIMEOUT_TIME);
		status = wmt_nfc_wait_idle(mtd, 1, -1, -1, -1); /* don't check ecc, wait nfc idle */
		/*  status = wmt_wait_cmd_ready(mtd);*/
		/* status = wmt_nfc_ready(mtd);*/
		if (status)
			printk(KERN_ERR "Ramdom input err: nfc is not idle\n");

		return;

	case NAND_CMD_RNDOUT:

		if (column != -1) {
			writeb(column, info->reg + WMT_NFC_COMPORT1_2);
			writeb(column, info->reg + WMT_NFC_COMPORT1_2 + 1);
			addr_cycle += 2;
		}

		/* CLEAR ECC BIT */
		writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT);
		writel(0xffffffff, info->reg + WMT_NFC_BANK18_ECC_STAT);
		/* write to clear B2R */
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

		/* set command 1 cycle */
		writeb(command, info->reg + WMT_NFC_COMPORT0);

		writew(DPAHSE_DISABLE|((addr_cycle + 1)<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

		status = wmt_wait_cmd_ready(mtd);
		/* status = wmt_nfc_ready(mtd);*/
		if (status) {
			printk(KERN_ERR "Ramdom output err: nfc command is not ready\n");
			/* return;*/
		}

		writeb(NAND_CMD_RNDOUTSTART, info->reg + WMT_NFC_COMPORT0);
		/* write to clear B2R */
		b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
		writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

		writew(NAND2NFC|(1<<1)|NFC_TRIGGER|OLD_CMD, info->reg + WMT_NFC_COMCTRL);

		status = wmt_wait_cmd_ready(mtd);
		/* status = wmt_nand_ready(mtd);*/
		if (status) {
			printk(KERN_ERR "Ramdom output err: nfc io transfer is not finished\n");
			/* return;*/
		}
		/* reduntant aera check ecc, wait nfc idle */
		status = wmt_nfc_wait_idle(mtd, 0, -1, -1, -1);
		/* status = wmt_nand_wait_idle(mtd);*/
		if (status)
			printk(KERN_ERR "Ramdom output err: nfc is not idle\n");
		return;


	case NAND_CMD_STATUS_ERROR:
	case NAND_CMD_STATUS_ERROR0:
		udelay(chip->chip_delay);
		return;


	default:
		/*
		 * If we don't have access to the busy pin, we apply the given
		 * command delay
		 */

		/* trigger command and addrress cycle */

		if (!chip->dev_ready) {
			udelay(chip->chip_delay);
			return;
		}
	}
	/* Apply this short delay always to ensure that we do wait tWB in */
	/* any case on any machine.*/
	/* ndelay(100);*/
	wmt_device_ready(mtd);
	/*if (((*(volatile unsigned long *)(GPIO_BASE_ADDR + 0x100))&6) == 2)
		spin_unlock(nand_lock);*/
}


static void wmt_nand_select_chip(struct mtd_info *mtd, int chipnr)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	unsigned int b2r_stat;
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "\r enter in wmt_nand_select_chip()\n");
	#endif
	if (!((*(volatile unsigned long *)PMCEU_ADDR)&0x0010000))
		*(volatile unsigned long *)PMCEU_ADDR |= (0x0010000);
	if (chipnr > 1)
		printk(KERN_WARNING "There are only support two chip sets\n");

	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

    if (chipnr >= 0 && chipnr < 2)
        writeb(~(1<<chipnr), info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
    else if (chipnr < 0)
        writeb(~0, info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
    else                                                                                                                                     
        printk(KERN_WARNING "There are only support two chip sets. chipnr = %d\n", chipnr);
}

#ifdef WMT_RDMZ
void rdmzier(uint8_t *buf, int size, int page)
{
	int i, j;
	unsigned int *bi = (unsigned int *)buf;
	j = page%256;

	for (i = 0; i < size; i++) {
		bi[i]	= rdmz[j] ^ bi[i];
		j++;
		if (j >= BYTE_SEED)
			j = 0;
	}
}
void rdmzier_oob(uint8_t *buf, uint8_t *src, int size, int page, int ofs)
{
	int i, j;
	unsigned int *bi = (unsigned int *)buf;
	unsigned int *bs = (unsigned int *)src;
	j = page%256;
	j = (j+ofs)%BYTE_SEED;

	for (i = 0; i < size; i++) {
		bi[i]	= rdmz[j] ^ bs[i];
		j++;
		if (j >= BYTE_SEED)
			j = 0;
	}
}
#endif

static void wmt_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_write_buf()\n");
	#endif
	memcpy(info->dmabuf + info->datalen, buf, len);

	info->datalen += len;
}

static void wmt_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_read_buf() len: %x infoDatalen :%x\n", len, info->datalen);
	#endif

	memcpy(buf, info->dmabuf + info->datalen, len);
	info->datalen += len;
}

static uint8_t wmt_read_byte(struct mtd_info *mtd)
{
	/* struct wmt_nand_mtd *nmtd = mtd->priv;*/
	/* struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);*/
	uint8_t d;
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_read_byte()\n");
	#endif

	/* d = readb(info->reg + WMT_NFC_DATAPORT) & 0xff;*/
	 wmt_nand_read_buf(mtd, &d, 1);
	/* via_dev_dbg(&nmtd->info->platform->dev, "Read %02x\n", d);*/
	/* via_dev_dbg(info->platform->dev, "Read %02x\n", d);*/

	return d;
}

static int wmt_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip, int page, int sndcmd)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	uint8_t *buf = chip->oob_poi;
	/* int length = mtd->oobsize;  */ /* prepad = chip->ecc.prepad, bytes = chip->ecc.bytes;*/
	/* int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;*/
	/* int eccsize = chip->ecc.size;*/
	uint8_t *bufpoi = buf;
	/* struct nand_oobfree *free = chip->ecc.layout->oobfree;*/
	/* uint32_t boffs;*/
	/* int pos;   */ /* toread, sndrnd = 1;*/
	#ifdef WMT_RDMZ
	unsigned int rdmz_mark = 0;
	#endif

	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "\r enter in wmt_nand_read_oob() page =0x%x\n", page);
	#endif
	/* info->datalen = mtd->writesize;*/  /* oob data is placed in after info->dmabuf[2047]  */

	
	/*  for (i = 0; i < chip->ecc.steps; i++) {*/
	/*for (i = 0; i < 4; i++) {*/
	// read redundant area cmd
	//printk(KERN_NOTICE "scan oob page=%d\n", page);
	info->oob_ecc_error = 0;
	//writew(mtd->writesize - 1, info->reg + WMT_NFC_DMA_COUNTER);
	writeb(readb(info->reg + WMT_NFC_SMC_ENABLE) | 0x2,
	info->reg + WMT_NFC_SMC_ENABLE);
	writeb((info->oob_ECC_bytes+1), info->reg + WMT_NFC_REMAINDER+1);
	if (info->ECC_mode != info->oob_ECC_mode)
		set_ecc_engine(info, info->oob_ECC_mode);
	//pos = info->oob_col/*+ i * (eccsize + chunk);*/
	//print_nand_register(mtd);
	chip->cmdfunc(mtd, NAND_CMD_READOOB, info->oob_col, page);
	if (info->ECC_mode != info->oob_ECC_mode)
		set_ecc_engine(info, info->ECC_mode);
	writeb(info->oob_ECC_bytes, info->reg + WMT_NFC_REMAINDER+1);
	writeb(readb(info->reg + WMT_NFC_SMC_ENABLE) & 0xfd,
	info->reg + WMT_NFC_SMC_ENABLE);

	// read last bank cmd	
	if (info->oob_ecc_error == 0x50) {
		//printk(KERN_NOTICE "Rebk page=%d\n", page);
		//pos = info->last_bank_col = pos - eccsize;//(eccsize + chip->ecc.bytes) * (chip->ecc.steps-1)
		writeb(readb(info->reg + WMT_NFC_ECC_BCH_CTRL) | 0x10, info->reg + WMT_NFC_ECC_BCH_CTRL);
		//printk("Re_oob fail,read last bk col=%d oob_col=%d\n", info->last_bank_col, info->oob_col);
		//print_nand_register(mtd);
		chip->cmdfunc(mtd, NAND_CMD_READ0, info->last_bank_col, page);
		writeb(readb(info->reg + WMT_NFC_ECC_BCH_CTRL) & ((~0x10)&0xFF), info->reg + WMT_NFC_ECC_BCH_CTRL);
		info->oob_ecc_error = 0;
		//printk(KERN_NOTICE "Rebk 8c=0x%x\n", readl(info->reg + WMT_NFC_ECC_BCH_CTRL));
	} else {
		#ifdef NAND_DEBUG
		int i;
		uint8_t *tmp = info->reg+ECC_FIFO_0;
		for (i=0;i<64;i++) {
			if (tmp[i]!=0xFF) {
				printk(KERN_NOTICE "FAIL-data not all FF, i=%d page=%d\n", i, page);
				break;
			}
		}
		if (i == 64)
			printk(KERN_NOTICE "ob pass\n");
		#endif
	}
	#ifdef WMT_RDMZ
	rdmzier_oob((uint8_t *)&rdmz_mark, (uint8_t *)(info->reg+ECC_FIFO_5), 1, page, (mtd->writesize+20)/4);
	//printk("re oob page=0x%x rdmz_mark=0x%x wmt_rdmz=0x%x fifo5=0x%x\n",page , rdmz_mark, *(unsigned int *)wmt_rdmz, *(unsigned int *)(info->reg+ECC_FIFO_5));
	if (mtd->dwRdmz == 1 && rdmz_mark == *(unsigned int *)wmt_rdmz) {
		rdmzier_oob(bufpoi, (uint8_t *)(info->reg+ECC_FIFO_0), 5, page, mtd->writesize/4);
	}	else
	#endif
		memcpy(bufpoi, info->reg+ECC_FIFO_0, 24);
	/*chip->read_buf(mtd, bufpoi, 32);*/
	/*chip->read_buf(mtd, bufpoi + i * 16, 16);*/
	/*}*/
	return 1;
}


/*
 * wmt_nand_read_raw_page
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @page:	page number to read
 * @sndcmd:	flag whether to issue read command or not
 */
static int wmt_nand_read_raw_page(struct mtd_info *mtd, struct nand_chip *chip, int page)
{
	unsigned int tmp, bch, ecc_bit_mode;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);

	tmp = readl(info->reg + WMT_NFC_NAND_TYPE_SEL);
	bch = readl(info->reg + WMT_NFC_ECC_BCH_CTRL);
	writeb((tmp & 0xfffffffc)+3,	info->reg + WMT_NFC_NAND_TYPE_SEL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & 0xfffffff8, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writew(eccBCH_inetrrupt_disable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);

	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);

	//info->datalen = mtd->writesize;
	//chip->read_buf(mtd, chip->oob_poi, 64);
	//memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, 64);
	//nfc_ecc_set(info, 1);   /* on hardware ecc  */
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & 0xfffffff7, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | bch, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writeb(tmp,	info->reg + WMT_NFC_NAND_TYPE_SEL);
	writew(eccBCH_inetrrupt_disable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);

	ecc_bit_mode = mtd->dwECCBitNum;
	if (ecc_bit_mode > 24)
		ecc_bit_mode = (ecc_bit_mode == 40) ? 6 : (-1);
	else
		ecc_bit_mode = (ecc_bit_mode > 16) ? ((ecc_bit_mode/4) - 1) : (ecc_bit_mode/4);
	set_ecc_engine(info, ecc_bit_mode);  /* BCH ECC structure 12bit ecc engine*/
	
	return 0;
}


/*
 * wmt_nand_read_bb_oob - OOB data read function
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @page:	page number to read
 * @sndcmd:	flag whether to issue read command or not
 */
static int wmt_nand_read_bb_oob(struct mtd_info *mtd, struct nand_chip *chip,
int page, int sndcmd)
{
	unsigned int tmp, bch, ecc_bit_mode;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "\r enter in wmt_nand_read_bb_oob() page=0x%x\n", page);
	#endif
	tmp = readl(info->reg + WMT_NFC_NAND_TYPE_SEL);
	bch = readl(info->reg + WMT_NFC_ECC_BCH_CTRL);
	writeb((tmp & 0xfffffffc)+3,	info->reg + WMT_NFC_NAND_TYPE_SEL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & 0xfffffff8, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | DIS_BCH_ECC, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writew(eccBCH_inetrrupt_disable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);

	if (sndcmd) {
		chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
		sndcmd = 0;
	}
	info->datalen = mtd->writesize;
	chip->read_buf(mtd, chip->oob_poi, 64);
	//memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, 64);
	//nfc_ecc_set(info, 1);   /* on hardware ecc  */
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) & 0xfffffff7, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | bch, info->reg + WMT_NFC_ECC_BCH_CTRL);
	writeb(tmp,	info->reg + WMT_NFC_NAND_TYPE_SEL);
	writew(eccBCH_inetrrupt_disable, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
	writel(readl(info->reg + WMT_NFC_ECC_BCH_CTRL) | READ_RESUME,
	info->reg + WMT_NFC_ECC_BCH_CTRL);

	ecc_bit_mode = mtd->dwECCBitNum;
	if (ecc_bit_mode > 24)
		ecc_bit_mode = (ecc_bit_mode == 40) ? 6 : (-1);
	else
		ecc_bit_mode = (ecc_bit_mode > 16) ? ((ecc_bit_mode/4) - 1) : (ecc_bit_mode/4);
	set_ecc_engine(info, ecc_bit_mode);  /* BCH ECC structure 12bit ecc engine*/
	
	return sndcmd;
}


/* write oob is no longer support */
static int wmt_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip, int page)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	/*int i;*/
	unsigned int b2r_stat;
	/*int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;*/
	int eccsize = chip->ecc.size; /* length = mtd->oobsize;  */
	/* prepad = chip->ecc.prepad, bytes = chip->ecc.bytes;*/

	int pos, status = 0;
	/*int steps = chip->ecc.steps;*/  /* Vincent 2008.11.4*/
	const uint8_t *bufpoi = chip->oob_poi;
	/* struct nand_oobfree *free = chip->ecc.layout->oobfree;*/
	/* uint32_t boffs;*/
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "\r enter in wmt_nand_write_oob()\n");
	#endif
	/*
	 * data-ecc-data-ecc ... ecc-oob
	 * or
	 * 512  7     1     5    0    3
	 * data-ecc-prepad-data-pad-oobecc ....
	 */

	/* 	for (i = 0; i < steps; i++) {*/
	/*for (i = 0; i < 4; i++) {*/
	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);

	info->datalen = 0;
	/*chip->write_buf(mtd, bufpoi, 32);*/
	memcpy(info->reg+ECC_FIFO_0, bufpoi, 32);
	pos = eccsize * chip->ecc.steps + 8*4;
	/*pos = eccsize + i * (eccsize + chunk);*/
	/*wmt_nfc_dma_cfg(mtd, 32, 1, 1, i);*/
	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);

	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
	/* printk(KERN_NOTICE "\r in wmt_nand_write_oob_new(): waitfunc_1\n");*/
	status = chip->waitfunc(mtd, chip);
	/* printk(KERN_NOTICE "\r in wmt_nand_write_oob_new(): waitfunc_2\n");*/
	if (status & NAND_STATUS_FAIL)
		return -EIO;
	/* } */
	return 0;

}

unsigned int reverse32 (unsigned int n)
{
	int i=0;
	unsigned int tmp = n, y=0;
	for(;i<31;i++) {
		y += tmp&0x00000001;
		tmp >>= 1;
		y   <<= 1;
	}
	y += tmp&0x00000001;
	return y;
}

int Gen_GF2(u8 bits, unsigned int  *buf)
{
//  assign bch_GF_40becc = 560'hC07F_89B1_A0DC_5D96_619F_32D0_4967_54F6_DE9D_4F93_F527_EF14_EFB0_FD53_9915_A82C_CD92_5528_8030_477D_EE3F_338A_59EC_5FA2_10AF_E2EF_DFAE_D244_DF31_4DA5_0762_B724_A002_9CEF_2DC1;
//  assign bch_GF_24becc = 560'h8E94_E024_8D90_9D2B_4525_72D1_EDD9_D098_FE73_0E8E_8D26_C2D2_2893_A3A0_485B_D0AB_6E0B_4992_9A35_6BD4_30EF;
//  assign bch_GF_12becc = 560'hE48_7325_6115_A567_84A6_940A_4C6E_6D7E_1205_E051;
//  assign bch_GF_8becc = 560'h15_F914_E07B_0C13_8741_C5C4_FB23;
//  assign bch_GF_4becc = 560'h4_5230_43AB_86AB;
	unsigned int bch_GF_40becc[] = { 0xC07F, 0x89B1A0DC, 0x5D96619F, 0x32D04967, 0x54F6DE9D, 0x4F93F527, 0xEF14EFB0, 0xFD539915, 0xA82CCD92, 0x55288030, 0x477DEE3F, 0x338A59EC, 0x5FA210AF, 0xE2EFDFAE, 0xD244DF31, 0x4DA50762, 0xB724A002, 0x9CEF2DC1};
	unsigned int bch_GF_24becc[] = { 0x8E94, 0xE0248D90, 0x9D2B4525, 0x72D1EDD9, 0xD098FE73, 0x0E8E8D26, 0xC2D22893, 0xA3A0485B, 0xD0AB6E0B, 0x49929A35, 0x6BD430EF};
	unsigned int bch_GF_12becc[] = { 0xE487325, 0x6115A567, 0x84A6940A, 0x4C6E6D7E, 0x1205E051};
	unsigned int bch_GF_8becc[] = { 0x15, 0xF914E07B, 0x0C138741, 0xC5C4FB23};
	unsigned int bch_GF_4becc[] = { 0x45230, 0x43AB86AB};
	unsigned int *p;
	int i,len,width;

  switch (bits) {
		case 4  : width = 51;   p = bch_GF_4becc;              break;
		case 8  : width = 103;  p = bch_GF_8becc;              break;
		case 12 : width = 155;  p = bch_GF_12becc;             break;
		case 24 : width = 335;  p = bch_GF_24becc;             break;
		case 40 : width = 559;  p = bch_GF_40becc;             break;
		default : width = 51;   p = bch_GF_4becc;              break;
	}
	len = width/32 +1;
	for(i=0;i<len;i++)
		buf[i] = *(p+len-1-i);

	return (width);
}

unsigned int Caculat_1b_bch( unsigned int *pariA, unsigned int *bch_GF2, unsigned int din, u8 pari_len, u8 pari_lb)
{
	//din: bit31-1 should be 0, only bit0 is valid
	//pari_len: the index of last DW of the parity
	//pari_lb:  the MSB   of the last DW 
	u8 i;
	unsigned int  mask  = ~(0xffffffff <<(pari_lb+1));
	unsigned int  lstdw = mask & pariA[pari_len];
	unsigned int  ldwMSB  = lstdw >> pari_lb ;
	//  for(i=pari_len;i>=0;i--)  printk("%8x",pariA[i]);printk("\n---before\n");
	for(i=pari_len;i>0;i--)	{
		pariA[i]= (pariA[i]<<1) +(pariA[i-1]>>31);
		if(din ^ ldwMSB)  pariA[i] = pariA[i] ^ bch_GF2[i]; 
	}
	pariA[0]= (pariA[0]<<1);
	if(din ^ ldwMSB)  pariA[i] = pariA[i]^ bch_GF2[i]; 
	//  for(i=pari_len;i>=0;i--)  printk("%8x",pariA[i]);printk("\n---after\n");
	return (ldwMSB );
}

int bch_encoder(unsigned int *p_parity, unsigned int *p_data, u8 bits, unsigned int datacnt)
{
	int  i,j;
	int  bchGF_msb;
	u8   pari_len,pari_lb;
	unsigned int  bch_GF2[18];
	unsigned int  tmp;
	unsigned int  *p, *p1;
	u8   *p2;//, p3[50];

	bchGF_msb = Gen_GF2( bits, bch_GF2);
	pari_len   = (u8)(bchGF_msb /32);
	pari_lb    = (u8)(bchGF_msb %32);
	//p = (unsigned int *)malloc((pari_len+2) * sizeof(unsigned int));
	p = (unsigned int *)kmalloc((pari_len+2) * sizeof(unsigned int), GFP_KERNEL);
  if (p == NULL) {
		printk("malloc Error!");
		return -1;
	} else {
		/*gen parity[ bchGF_msb:0] begin*/  
 		//Init  
		for(i=pari_len+1;i>=0;i--)
			*(p+i) = 0;
 		//Caculate 
		p1 = &p[1];
		for (i=0;i<datacnt;i++) {
			tmp = p_data[i];
			for (j=0;j<32;j++) {
	   		Caculat_1b_bch( p1, bch_GF2, tmp&0x00000001, pari_len, pari_lb);
	   		tmp >>= 1;
			}
		}
		//printk("encode finiah!pari_len=%d p_parity=0x%x\n",pari_len, (unsigned int)p_parity);
		/*gen parity[ bchGF_msb:0] end*/  

		/*reverse oder of parity begin*/
		p2 = (u8 *)p;
		//printk("pari_lb=%d p2=0x%x\n", pari_lb, (unsigned int)p2);
		p1 = (unsigned int *)(p2+3-(pari_lb/8));
		/*p2 = (p2+3-(pari_lb/8));
		for(i=0;i<((pari_len+1)*4);i++)
			p3[i] = p2[i];
		p1 = p3;
		*/
		//printk("p2=0x%x p3=0x%x\n", (unsigned int)p2, (unsigned int)p3);
		for(i=0;i<=pari_len;i++) {
			p_parity[pari_len-i] = reverse32(p1[i]);
		}
		/*reverse oder of parity end*/
	//printk("reverse finiah!\n");
	  kfree(p);    //release malloc
  }
  //printk("leave encode\n");
	return 0;
}

#if 0 //slow encode function
int encode_ecc(unsigned char *src_data, unsigned char *parity, unsigned int ecc_bit, unsigned char *c_len, unsigned int encode_len)
{
	//unsigned char src_data[512];//24
	//unsigned char parity[26];//42
	//unsigned char ecc_bit;
	unsigned char c_len1 = *c_len;
	unsigned int fail;

	//char in_char;
	int i;
	//int j,in_v;



	//for (i=0; i<encode_len; i++) src_data[i] = 0x00;
	// for (i = 0; i < encode_len; i += 2) {
	//		src_data[i] = 0xFF&(jj>>8);
	//		src_data[i+1] = 0xFF&jj;
	//		jj++;
	//		jj %= 0x10000;
	//		src_data[i] = 0x12;
	//		src_data[i+1] = 0x12;
	//	}
/*
	i = 0; j = 0;
	in_char = getchar();
	while (in_char != EOF) {
		in_v = hextoint(in_char);
		if (in_v != -1)	{
			if (j==0)	{
				src_data[i] = 0;
				src_data[i] += in_v * 16;
				j++;
			}	else {
				src_data[i] += in_v;
				i++;
				j = 0;
			}
		}
		in_char = getchar();
	}*/
	//printk("start encode\n");
	fail = wmt_bchencoder(src_data,parity,ecc_bit,&c_len1, encode_len);
	if (fail) 
		printk("----------------Encode Error Detected! code=%d-----------------\n",fail);
	else
		*c_len = c_len1;
	/*printk("\nCodeLengh=%d %d Parity=",*c_len, c_len1);
		for (i=(c_len1-1); i>=0; i--)
			printk("%02x ",parity[i]);
	printk("\n");*/

	return 0;
}

int hextoint(char hex)
// Convert HEX number to Integer
{
	int r, h;
	r = -1;
	h = (int)hex;
	if ((h >= 97) && (h <= 102))
			r = h - 87;
	else if ((h >= 65) && (h <= 70))
			r = h - 55;
	else if ((h >= 48) && (h <= 57))
			r = h - 48;
	else if ((h != 10) && (h != 13))
			printk("Error detected!!! hex=%c",hex);
	return r;
}


// This function is used to encode the BCH code for the input data
// data :        [IN] The information data to be encoded by BCH. The lendth of this buffer is fixed at 512Bytes.
// bch_code :    [OUT] Buffer pointer to keep the BCH code.
// bits :        [IN] The number of bits for the BCH error correcting capability.
// bch_codelen : [IN/OUT] This parameter is used to specify the length of the buffer bch_code in unit of byte for input for the
//               encoder. And will specify the length of encoded bch for the data with error correcting capability bits as output.
// RETURN :      0 indicates success. Nonzero indicates failure.
unsigned int wmt_bchencoder (unsigned char *data, unsigned char *bch_code, unsigned char bits, unsigned char *bch_codelen, unsigned int encode_len)
{
	unsigned char bch_codelen_in;
	unsigned char bch_i;
	/*unsigned char b_data[MAX_BANK_SIZE*8];
	unsigned char bch_sera[MAX_PARITY_SIZE*8];
	unsigned char bch_sera_tmp[MAX_PARITY_SIZE*8];*/
	unsigned char bch_sera_back;
	unsigned int  width;
	unsigned int i,j,k;
	unsigned long retval;
	unsigned char offset;

	unsigned char *bch_GF2;
	/*unsigned char bch_GF_4becc[MAX_PARITY_SIZE*8] = {0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	unsigned char bch_GF_8becc[MAX_PARITY_SIZE*8] = {0,0,0,1,0,1,0,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,0,1,1,1,0,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	unsigned char bch_GF_12becc[MAX_PARITY_SIZE*8] = {1,1,1,0,0,1,0,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,0,0,1,0,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,0,0,1,0,1,0,0,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	unsigned char bch_GF_16becc[MAX_PARITY_SIZE*8] = {1,1,0,0,1,0,1,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,1,1,0,0,0,1,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	unsigned char bch_GF_24becc[MAX_PARITY_SIZE*8] = {1,0,0,0,1,1,1,0,1,0,0,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,0,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,1,0,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	unsigned char bch_GF_40becc[MAX_PARITY_SIZE*8] = {1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,0,1,0,1,0,1,0,0,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,1,1,1,0,0,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1};*/

	// initialization
	retval = 0;
	for(i=0; i<MAX_PARITY_SIZE*8; i++) {
		bch_sera[i] = 0;
		bch_sera_tmp[i] = 0;
	}

	for (i=0; i <=(encode_len*8); i++) {
	if ((unsigned char)((unsigned int)(1<<(i%8))) & data[i/8])
		b_data[i] = 1;
	else
		b_data[i] = 0;
	}

	// select width and poly-nominal
	switch (bits)	{
		case 4  : width = 51;   bch_GF2 = bch_GF_4becc;              break;
		case 8  : width = 103;  bch_GF2 = bch_GF_8becc;              break;
		case 12 : width = 155;  bch_GF2 = bch_GF_12becc;             break;
		case 16 : width = 207;  bch_GF2 = bch_GF_16becc;             break;
		case 24 : width = 335;  bch_GF2 = bch_GF_24becc;             break;
		case 40 : width = 559;  bch_GF2 = bch_GF_40becc;             break;
		default : width = 51;   bch_GF2 = bch_GF_4becc; retval += 1; break;
	}

	// calculate the parity
	for (k=0; k<(encode_len*8); k++) {
		bch_i = b_data[k];
		bch_sera_back = bch_sera[width] ^ bch_i;
		bch_sera_tmp[0] = bch_sera_back;
		for (i=0; i<width; i++)	{
			bch_sera_tmp[i+1] = bch_sera[i] ^ (bch_sera_back * bch_GF2[width-(i+1)]);
		}
		for (i=0; i<=width; i++)
			bch_sera[i] = bch_sera_tmp[i];
	}

	i = 0;
	bch_code[0] = 0;
	bch_codelen_in = *bch_codelen;
	if(bits == 4 || bits == 12)
		offset = 4;
	else
		offset = 0;
	for (j = 0; j <= width; j++) {
		*bch_codelen = i+1;
		bch_code[i] += bch_sera[j] * (unsigned char)((unsigned int)(1<<(7-((j+offset)%8))));
		if (i>=bch_codelen_in) {
			retval += 2;
			break;
		}
		if((j+offset)%8==7) {
			i++;
			bch_code[i] = 0;
		}
	}

	return(retval);
}
#endif //end of #if 0 : slow encode function

/**
 * wmt_nand_read_page - hardware ecc syndrom based page read
 * @mtd:	mtd info structure
 * @chip:	nand chip info structure
 * @buf:	buffer to store read data
 *
 * The hw generator calculates the error syndrome automatically. Therefor
 * we need a special oob layout and handling.
 */
static int wmt_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
						 uint8_t *buf, int page)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	#ifdef WMT_RDMZ
	unsigned int rdmz_mark = 0;
	#endif
	#ifdef NAND_DEBUG
		printk(KERN_NOTICE "\r enter in wmt_nand_read_page()page=0x%x\n", page);
	#endif
	info->datalen = 0;
	chip->read_buf(mtd, buf, mtd->writesize);
	#ifdef WMT_RDMZ
	if (mtd->dwRdmz == 1) {
		rdmzier_oob((uint8_t *)&rdmz_mark, (uint8_t *)(info->reg+ECC_FIFO_5), 1, page, (mtd->writesize+20)/4);
		if ((*(unsigned int *)(info->reg+ECC_FIFO_5)) == (*(unsigned int *)wmt_rdmz) ||
			rdmz_mark == (*(unsigned int *)wmt_rdmz)) {
			//printk("derdmz page= 0x%x\n", page);
			rdmzier(buf, mtd->writesize/4, page);
		}
	}
	#endif

	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "\r enter in nand_read_page(): mtd->writesize is %d and oobsize is %d\n",
	mtd->writesize, mtd->oobsize);
	#endif
	/* memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, mtd->oobsize);*/
	/* memset(chip->oob_poi, 0xff, mtd->oobsize);*/
	if (mtd->writesize == 2048) {
		/* writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);*/
		memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, mtd->oobsize);
	} else if (mtd->writesize == 4096 || mtd->writesize >= 8192) {
		/* dannier test 0x34 are used or not when not hamming mode*/
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);

		#ifdef WMT_RDMZ
		//printk("re page=0x%x rdmz_mark=0x%x wmt_rdmz=0x%x fifo5=0x%x\n",page , rdmz_mark, *(unsigned int *)wmt_rdmz, *(unsigned int *)(info->reg+ECC_FIFO_5));
		if (mtd->dwRdmz == 1 && rdmz_mark == *(unsigned int *)wmt_rdmz) {
			rdmzier_oob((uint8_t *)chip->oob_poi, (uint8_t *)(info->reg+ECC_FIFO_0), 5/*20/4*/, page, mtd->writesize/4);
		}	else
		#endif
			memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, 20);

	} else {  /* pagesize = 512 */
		/* only reduntant area read enable */
		memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, mtd->oobsize);
		#ifndef PAGE_READ_COUNTER
			writeb(readb(info->reg + WMT_NFC_SMC_ENABLE) & 0xfd,
			info->reg + WMT_NFC_SMC_ENABLE);
		#endif
		/* memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, mtd->oobsize);*/
	}

	#if 0
	/* for debug  */
	int i;
	/* printk(KERN_NOTICE "data aera is -------------------------\n");*/
	/* for (i = 0; i < mtd->writesize; i += 4) {*/
	/* printk(KERN_NOTICE "%x %x %x %x\n",
	info->dmabuf[i], info->dmabuf[i+1], info->dmabuf[i+2], info->dmabuf[i+3]);*/
	/* }*/
	printk(KERN_NOTICE "spare aera is -------------------------\n");
	for (i = 0; i < mtd->oobsize; i += 4)
		printk(KERN_NOTICE "%x %x %x %x\n",
		chip->oob_poi[i], chip->oob_poi[i+1], chip->oob_poi[i+2], chip->oob_poi[i+3]);
	#endif

 /*   memcpy(chip->oob_poi, info->reg+ECC_FIFO_0, mtd->oobavail);*/
 /*   chip->read_buf(mtd, chip->oob_poi, mtd->oobavail); */  /* ????  */
	return 0;
}
//extern unsigned int wmt_read_oscr(void);
/**
 *  wmt_nand_write_page_lowlevel - hardware ecc syndrom based page write
 *  @mtd:    mtd info structure
 *  @chip:  nand chip info structure
 *  @buf:  data buffer
 *
 *  The hw generator calculates the error syndrome automatically. Therefor
 *  we need a special oob layout and handling.
 *
 */
static void wmt_nand_write_page_lowlevel(struct mtd_info *mtd, struct nand_chip *chip, const uint8_t *buf)
{
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	struct ECC_size_info ECC_size;
	unsigned char ecc_bit = 24/*40*/, c_len = 42;//70
	unsigned char *FIFO6 = (unsigned char *)(info->reg + ECC_FIFO_6);
	unsigned char *FIFO0 = (unsigned char *)(info->reg + ECC_FIFO_0);
	int status;
	//unsigned int now_time = 0, delay_time = 0;
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_page_write_lowlevel() writesize %x\n", mtd->writesize);
	#endif
	unsigned int b2r_stat, data_len = 24, i;
	info->dma_finish = 0;
	b2r_stat = readb(info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(B2R|b2r_stat, info->reg + WMT_NFC_HOST_STAT_CHANGE);
	writeb(0x07, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
	info->datalen = 0;
	chip->write_buf(mtd, buf, mtd->writesize);
	wmt_nfc_dma_cfg(mtd, mtd->writesize, 1, 0, -1);  /*  2048bytes  */

	/* for debug  */
	#if 0
	int i;
	/* printk(KERN_NOTICE "data aera is -------------------------\n");*/
	/* for (i = 0; i < mtd->writesize; i += 4) {*/
	/* printk(KERN_NOTICE "%x %x %x %x\n",
	info->dmabuf[i], info->dmabuf[i+1], info->dmabuf[i+2], info->dmabuf[i+3]);*/
	/* info->dmabuf[i] = 0;*/
	/* info->dmabuf[i+1] = 0;*/
	/* info->dmabuf[i+2] = 0;*/
	/* info->dmabuf[i+3] = 0;*/
	/*  }*/
	printk(KERN_NOTICE "spare aera is -------------------------\n");
	for (i = 0; i < mtd->oobsize; i += 4)
		printk(KERN_NOTICE "%x %x %x %x\n",
		chip->oob_poi[i], chip->oob_poi[i+1], chip->oob_poi[i+2], chip->oob_poi[i+3]);
	#endif

	ECC_size.ecc_engine = info->ECC_mode;
	calculate_ECC_info(mtd, &ECC_size);
	ecc_bit = ECC_size.oob_max_bit_error;
	c_len = ECC_size.oob_ECC_bytes;
	#ifdef WMT_RDMZ
	if (mtd->dwRdmz == 1)
		*(unsigned int *)(chip->oob_poi+20) = *(unsigned int *)wmt_rdmz;
	#endif
	if (mtd->writesize == 2048) {
		/* writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7, info->reg + WMT_NFC_CALC_CTRL);*/
		memcpy(info->reg+ECC_FIFO_0, chip->oob_poi, 20);
		//status = encode_ecc((unsigned char *)chip->oob_poi, parity, ecc_bit, &c_len, data_len);
		bch_encoder((unsigned int *)parity, (unsigned int *)chip->oob_poi, ecc_bit, data_len/4);
		for (i = 0; i < c_len; i++) {
			if (i >= 40) {
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | 0x08,
				info->reg + WMT_NFC_CALC_CTRL);
				FIFO0[i-40] = parity[i];//parity[c_len-i-1];
			} else
				FIFO6[i] = parity[i];//parity[c_len-i-1];
		}
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);

	} else if (mtd->writesize == 4096 || mtd->writesize >= 8192) {
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);
		//now_time = wmt_read_oscr();
		//memcpy(info->reg+ECC_FIFO_0, chip->oob_poi, 20);
		#ifdef WMT_RDMZ
		if (mtd->dwRdmz == 1) {
			rdmzier_oob((uint8_t *)(info->reg+ECC_FIFO_0), (uint8_t *)chip->oob_poi, 6/*20/4*/, info->cur_page, mtd->writesize/4);
		} else
		#endif
			memcpy(info->reg+ECC_FIFO_0, chip->oob_poi, 20);
		//delay_time = wmt_read_oscr() - now_time;
		//printk(KERN_NOTICE"wr oob_poi=0x%x fifo5=0x%x \n", *(unsigned int *)(chip->oob_poi+20), *(unsigned int *)(info->reg+ECC_FIFO_5));
		//printk(KERN_NOTICE"wr page=0x%x copy oob time =%d us/3\n", info->cur_page, delay_time);
		//now_time = wmt_read_oscr();
		//status = encode_ecc((unsigned char *)chip->oob_poi, parity, ecc_bit, &c_len, data_len);
		status = bch_encoder((unsigned int *)parity, (unsigned int *)chip->oob_poi, ecc_bit, data_len/4);
		//delay_time = wmt_read_oscr() - now_time;
		//printk(KERN_NOTICE"encode_t =%d \n", delay_time/3);
		for (i = 0; i < c_len; i++) {
			if (i >= 40) {
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | 0x08,
				info->reg + WMT_NFC_CALC_CTRL);
				FIFO0[i-40] = parity[i];//parity[c_len-i-1];
			} else
				FIFO6[i] = parity[i];//parity[c_len-i-1];
		}
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);

	} else {
		memcpy(info->reg+ECC_FIFO_0, chip->oob_poi, 20);
		//status = encode_ecc((unsigned char *)chip->oob_poi, parity, ecc_bit, &c_len, data_len);
		bch_encoder((unsigned int *)parity, (unsigned int *)chip->oob_poi, ecc_bit, data_len/4);
		for (i = 0; i < c_len; i++) {
			if (i >= 40) {
				writeb(readb(info->reg + WMT_NFC_CALC_CTRL) | 0x08,
				info->reg + WMT_NFC_CALC_CTRL);
				FIFO0[i-40] = parity[i];//parity[c_len-i-1];
			} else
				FIFO6[i] = parity[i];//parity[c_len-i-1];
		}
		writeb(readb(info->reg + WMT_NFC_CALC_CTRL) & 0xF7,
		info->reg + WMT_NFC_CALC_CTRL);
	}
	/* memcpy(info->reg+ECC_FIFO_0, chip->oob_poi, mtd->oobavail);*/
	/* chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);*/
}


static int wmt_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
const uint8_t *buf, int page, int cached, int raw)
{
	int status, set_eslc = 0;
	uint8_t *tmp_buf = (uint8_t *)buf;
	struct wmt_nand_info *info = wmt_nand_mtd_toinfo(mtd);
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "enter in wmt_nand_write_page()\n");
	printk(KERN_NOTICE "raw = %d\n", raw);
	#endif
	
	if (chip->cur_chip && (chip->cur_chip->nand_id>>24) == NAND_MFR_HYNIX /*&& mtd->dwRetry*/) {
		if (page >= ((mtd->blkcnt-8)*mtd->pagecnt) /*&& ((mtd->blkcnt-4)*mtd->pagecnt)*/) {
			set_eslc = 1;
			printk(KERN_NOTICE "dannier set eslc mode before write page=0x%x\n", page);
			chip->cur_chip->set_parameter(mtd, ESLC_MODE, ECC_ERROR_VALUE);
		}
	}
	
	info->cur_page = page;
	#ifdef WMT_RDMZ
	if (mtd->dwRdmz == 1) {
		tmp_buf = buf_rdmz;
		memcpy(tmp_buf, buf, mtd->writesize);
		rdmzier(tmp_buf, mtd->writesize/4, page);
	}
	#endif
	info->datalen = 0;
	chip->ecc.write_page(mtd, chip, tmp_buf);
		/*   }*/
	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
	status = nand_pdma_handler(mtd);
	nand_free_pdma(mtd);
	if (status)
		printk(KERN_ERR "check write pdma handler status= %x \n", status);

	/*
	 * *   * Cached progamming disabled for now, Not sure if its worth the
	 * *       * trouble. The speed gain is not very impressive. (2.3->2.6Mib/s)
	 * *           */
	cached = 0;

	if (!cached || !(chip->options & NAND_CACHEPRG)) {

		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
		status = chip->waitfunc(mtd, chip);
		writeb(0x80, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		/*
		* * See if operation failed and additional status checks are
		* * available
		* *      */
		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
			status = chip->errstat(mtd, chip, FL_WRITING, status,	page);

		if (status & NAND_STATUS_FAIL)
			goto GO_EIO;//return -EIO;
	} else {
		chip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);
		status = chip->waitfunc(mtd, chip);
	}


	#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
	/* Send command to read back the data */
	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);

	if (chip->verify_buf(mtd, buf, mtd->writesize))
		goto GO_EIO;//return -EIO;
	#endif
	if (set_eslc == 1)
		chip->cur_chip->set_parameter(mtd, ESLC_MODE, DEFAULT_VALUE);
	return 0;

GO_EIO:
	if (set_eslc == 1)
		chip->cur_chip->set_parameter(mtd, ESLC_MODE, DEFAULT_VALUE);
	return -EIO;
}


/* wmt_nand_init_chip
 *
 * init a single instance of an chip
 */

static void wmt_nand_init_chip(struct wmt_nand_info *info, struct wmt_nand_mtd *nmtd,
struct ECC_size_info *ECC_size)
{
	struct nand_chip *chip = &nmtd->chip;
	struct mtd_info *mtd = &nmtd->mtd;

	#if 0
	chip->cmdfunc      = wmt_nand_cmdfunc;
	chip->dev_ready    = wmt_device_ready;
	chip->read_byte    = wmt_read_byte;
	chip->write_buf    = wmt_nand_write_buf;
	chip->read_buf     = wmt_nand_read_buf;
	chip->select_chip  = wmt_nand_select_chip;
	chip->chip_delay   = 20;
	chip->priv	   = nmtd;
	chip->options	   = 0;
	chip->controller   = &info->controller;
	#endif

	/* chip->cmd_ctrl  = wmt_nand_hwcontrol;*/
	#if 0
	switch (info->cpu_type) {
	case TYPE_wmt:
		break;

	case TYPE_vt8620:
		break;

	case TYPE_vt8610:
		break;
	}
	#endif

	/* nmtd->set	   = set;*/
	if (hardware_ecc) {
		/*	chip->ecc.calculate = wmt_nand_calculate_ecc;*/
		/*	chip->ecc.correct   = wmt_nand_correct_data;*/

		if (mtd->writesize == 2048) {
			chip->ecc.size      = 512;
			chip->ecc.bytes     = 8;
			chip->ecc.steps     = 4;
			/*chip->ecc.layout    = &wmt_oobinfo_2048;*/
			chip->ecc.prepad    = 1;
			chip->ecc.postpad   = 8;
		} else if (mtd->writesize == 4096) {
			chip->ecc.size      = 512;
			if (ECC8BIT_ENGINE == 1)
				chip->ecc.bytes     = 20;
			//chip->ecc.bytes     = 16;
			else
			chip->ecc.bytes     = 8;

			chip->ecc.steps     = 8;
			/*chip->ecc.layout    = &wmt_oobinfo_4096;*/
			chip->ecc.prepad    = 1;
			chip->ecc.postpad   = 8;
		} else if (mtd->writesize == 8192) {
			chip->ecc.size      = 1024;
			chip->ecc.bytes     = 42;
			chip->ecc.steps     = 8;
			/*chip->ecc.layout    = &wmt_oobinfo_8192;*/
			chip->ecc.prepad    = 1;
			chip->ecc.postpad   = 8;
		} else if (mtd->writesize == 16384) {
			chip->ecc.size      = 1024;
			chip->ecc.bytes     = 70;
			chip->ecc.steps     = 16;
			/*chip->ecc.layout    = &wmt_oobinfo_16k;*/
			chip->ecc.prepad    = 1;
			chip->ecc.postpad   = 8;
		} else {   /*  512 page   */
			chip->ecc.size      = 512;
			chip->ecc.bytes      = 3;
			chip->ecc.steps     = 1;
			/*chip->ecc.layout    = &wmt_oobinfo_512;*/
			chip->ecc.prepad    = 4;
			chip->ecc.postpad   = 9;
		}
		if (mtd->writesize != 512) {
			chip->ecc.size      = (mtd->writesize/ECC_size->banks);
			chip->ecc.bytes     = ECC_size->ECC_bytes;
			chip->ecc.steps     = ECC_size->banks;
		}

		chip->write_page = wmt_nand_write_page;
		chip->ecc.write_page = wmt_nand_write_page_lowlevel;
		chip->ecc.write_oob = wmt_nand_write_oob;
		chip->ecc.read_page = wmt_nand_read_page;
		chip->ecc.read_oob = wmt_nand_read_oob;

		chip->ecc.read_bb_oob = wmt_nand_read_bb_oob;

		/*	switch (info->cpu_type) {*/
		/*	case TYPE_wmt:*/
		chip->ecc.hwctl	    = wmt_nand_enable_hwecc;
		/*	chip->ecc.calculate = wmt_nand_calculate_ecc;*/
		/*	break;*/
	#if 0
	case TYPE_vt8620:
		chip->ecc.hwctl     = vt8620_nand_enable_hwecc;
		chip->ecc.calculate = vt86203_nand_calculate_ecc;
		break;

	case TYPE_vt8610:
		chip->ecc.hwctl     = vt8610_nand_enable_hwecc;
		chip->ecc.calculate = vt8610_nand_calculate_ecc;
		break;
		}
	#endif
	} else
		chip->ecc.mode	    = NAND_ECC_SOFT;
}


static int wmt_nand_remove(struct platform_device *pdev)
{
	struct wmt_nand_info *info = dev_get_drvdata(&pdev->dev);

	/*  struct mtd_info *mtd = dev_get_drvdata(pdev);*/
	dev_set_drvdata(&pdev->dev, NULL);
	/*  platform_set_drvdata(pdev, NULL);*/
	/*  dev_set_drvdata(pdev, NULL);*/
	if (info == NULL)
		return 0;

	/* first thing we need to do is release all our mtds
	 * and their partitions, then go through freeing the
	 * resources used
	 */

	if (info->mtds != NULL) {
		struct wmt_nand_mtd *ptr = info->mtds;
	/* int mtdno;*/

	/* for (mtdno = 0; mtdno < info->mtd_count; mtdno++, ptr++) {*/
	/*     pr_debug("releasing mtd %d (%p)\n", mtdno, ptr);*/
		nand_release(&ptr->mtd);
	/*  }*/
		kfree(info->mtds);
	}

	/* free the common resources */

	if (info->reg != NULL) {
		//iounmap(info->reg);
		info->reg = NULL;
	}

	if (info->area != NULL) {
		release_resource(info->area);
		kfree(info->area);
		info->area = NULL;
	}
	kfree(info);
	if (buf_rdmz)
		vfree(buf_rdmz);
	return 0;
}

#ifdef CONFIG_MTD_CMDLINE_PARTS

extern int mtdpart_setup(char *);

static int __init add_dynamic_parts(struct mtd_info *mtd)
{
	static const char *part_parsers[] = { "cmdlinepart", NULL };
	struct mtd_partition *parts;
	/*const struct omap_flash_part_config *cfg;
	char *part_str = NULL;
	size_t part_str_len;*/
	int c;

	/*cfg = omap_get_var_config(OMAP_TAG_FLASH_PART, &part_str_len);
	if (cfg != NULL) {
		part_str = kmalloc(part_str_len + 1, GFP_KERNEL);
		if (part_str == NULL)
			return -ENOMEM;
		memcpy(part_str, cfg->part_table, part_str_len);
		part_str[part_str_len] = '\0';
		mtdpart_setup(part_str);
	}*/
	c = parse_mtd_partitions(mtd, part_parsers, &parts, 0);
	/*if (part_str != NULL) {
		mtdpart_setup(NULL);
		kfree(part_str);
	}*/
	if (c <= 0)
		return -1;

 	mtd_device_register(mtd, parts, c);
	//add_mtd_partitions(mtd, parts, c);

	return 0;
}

#else

static inline int add_dynamic_parts(struct mtd_info *mtd)
{
	return -1;
}

#endif

int search_mtd_table(char *string, char *ret)
{
	int i, err = 0;
	for (i = 0; i < MAX_MTD_DEVICES; i++) {
		if (!&nand_partitions[i]) {
			err = 1;
			break;
		}
		printk(KERN_DEBUG "MTD dev%d size: %8.8llx \"%s\"\n",
		i, nand_partitions[i].size, nand_partitions[i].name);
		if (strcmp(string, nand_partitions[i].name) == 0) {
			*ret = i;
			break;
		}
	}
	return err;
}
	
/*Lch */
static int wmt_recovery_call(struct notifier_block *nb, unsigned long code, void *_cmd)
{
	/*struct mtd_info *mtd;
	int err = 0, ret = 0;
	char ret1 = 0;*/
	printk(KERN_EMERG "Lch enter wmt_recovery_call.\n");
#if 0
	mtd = container_of(nb, struct mtd_info, reboot_notifier);

	if((code == SYS_RESTART) && _cmd) {
		char *cmd = _cmd;
		if  (!strcmp(cmd, "recovery")) {
			err = search_mtd_table("android-data", &ret1);
			ret = (int)ret1;
			if (!err) {
			//	printk(KERN_EMERG "Lch jump2 android-data wmt_recovery_call.ret =%d\n",ret);
				struct erase_info einfo;
				loff_t to;
				memset(&einfo, 0, sizeof(einfo));
				to = nand_partitions[ret].offset;
				einfo.mtd = mtd;
				einfo.addr = (unsigned long)to;
				einfo.len = nand_partitions[ret].size;

			//	printk("android-data einfo.addr is %8.8x\n",einfo.addr);
			//	printk("android-data einfo.len is %8.8x\n",einfo.len);
			//	printk("android-data nand_partitions[%d].offset is %8.8x\n",ret,nand_partitions[ret].offset);
			//	printk("android-data nand_partitions[%d].size is %8.8x\n",ret,nand_partitions[ret].size);
				ret = nand_erase_nand(mtd, &einfo, 0xFF);
				if (ret < 0)
					printk("enand_erase_nand result is %x\n",ret);
			}

			err = search_mtd_table("android-cache", &ret1);
			ret = (int)ret1;
			if (!err) {
			//	printk(KERN_EMERG "Lch jump3 wmt_recovery_call.android-cache ret=%d\n",ret);
				struct erase_info einfo;
				loff_t to;
				memset(&einfo, 0, sizeof(einfo));
				to = nand_partitions[ret].offset;
				einfo.mtd = mtd;
				einfo.addr = (unsigned long)to;
				einfo.len = nand_partitions[ret].size;

			//	printk("android-cache einfo.addr is %8.8x\n",einfo.addr);
			//	printk("android-cache einfo.len is %8.8x\n",einfo.len);
			//	printk("android-data nand_partitions[%d].offset is %8.8x\n",ret,nand_partitions[ret].offset);
			//	printk("android-data nand_partitions[%d].size is %8.8x\n",ret,nand_partitions[ret].size);
				ret = nand_erase_nand(mtd, &einfo, 0xFF);
				if (ret < 0)
					printk("enand_erase_nand result is %x\n",ret);
			}
		}
	}
#endif
	return NOTIFY_DONE;
}

/**********************************************************************
Name  	 : nfc_pdma_isr
Function    :.
Calls		:
Called by	:
Parameter :
Author 	 : Dannier Chen
History	:
***********************************************************************/
static irqreturn_t nfc_pdma_isr(int irq, void *dev_id)
{
	struct wmt_nand_info *info = (struct wmt_nand_info *)dev_id;
	disable_irq_nosync(irq);
	//spin_lock(&host->lock);
	writel(0, info->reg + NFC_DMA_IER);
	//writel(/*readl(info->reg + NFC_DMA_ISR)&*/NAND_PDMA_IER_INT_STS, info->reg + NFC_DMA_ISR);
	//printk(" pdmaisr finish NFC_DMA_ISR=0x%x\n", readl(info->reg + NFC_DMA_ISR));
	//print_nand_register(info);
	info->dma_finish = 1;
	WARN_ON(info->done_data == NULL);
	complete(info->done_data);
	info->done_data = NULL;
	//info->done = NULL;
	//spin_unlock(&host->lock);
	enable_irq(irq);

	return IRQ_HANDLED;
}

/**********************************************************************
Name  	 : nfc_regular_isr
Function    :.
Calls		:
Called by	:
Parameter :
Author 	 : Dannier Chen
History	:
***********************************************************************/
//static irqreturn_t nfc_regular_isr(int irq, void *dev_id, struct pt_regs *regs)
irqreturn_t nfc_regular_isr(int irq, void *dev_id)
{

	struct wmt_nand_info *info = dev_id;
	struct mtd_info	*mtd = &info->mtds->mtd;
	unsigned int bank_stat1, bank_stat2=0,status = 0;

	disable_irq_nosync(irq);
	//spin_lock(&host->lock);
	//printk("isrCMD=0x%x\n", info->isr_cmd);
	//status = (readb(info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK)&0xFF);
	if (info->isr_cmd != 0 /*&& status*/) {
		/* only erase/write/read_oob operation enable B2R interrupt */
		//printk("isrCMD=0x%x\n", info->isr_cmd);
		status = (readb(info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK)&0xFF);
		if (status != 0x7) {
			printk("error: isr is not check busy interrup =0x%x\n", status);
			dump_stack();
			//while(info->isr_cmd);
		}
		writeb(0x0F, info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK);
		if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R) {
			writeb(B2R, info->reg + WMT_NFC_HOST_STAT_CHANGE);
			if (readb(info->reg + WMT_NFC_HOST_STAT_CHANGE) & B2R)
				printk("[nfc_isr] B2R staus can't clear\n");
			/*if (info->isr_cmd == 0x50)
				printk("50 isr B2R info->cur_page=0x%x\n",info->cur_page);*/
			//goto isr_complete;
			WARN_ON(info->done_data == NULL);
			complete(info->done_data);
			info->done_data = NULL;
		}
	}
	if (info->isr_cmd == 0 || info->isr_cmd == 0x50) {
		bank_stat1 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
		if (bank_stat1&(ERR_CORRECT | BCH_ERR)) {
			while (bank_stat1 != (ERR_CORRECT | BCH_ERR)) {
				//printk("1ECC status = 0x%x\n", bank_stat1);
				bank_stat2++;
				bank_stat1 = readw(info->reg + WMT_NFC_ECC_BCH_INT_STAT1);
				//printk("2ECC status = 0x%x\n", bank_stat2);
				if (bank_stat2 >= 0x10000)
					break;
			}
			//printk("dma isrCMD=0x%x\n", info->isr_cmd);
			//printk("isrRe ecc err count = 0x%x\n", bank_stat2);
			if ((bank_stat1 & (ERR_CORRECT | BCH_ERR)) == (ERR_CORRECT | BCH_ERR)) {
				bank_stat2 = readw(info->reg + WMT_NFC_ECC_BCH_CTRL);
				/* 0: data, 1: reduntant area */
				//data_redunt_flag = bank_stat2 & 0x10;
				#ifdef NAND_DEBUG
				printk(KERN_NOTICE" BCH Read data ecc eror page_addr:%x cmd=%d\n", info->cur_page, info->isr_cmd);
				#endif
				if (bank_stat2 & BANK_DR) {
					/*status = (readb(info->reg + WMT_NFC_REDUNT_ECC_STAT_MASK)&0xFF);
					printk("status=0x%x \n", status);
					print_nand_register(mtd);*/
					bch_redunt_ecc_correct(mtd);
				} else {
					bch_data_ecc_correct(mtd);
				}
			} else
				printk("eccErr hw corr status not set bank_stat1=0x%x\n", bank_stat1);
		} /*else {
			printk("regular NOT isrWr busy\n");
		}*/
	}
	//spin_unlock(&host->lock);
	enable_irq(irq);

	return IRQ_HANDLED;
}

static int wmt_nand_probe(struct platform_device *pdev)
{
	/* struct wmt_platform_nand *plat = to_nand_plat(pdev);*/
	/*struct device *dev = &pdev->dev;*/
	struct wmt_nand_info *info;
	struct wmt_nand_mtd *nmtd;
	struct mtd_info *mtd;
	/*	struct wmt_nand_set *sets; */ /*  extend more chips and partitions structure*/
	struct resource *res;
	unsigned int varlen, ecc_bit_mode;
	struct ECC_size_info ECC_size, *ECC_size_pt;
	char ret1;
	int err = 0, ret = 0, status = 0;
	unsigned char varval[100], tmp[100];
	int size;
	buf_rdmz =  NULL;
	/*	int nr_sets;*/
	/*	int setno;*/
	/*err = -EINVAL;
	return err;*/
	*(volatile unsigned int *)(GPIO_BASE_ADDR + 0x200) &= ~(1<<1); /*PIN_SHARE_SDMMC1_NAND*/
	wmt_version = *(unsigned int *)(SYSTEM_CFG_CTRL_BASE_ADDR);
	/*	printk(KERN_NOTICE "CHIP version is %x\n", wmt_version);*/
	if (wmt_version == 0x34000101)
		return -1;  /* A0 chip not support nand flash */
	/*end wmt_revision: VT3400 A1 and Later...  */

	pr_debug("wmt_nand_probe(%p)\n", pdev);

	info = kmalloc(sizeof(*info), GFP_KERNEL);
	if (info == NULL) {
		dev_err(&pdev->dev, "no memory for flash info\n");
		err = -ENOMEM;
		goto exit_error;
	}

	memzero(info, sizeof(*info));
	dev_set_drvdata(&pdev->dev, info);
	platform_get_resource(pdev, IORESOURCE_MEM, 0);
	
	ret = request_irq(IRQ_NFC,
					nfc_regular_isr,
					IRQF_SHARED,			//SA_SHIRQ, /*SA_INTERRUPT, * that is okay?*/	//zhf: modified by James Tian, should be IRQF_SHARED?
					"NFC",
					(void *)info);
	if (ret) {
		printk(KERN_ALERT "[NFC driver] Failed to register regular ISR!\n");
		goto unmap;
	}

	ret = request_irq(IRQ_NFC_DMA,
					nfc_pdma_isr,
					IRQF_DISABLED,	//	SA_INTERRUPT,  //zhf: modified by James Tian
					"NFC",
					(void *)info);
	if (ret) {
		printk(KERN_ALERT "[NFC driver] Failed to register DMA ISR!\n");
		goto fr_regular_isr;
	}
	spin_lock_init(&info->controller.lock);
	init_waitqueue_head(&info->controller.wq);

	/* allocate and map the resource */

	/* currently we assume we have the one resource */
	res  = pdev->resource;
	size = res->end - res->start + 1;

	info->area = request_mem_region(res->start, size, pdev->name);

	if (info->area == NULL) {
		dev_err(&pdev->dev, "cannot reserve register region\n");
		err = -ENOENT;
		goto exit_error;
	}

	info->device     = &pdev->dev;
	/*	info->platform   = plat;*/
	info->reg = (void __iomem *)NF_CTRL_CFG_BASE_ADDR;/*ioremap(res->start, size);*/
	/*	info->cpu_type   = cpu_type;*/

	if (info->reg == NULL) {
		dev_err(&pdev->dev, "cannot reserve register region\n");
		err = -EIO;
		goto exit_error;
	}

/*
 * * extend more partitions
 *
	err = wmt_nand_inithw(info, pdev);
		if (err != 0)
		goto exit_error;

	sets = (plat != NULL) ? plat->sets : NULL;
	nr_sets = (plat != NULL) ? plat->nr_sets : 1;

	info->mtd_count = nr_sets;
*/
	/* allocate our information */

/*	size = nr_sets * sizeof(*info->mtds);*/
	size = sizeof(*info->mtds);
	info->mtds = kmalloc(size, GFP_KERNEL);
	if (info->mtds == NULL) {
		dev_err(&pdev->dev, "failed to allocate mtd storage\n");
		err = -ENOMEM;
		goto exit_error;
	}

	memzero(info->mtds, size);

	/* initialise all possible chips */

	nmtd = info->mtds;

	/* initialise the hardware */
	/*wmt_nfc_init(info, &nmtd->mtd);*/
	nfc_ecc_set(info, 1);  /* on hw ecc */
	
	mtd = &nmtd->mtd;
	info->dmabuf = dma_alloc_coherent(&pdev->dev, 17664 + 0x300, &info->dmaaddr, GFP_KERNEL);
	
	if (!info->dmabuf && (info->dmaaddr & 0x0f)) {
		err = -ENOMEM;
		goto out_free_dma;
	}
	/*	nmtd->chip.buffers = (void *)info->dmabuf + 2112;*/

	nmtd->chip.cmdfunc      = wmt_nand_cmdfunc;
	nmtd->chip.dev_ready    = wmt_device_ready;
	nmtd->chip.read_byte    = wmt_read_byte;
	nmtd->chip.write_buf    = wmt_nand_write_buf;
	nmtd->chip.read_buf     = wmt_nand_read_buf;
	nmtd->chip.select_chip  = wmt_nand_select_chip;
	nmtd->chip.get_para     = nand_get_para;
	nmtd->chip.chip_delay   = 20;
	nmtd->chip.priv	   = nmtd;
	nmtd->chip.options	   = NAND_BBT_LASTBLOCK | NAND_USE_FLASH_BBT | NAND_BBT_PERCHIP;
	/*	nmtd->chip.options	   = 0;*/
	/*	nmtd->chip.controller   = &info->controller;*/

	/*nmtd->chip.ecc.steps     = 1;
		nmtd->chip.ecc.prepad    = 1;
		nmtd->chip.ecc.postpad   = 8;*/

	nmtd->chip.ecc.mode	    = NAND_ECC_HW;
	/*nmtd->chip.ecc.mode	    = 0;*/


	/*	for (setno = 0; setno < nr_sets; setno++, nmtd++)*/
	#ifdef NAND_DEBUG
	printk(KERN_NOTICE "initialising (%p, info %p)\n", nmtd, info);
	#endif
	/*	wmt_nand_init_chip(info, nmtd, sets);*/

	/* Set up DMA address */
	/*writel(info->dmaaddr & 0xffffffff, info->reg + NFC_DMA_DAR);*/

	/*info->dmabuf = readl(info->reg + WMT_NFC_DMA_TRANS_CONFIG);*/

	/* nmtd->nand.chip_delay = 0;*/

	/* Enable the following for a flash based bad block table */
	/*	nmtd->nand.options = NAND_USE_FLASH_BBT | NAND_NO_AUTOINCR | NAND_OWN_BUFFERS;*/

	#if 1
	if (mtd->writesize == 512) {
		printk(KERN_NOTICE "wmt_oobinfo_512 \n");
		nmtd->chip.ecc.layout = &wmt_oobinfo_512;
		nmtd->chip.bbt_td = &wmt_bbt_main_descr_512;
		nmtd->chip.bbt_md = &wmt_bbt_mirror_descr_512;
	} else { /*if (NAND_PAGE_SIZE == 4096 or 2048)*/
		nmtd->chip.bbt_td = &wmt_bbt_main_descr_2048;
		nmtd->chip.bbt_md = &wmt_bbt_mirror_descr_2048;
		nmtd->chip.retry_pattern = &wmt_rdtry_descr;
	}
	#endif

	nmtd->chip.cur_chip = NULL;

	/*nmtd->scan_res = nand_scan(&nmtd->mtd, (sets) ? sets->nr_chips : 1);*/

	nmtd->info	   = info;
	nmtd->mtd.priv	   = &nmtd->chip;
	nmtd->mtd.owner    = THIS_MODULE;
	nmtd->mtd.reboot_notifier.notifier_call = wmt_recovery_call;//Lch

	set_ecc_engine(info, 1);
	
	info->datalen = 0;
	ret1 = wmt_nfc_init(info, &nmtd->mtd);
	if (ret1 == 2)
		goto out_free_dma;
	writeb(0xff, info->reg + WMT_NFC_CHIP_ENABLE_CTRL); //chip disable 
	
	ecc_bit_mode = mtd->dwECCBitNum;
	if (ecc_bit_mode > 24)
		ecc_bit_mode = (ecc_bit_mode == 40) ? 6 : (-1);
	else
		ecc_bit_mode = (ecc_bit_mode > 16) ? ((ecc_bit_mode/4) - 1) : (ecc_bit_mode/4);
	info->ECC_mode = ECC_size.ecc_engine = ecc_bit_mode;
	calculate_ECC_info(mtd, &ECC_size);
	writew((ECC_size.oob_ECC_bytes<<8)/*+ ECC_size.unprotect;*/, info->reg + WMT_NFC_REMAINDER);
	info->oob_ECC_bytes = ECC_size.oob_ECC_bytes;
	info->last_bank_dmaaddr = info->dmaaddr + mtd->writesize - ECC_size.bank_size;
	info->oob_col = mtd->writesize + (ECC_size.ECC_bytes * (ECC_size.banks-1));
	info->last_bank_col = info->oob_col - ECC_size.bank_size;
	info->oob_ECC_mode = ECC_size.oob_ECC_mode;
	info->oob_ecc_error = 0;
	printk(KERN_NOTICE "last_bank_dmaaddr=0x%x\n", info->last_bank_dmaaddr);
	printk(KERN_NOTICE "oob_col=%d\n", info->oob_col);
	printk(KERN_NOTICE "last_bank_col=%d\n", info->last_bank_col);
	ECC_size_pt = &ECC_size;
	wmt_nand_init_chip(info, nmtd, ECC_size_pt);
	/*rc = set_ECC_mode(mtd);
	if (rc)
		goto out_free_dma;*/
	if (mtd->dwRdmz == 1) {
		buf_rdmz = vmalloc(mtd->writesize);
		if (!buf_rdmz) {
			printk("buf_rdmz alloc fail");
			goto out_free_dma;
		}
	}

	printk(KERN_NOTICE "BCH ECC %d BIT mode\n", mtd->dwECCBitNum);
	set_ecc_engine(info, ecc_bit_mode);  /* BCH ECC new structure */
	

	if (mtd->writesize == 2048) {
		nmtd->chip.ecc.layout = &wmt_oobinfo_2048;
	} else if (mtd->writesize == 4096) {
		if (mtd->dwECCBitNum == 12)
			nmtd->chip.ecc.layout = &wmt_12bit_oobinfo_4096;
		else
			nmtd->chip.ecc.layout = &wmt_oobinfo_4096;
	} else if (mtd->writesize == 8192) {
		nmtd->chip.ecc.layout = &wmt_oobinfo_8192;
	} else if (mtd->writesize == 16384) {
		nmtd->chip.ecc.layout = &wmt_oobinfo_16k;
	} else {
		nmtd->chip.ecc.layout = &wmt_oobinfo_512;
		nmtd->chip.bbt_td = &wmt_bbt_main_descr_512;
		nmtd->chip.bbt_md = &wmt_bbt_mirror_descr_512;
	}


	nmtd->scan_res = nand_scan(&nmtd->mtd, MAX_CHIP);


	if (nmtd->scan_res == 0) {
		#ifdef CONFIG_MTD_CMDLINE_PARTS
		err = add_dynamic_parts(&nmtd->mtd);
		if (err < 0) {
			printk(KERN_ERR "WMT_nand: uboot no dynamic partitions defined, use default static\n");
			/*err = -ENODEV;
			nand_release(mtd);*/
			mtd_device_register(&nmtd->mtd, nand_partitions, NUM_NAND_PARTITIONS/*nr_parts*/);
			//add_mtd_partitions(&nmtd->mtd, nand_partitions, ARRAY_SIZE(nand_partitions));
		}
		#else
		mtd_device_register(&nmtd->mtd, nand_partitions, NUM_NAND_PARTITIONS/*nr_parts*/);
		//add_mtd_partitions(&nmtd->mtd, nand_partitions, ARRAY_SIZE(nand_partitions));
		#endif

		//mtd_device_register(&nmtd->mtd, NULL, 0);
	}

	err = search_mtd_table("u-boot-logo", &ret1);
	ret = (int) ret1;
	varlen = 100;
	status = wmt_getsyspara("wmt.nfc.mtd.u-boot-logo", tmp, &varlen);
	sprintf(varval, "0x%llx", nand_partitions[ret].offset);
	if (!status || (strcmp(varval, tmp) == 0))
		status = 0;
	if (!err && status) {
		ret = wmt_setsyspara("wmt.nfc.mtd.u-boot-logo", varval);
		if (ret)
			printk(KERN_NOTICE "write u-boot-logo offset to env fail\n");
	} else if (err)
		printk(KERN_NOTICE "search u-boot-logo partition fail\n");

	err = search_mtd_table("kernel-logo", &ret1);
	ret = (int) ret1;
	varlen = 100;
	status = wmt_getsyspara("wmt.nfc.mtd.kernel-logo", tmp, &varlen);
	sprintf(varval, "0x%llx", nand_partitions[ret].offset);
	if (!status || (strcmp(varval, tmp) == 0))
		status = 0;
	if (!err && status) {
		ret = wmt_setsyspara("wmt.nfc.mtd.kernel-logo", varval);
		if (ret)
			printk(KERN_NOTICE "write kernel-logo offset to env fail\n");
	} else if (err)
		printk(KERN_NOTICE "search kernel-logo partition fail\n");


	register_reboot_notifier(&mtd->reboot_notifier);//Lch
	printk(KERN_NOTICE "nand initialised ok\n");
	return 0;

out_free_dma:
	dma_free_coherent(&pdev->dev, 17664 + 0x300, info->dmabuf, info->dmaaddr);
	
fr_regular_isr:
unmap:
exit_error:
	wmt_nand_remove(pdev);

	if (err == 0)
		err = -EINVAL;
	return err;
}

/* PM Support */
#ifdef CONFIG_PM
int wmt_nand_suspend(struct platform_device *pdev, pm_message_t state)
{
	/*struct wmt_nand_info *info = dev_get_drvdata(&pdev->dev);*/

	if (((*(volatile unsigned long *)(GPIO_BASE_ADDR + 0x100))&6) == 2) {
			*(volatile unsigned long *)PMCEU_ADDR |= (0x0010000);
		/*writel(0x0, info->reg + WMT_NFC_COMPORT0);
		writel(0x0, info->reg + WMT_NFC_COMPORT1_2);
		writel(0x0, info->reg + WMT_NFC_COMPORT3_4);
		writel(0x30, info->reg + WMT_NFC_COMPORT5_6);
		writel(0x1FF, info->reg + WMT_NFC_DMA_COUNTER);
		writel(0x41, info->reg + WMT_NFC_NAND_TYPE_SEL);
		writel(0x12123636, info->reg + WMT_NFC_READ_CYCLE_PULE_CTRL);
		writel(0x0, info->reg + WMT_NFC_CHIP_ENABLE_CTRL);
		writel(0x2, info->reg + WMT_NFC_CALC_CTRL);
		writel(0x101, info->reg + WMT_NFC_ECC_BCH_INT_MASK);
		writel(0x1, info->reg + WMT_NFC_NANDFLASH_BOOT);*/
		*(volatile unsigned long *)(NF_CTRL_CFG_BASE_ADDR + 0x88) |= (1<<5);
	printk(KERN_NOTICE "reset nand boot register NF_CTRL_CFG_BASE_ADDR + 0x88\n");
	*(volatile unsigned long *)(NF_CTRL_CFG_BASE_ADDR + 0x88) &= ~(1<<5);
	}
	printk(KERN_NOTICE "wmt_nand_suspend\n");
	return 0;
}

int wmt_nand_resume(struct platform_device *pdev)
{
	struct wmt_nand_info *info = dev_get_drvdata(&pdev->dev);
	struct wmt_nand_mtd *nmtd;
	int ret, ecc_bit_mode;
	struct ECC_size_info ECC_size;
	*(volatile unsigned long *)PMCEU_ADDR |= (0x0010000);/*add by vincent*/
	if (info) {
			nmtd = info->mtds;
		if (((*(volatile unsigned long *)(GPIO_BASE_ADDR + 0x100))&6) == 2)
			writel(0x0, info->reg + WMT_NFC_NANDFLASH_BOOT);
		/* initialise the hardware */
		ret = wmt_nfc_init(info, &nmtd->mtd);
		if (ret == 2)
			while(ret);
		nfc_ecc_set(info, 1);  /* on hw ecc */
		/* Set up DMA address */
		/*writel(info->dmaaddr & 0xffffffff, info->reg + NFC_DMA_DAR);*/
		ecc_bit_mode = (&nmtd->mtd)->dwECCBitNum;
		if (ecc_bit_mode > 24)
			ecc_bit_mode = (ecc_bit_mode == 40) ? 6 : (-1);
		else
			ecc_bit_mode = (ecc_bit_mode > 16) ? ((ecc_bit_mode/4) - 1) : (ecc_bit_mode/4);

		set_ecc_engine(info, ecc_bit_mode); /* BCH ECC */
		ECC_size.ecc_engine = ecc_bit_mode;
		calculate_ECC_info((&nmtd->mtd), &ECC_size);
		writew((ECC_size.oob_ECC_bytes<<8)/*+ ECC_size.unprotect;*/, info->reg + WMT_NFC_REMAINDER);

		printk(KERN_NOTICE "wmt_nand_resume OK\n");
	} else
		printk(KERN_NOTICE "wmt_nand_resume error\n");

	*(volatile unsigned long *)PMCEU_ADDR &= ~(0x0010000);/*add by vincent*/
	return 0;
}

#else /* else of #define PM */
#define wmt_nand_suspend NULL
#define wmt_nand_resume NULL
#endif

/*struct platform_driver wmt_nand_driver = {*/
struct platform_driver wmt_nand_driver = {
	.driver.name	= "nand",
	.probe = wmt_nand_probe,
	.remove = wmt_nand_remove,
	.suspend = wmt_nand_suspend,
	.resume = wmt_nand_resume
	/*
	.driiver = {
	.name	= "wmt-nand",
	.owner	= THIS_MODULE,
	},
	*/
};

static int __init wmt_nand_init(void)
{
	//printk(KERN_NOTICE "NAND Driver, WonderMedia Technologies, Inc\n");
	return platform_driver_register(&wmt_nand_driver);
}

static void __exit wmt_nand_exit(void)
{
	platform_driver_unregister(&wmt_nand_driver);
}

module_init(wmt_nand_init);
module_exit(wmt_nand_exit);

MODULE_AUTHOR("WonderMedia Technologies, Inc.");
MODULE_DESCRIPTION("WMT [Nand Flash Interface] driver");
MODULE_LICENSE("GPL");
